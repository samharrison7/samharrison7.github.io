var tipuesearch = {"pages":[{"title":" NanoFASE ","text":"NanoFASE Model of the environmental fate of engineered nanoparticles. Developer Info CEH","tags":"","loc":"index.html"},{"title":"UtilModule.f08 – NanoFASE","text":"Modules UtilModule Source Code UtilModule.f08 Source Code !> Module with a handful of useful globally-available procedures module UtilModule use Globals implicit none !> Return a string from an integer or real number interface str module procedure strFromInteger module procedure strFromReal module procedure strFromDp end interface interface ref module procedure ref2 module procedure ref3 module procedure ref4 end interface contains !> Convert an integer to a string pure function strFromInteger ( i ) result ( str ) integer , intent ( in ) :: i !! The integer to convert to a string character ( len = 256 ) :: str !! The string to return write ( str , * ) i str = trim ( adjustl ( str )) end function !> Convert a real to a string pure function strFromReal ( r ) result ( str ) real , intent ( in ) :: r !! The integer to convert to a string character ( len = 256 ) :: str !! The string to return write ( str , * ) r str = trim ( adjustl ( str )) end function !> Convert a double-precision real to a string pure function strFromDp ( r ) result ( str ) real ( dp ), intent ( in ) :: r !! The integer to convert to a string character ( len = 256 ) :: str !! The string to return write ( str , * ) r str = trim ( adjustl ( str )) end function !> Generate an object reference from a prefix (e.g., \"GridCell\") !! and two integers pure function ref2 ( prefix , a , b ) character ( len =* ), intent ( in ) :: prefix integer , intent ( in ) :: a integer , intent ( in ) :: b character ( len = 256 ) :: ref2 ref2 = trim ( prefix ) // \"_\" // trim ( str ( a )) // \"_\" // trim ( str ( b )) end function !> Generate an object reference from a prefix (e.g., \"RiverReach\") !! and three integers pure function ref3 ( prefix , a , b , c ) character ( len =* ), intent ( in ) :: prefix integer , intent ( in ) :: a integer , intent ( in ) :: b integer , intent ( in ) :: c character ( len = 256 ) :: ref3 ref3 = trim ( prefix ) // \"_\" // trim ( str ( a )) // \"_\" // trim ( str ( b )) // & \"_\" // trim ( str ( c )) end function !> Generate an object reference from a prefix (e.g., \"BedSediment\") !! and four integers pure function ref4 ( prefix , a , b , c , d ) character ( len =* ), intent ( in ) :: prefix integer , intent ( in ) :: a integer , intent ( in ) :: b integer , intent ( in ) :: c integer , intent ( in ) :: d character ( len = 256 ) :: ref4 ref4 = trim ( prefix ) // \"_\" // trim ( str ( a )) // \"_\" // trim ( str ( b )) // & \"_\" // trim ( str ( c )) // \"_\" // trim ( str ( d )) end function end module","tags":"","loc":"sourcefile/utilmodule.f08.html"},{"title":"main.f08 – NanoFASE","text":"Programs main Source Code main.f08 Source Code program main use Globals use UtilModule use ResultModule use classRiverReach1 use classEnvironment1 implicit none real :: start , finish ! Simulation start and finish times type ( Result ) :: r ! Result object integer :: x , y , s , t , i ! Loop iterator type ( Environment1 ) :: env ! Environment object call GLOBALS_INIT () ! Set up global vars and constants open ( unit = 2 , file = 'output.txt' ) ! Open the output data file open ( unit = 3 , file = 'output_erosion.txt' ) call cpu_time ( start ) ! Simulation start time r = env % create () ! Create the environment do t = 1 , 365 r = env % update ( t ) ! Run the simulation for 1 year do x = 1 , size ( env % colGridCells , 1 ) ! Loop through the rows do y = 1 , size ( env % colGridCells , 2 ) ! Loop through the columns if (. not . env % colGridCells ( x , y )% item % isEmpty ) then write ( 3 , * ) t , \", \" , x , \", \" , y , \", \" , & env % colGridCells ( x , y )% item % erodedSediment do s = 1 , size ( env % colGridCells ( x , y )% item % colSubRivers ) ! Loop through the SubRivers ! Write to the data file write ( 2 , * ) t , \", \" , x , & \", \" , y , \", \" , s , \", \" & , env % colGridCells ( x , y )% item % colSubRivers ( s )% item % m_spm ( 1 ), \", \" & , env % colGridCells ( x , y )% item % colSubRivers ( s )% item % m_spm ( 2 ), \", \" & , env % colGridCells ( x , y )% item % colSubRivers ( s )% item % m_spm ( 3 ), \", \" & , env % colGridCells ( x , y )% item % colSubRivers ( s )% item % m_spm ( 4 ), \", \" & , env % colGridCells ( x , y )% item % colSubRivers ( s )% item % m_spm ( 5 ) end do end if end do end do end do close ( 2 ) ! Close the output file call cpu_time ( finish ) ! Simulation finish time print * , 'Time taken to simulate and write data (s): ' , finish - start ! How long did it take? end program","tags":"","loc":"sourcefile/main.f08.html"},{"title":"Globals.f08 – NanoFASE","text":"Modules Globals Source Code Globals.f08 Source Code module Globals use json_module use mo_netcdf use ErrorCriteriaModule use ErrorInstanceModule implicit none type ( ErrorCriteria ) :: ERROR_HANDLER integer , parameter :: dp = selected_real_kind ( 15 , 307 ) integer , parameter :: qp = selected_real_kind ( 33 , 4931 ) type , public :: Constants ! Physical constants real ( dp ) :: g = 9.80665_dp !! Gravitational acceleration [m/s&#94;2] real ( dp ) :: n_river = 0.035_dp !! Manning's roughness coefficient, for natural streams and major rivers. !! [Reference](http://www.engineeringtoolbox.com/mannings-roughness-d_799.html). ! Data input real ( dp ) :: T = 1 5.0_dp !! Temperature [C] character ( len = 12 ) :: inputFile = 'data/data.nc' !! Name of the data input file. TODO: Get this from config file. ! Size class distributions real ( dp ), allocatable :: d_spm (:) !! Suspended particulate matter size class diameters [m] real ( dp ), allocatable :: d_np (:) !! Nanoparticle size class diameters [m] integer :: nSizeClassesSpm !! Number of sediment particle size classes integer :: nSizeClassesNP !! Number of nanoparticle size classes integer , allocatable :: defaultDistributionSediment (:) !! Default imposed size distribution for sediment integer , allocatable :: defaultDistributionNP (:) !! Default imposed size distribution for NPs ! Limits integer :: maxRiverReaches = 100 !! Maximum number of RiverReaches a SubRiver can have. !! TODO: Would be good if this was from config file ! Structure and time real ( dp ) :: gridCellSize !! The dimensions of each grid cell [m]. integer :: timeStep !! The timestep to run the model on [s]. integer :: nTimeSteps !! The number of timesteps. contains procedure :: rho_w , nu_w end type type ( Constants ) :: C contains !> Initialise global variables. For the moment, just error !! handling, but concievably could deal with constants, files !! and other setup tasks in the future. subroutine GLOBALS_INIT () type ( NcDataset ) :: NC !! NetCDF dataset type ( NcVariable ) :: var !! NetCDF variable type ( NcGroup ) :: grp !! NetCDF group type ( json_file ) :: config !! JSON config file logical :: jsonVarFound !! Was the JSON variable found? real ( dp ), allocatable :: spmSizeClasses (:) !! Array of sediment particle sizes real ( dp ), allocatable :: npSizeClasses (:) !! Array of nanoparticle particle sizes ! Add custom errors to the error handler call ERROR_HANDLER % init ( errors = [ & ! File operations ErrorInstance ( code = 200 , message = \"File not found.\" ), & ErrorInstance ( code = 201 , message = \"Variable not found in input file.\" ), & ErrorInstance ( code = 202 , message = \"Group not found in input file.\" ), & ErrorInstance ( code = 203 , message = \"Unknown config file option.\" ), & ! Numerical calculations ErrorInstance ( code = 300 , message = \"Newton's method failed to converge.\" ), & ! Grid and geography ErrorInstance ( code = 401 , message = \"Invalid SubRiver inflow reference. Inflow must be from a neighbouring SubRiver.\" ), & ! River routing ErrorInstance ( code = 500 , message = \"All SPM advected from RiverReach.\" , isCritical = . false .), & ErrorInstance ( code = 501 , message = \"No input data provided for required SubRiver - check nSubRivers is correct.\" ), & ! General ErrorInstance ( code = 901 , message = \"Invalid RiverReach type index provided.\" ), & ErrorInstance ( code = 902 , message = \"Invalid Biota index provided.\" ), & ErrorInstance ( code = 903 , message = \"Invalid Reactor index provided.\" ), & ErrorInstance ( code = 904 , message = \"Invalid BedSedimentLayer index provided.\" ) & ]) ! Get config options from the config file ! TODO: NOT WORKING ! call config%initialize() ! call config%load_file(filename = '../config.json') ! if (config%failed()) call ERROR_HANDLER%trigger( & !     error = ErrorInstance(code=200, message=\"Config file config.json not found.\")) ! ! call config%get('data.input_file', C%inputFile, jsonVarFound) ! ! if (.not. jsonVarFound) call ERROR_HANDLER%queue(201, message=\"data.input_file variable not found in config file.\") ! call config%get('run.timestep', C%timeStep, jsonVarFound) ! if (.not. jsonVarFound) call ERROR_HANDLER%queue( & !     error = ErrorInstance(201, message=\"run.timestep variable not found in config file.\")) ! call config%get('run.n_timesteps', C%nTimeSteps, jsonVarFound) ! if (.not. jsonVarFound) call ERROR_HANDLER%queue( & !     error = ErrorInstance(201, message=\"run.n_timesteps variable not found in config file.\")) ! call config%destroy() ! Get the sediment and nanoparticle size classes from data file nc = NcDataset ( C % inputFile , \"r\" ) ! Open dataset as read-only grp = nc % getGroup ( \"global\" ) ! Get the global variables group var = grp % getVariable ( \"spm_size_classes\" ) ! Get the sediment size classes variable call var % getData ( spmSizeClasses ) ! Get the variable's data allocate ( C % d_spm , source = spmSizeClasses ) ! Allocate to class variable var = grp % getVariable ( \"np_size_classes\" ) ! Get the sediment size classes variable call var % getData ( npSizeClasses ) ! Get the variable's data allocate ( C % d_np , source = npSizeClasses ) ! Allocate to class variable var = grp % getVariable ( \"defaultDistributionSediment\" ) ! Get the default sediment size classes distribution call var % getData ( C % defaultDistributionSediment ) ! Get the variable's data ! TODO: Check the distribution adds up to 100% var = grp % getVariable ( \"defaultDistributionNP\" ) ! Get the sediment size classes variable call var % getData ( C % defaultDistributionNP ) ! Get the variable's data var = grp % getVariable ( \"gridCellSize\" ) ! Get the size of a grid cell [m] call var % getData ( C % gridCellSize ) var = grp % getVariable ( \"timeStep\" ) ! Get the timestep to run the model on [s] call var % getData ( C % timeStep ) var = grp % getVariable ( \"nTimeSteps\" ) ! Get the number of time steps [s] call var % getData ( C % nTimeSteps ) ! Set the number of size classes C % nSizeClassesSpm = size ( C % d_spm ) C % nSizeClassesNP = size ( C % d_np ) end subroutine !> Calculate the density of water at a given temperature  T : !!  !!      \\rho_{\\text{w}}(T) = 1000 \\left( 1 - \\frac{T + 288.9414}{508929.2 (T + 68.12963) (T - 3.9863&#94;2)} \\right) !!  !! and optionally with a given salinity  S : !!  !!      \\rho_{\\text{w,s}}(T,S) = \\rho_w + AS + BS&#94;{3/2} + CS&#94;2 !!  !! where  A = 0.824493 - 0.0040899T + 0.000076438T&#94;2 -0.00000082467T&#94;3 + 0.0000000053675T&#94;4 , !!  B = -0.005724 + 0.00010227T - 0.0000016546T&#94;2  and  C = 4.8314 \\times 10&#94;{-4} . !! Reference: !!  - [D. R. Maidment, Handbook of Hydrology (2012)](https://books.google.co.uk/books/about/Handbook_of_hydrology.html?id=4_9OAAAAMAAJ) pure function rho_w ( me , T , S ) class ( Constants ), intent ( in ) :: me !! This Constants instance. real ( dp ), intent ( in ) :: T !! Temperature  T  [C]. real ( dp ), intent ( in ), optional :: S !! Salinity  S  [g/kg] real ( dp ) :: rho_w !! Density of water  \\rho_w  [kg/m**3]. if ( present ( S )) then rho_w = 100 0.0_dp * ( 1 - ( T + 28 8.9414_dp ) / ( 50892 9.2_dp * ( T + 6 8.12963_dp )) * ( T - 3.9863_dp ) ** 2 ) & + ( 0.824493_dp - 0.0040899_dp * T + 0.000076438_dp * T ** 2 - 0.00000082467_dp * T ** 3 + 0.0000000053675_dp * T ** 4 ) * S & + ( - 0.005724_dp + 0.00010227_dp * T - 0.0000016546_dp * T ** 2 ) * S ** ( 3.0_dp / 2.0_dp ) & + 0.00048314_dp * S ** 2 else rho_w = 100 0.0_dp * ( 1 - ( T + 28 8.9414_dp ) / ( 50892 9.2_dp * ( T + 6 8.12963_dp )) * ( T - 3.9863_dp ) ** 2 ) end if end function !> Calculate the kinematic viscosity of water  \\nu_w  at given temperature  T  !! and optionally salinity  S : !!  !!      \\nu_{\\text{w}}(T,S) = \\frac{1}{\\rho_w(T,S)} 2.414\\times 10&#94;{-5} 10&#94;{\\frac{247.8}{(T+273.15)-140.0}} !!  pure function nu_w ( me , T , S ) class ( Constants ), intent ( in ) :: me !! This Constants instance. real ( dp ), intent ( in ) :: T !! Temperature  T  [C]. real ( dp ), intent ( in ), optional :: S !! Salinity  S  [g/kg] real ( dp ) :: nu_w !! Kinematic viscosity of water  \\nu_{\\text{w}}  if ( present ( S )) then nu_w = ( 2.414e-5_dp * 1 0.0_dp ** ( 24 7.8_dp / (( T + 27 3.15_dp ) - 14 0.0_dp ))) / me % rho_w ( T , S ) else nu_w = ( 2.414e-5_dp * 1 0.0_dp ** ( 24 7.8_dp / (( T + 27 3.15_dp ) - 14 0.0_dp ))) / me % rho_w ( T ) end if end function end module","tags":"","loc":"sourcefile/globals.f08.html"},{"title":"classDatabase.f08 – NanoFASE","text":"Modules classDatabase Source Code classDatabase.f08 Source Code !> Module for interacting with the input data. !! TODO: Not currently working as var%getData(variable) needs a specific !! variable type passed to it, so using a polymorphic class(*) won't work !! and we would need to take an approach similar to mo_netcdf in creating !! procedures for every data type. Need to think about this a bit more. module classDatabase use ResultModule use mo_netcdf implicit none private type , public :: Database character ( len = 256 ) :: filePath type ( NcDataset ) :: file contains procedure , public :: init => initDatabase procedure , public :: destroy => destroyDatabase procedure , public :: read => readDatabase procedure , public :: get => getVariable end type contains !> Initialise the NetCDF database function initDatabase ( me , filePath ) result ( r ) class ( Database ) :: me !! This Database object character ( len =* ) :: filePath !! Path to the data file type ( Result ) :: r !! The Result object me % filePath = filePath ! Store the file path me % file = NcDataset ( me % filePath , \"r\" ) ! Open dataset as read-only end function !> Destroy the NetCDF database function destroyDatabase ( me ) result ( r ) class ( Database ) :: me type ( Result ) :: r ! me%file%close() end function function getVariable ( me , location , variable ) result ( r ) class ( Database ) :: me character ( len = 256 ), allocatable :: location (:) class ( * ) :: variable integer :: i type ( NcVariable ) :: var !! NetCDF variable type ( NcGroup ) :: grp !! NetCDF group type ( Result ) :: r do i = 1 , size ( location ) - 1 if ( i == 1 ) then if ( me % file % hasGroup ( trim ( location ( 1 )))) then grp = me % file % getGroup ( trim ( location ( 1 ))) else ! error end if else if ( grp % hasGroup ( trim ( location ( 1 )))) then grp = grp % getGroup ( trim ( location ( 1 ))) else ! error end if end if end do ! Final array element should be the variable var = grp % getVariable ( location ( i + 1 )) call var % getData ( variable ) r = Result ( data = variable ) end function !> Read data from the NetCDF database function readDatabase ( me , ref ) result ( r ) class ( Database ) :: me character ( len =* ), allocatable :: ref (:) type ( Result ) :: r end function end module","tags":"","loc":"sourcefile/classdatabase.f08.html"},{"title":"classSoilProfile1.f08 – NanoFASE","text":"Modules classSoilProfile1 Source Code classSoilProfile1.f08 Source Code !> A SoilProfile class acts as a container for a collection of !! SoilLayer objects, which collectively define the layout of !! the SoilProfile. module classSoilProfile1 use Globals ! global declarations use UtilModule ! Useful functions use mo_netcdf ! input/output handling use ResultModule ! error handling classes, required for use spcSoilProfile ! use containing object type implicit none ! force declaration of all variables type , public , extends ( SoilProfile ) :: SoilProfile1 contains procedure :: create => createSoilProfile1 ! Create the SoilProfile object. Exposed name: create procedure :: destroy => destroySoilProfile1 ! Remove the SoilProfile object and all contained objects. Exposed name: destroy procedure :: update => updateSoilProfile1 ! Update on every timestep (e.g., perform routing of water through soil) procedure :: erode => erodeSoilProfile1 ! Erode soil for a given timestep procedure :: imposeSizeDistribution => imposeSizeDistributionSoilProfile1 ! Impose size distribution on mass of sediment procedure :: parseInputData => parseInputDataSoilProfile1 ! Parse the data from the input file and store in object properties end type contains !> Creating the SoilProfile parses input data and fills !! the corresponding object properties, as well as setting !! up the contained SoilLayers. function createSoilProfile1 ( me , x , y , p , slope , n_river , area ) result ( r ) class ( SoilProfile1 ) :: me !! The SoilProfile instance. integer :: x !! Containing GridCell x position integer :: y !! Containing GridCell y position integer :: p !! SoilProfile reference (redundant for now as only one SoilProfile per GridCell) real ( dp ) :: slope !! Slope of the containing GridCell [m/m] real ( dp ) :: n_river !! Manning's roughness coefficient for the GridCell's rivers [-] real ( dp ) :: area !! The surface area of the SoilProfile [m3] type ( Result ) :: r !! The Result object ! Allocate the object properties that need to be allocate ( me % usle_C ( C % nTimeSteps )) allocate ( me % usle_alpha_half ( C % nTimeSteps )) allocate ( me % rusle2015_erodedSediment ( C % nTimeSteps )) allocate ( me % erodedSediment ( C % nTimeSteps )) allocate ( me % distributionSediment ( C % nSizeClassesSpm )) me % x = x ! GridCell x index me % y = y ! GridCell y index me % p = p ! SoilProfile index within the GridCell me % ref = trim ( ref ( \"SoilProfile\" , x , y , p )) ! Generate the reference name for the SoilProfile me % slope = slope me % n_river = n_river me % area = area ! Parse and store input data in this object r = me % parseInputData () call r % addToTrace ( \"Creating \" // trim ( me % ref )) end function function destroySoilProfile1 ( me ) result ( r ) class ( SoilProfile1 ) :: me !! This SoilProfile instance type ( Result ) :: r !! Result object to return end function function updateSoilProfile1 ( me , t , Qrunoff ) result ( r ) class ( SoilProfile1 ) :: me !! This SoilProfile instance integer :: t !! The current timestep real ( dp ) :: Qrunoff !! Runoff generated on this timestep type ( Result ) :: r !! Result object to return me % Qrunoff = Qrunoff ! Set the runoff for this timestep r = me % erode ( t ) ! Erode soil on this timestep call r % addToTrace ( \"Updating \" // trim ( me % ref ) // \" on timestep #\" // trim ( str ( t ))) end function !> Calculates soil erosion for this timstep t. Updates this GridCell's !! state variable erodedSediment accordingly. function erodeSoilProfile1 ( me , t ) result ( r ) class ( SoilProfile1 ) :: me !! This SoilProfile instance integer :: t !! The timestep we're on type ( NcDataset ) :: nc !! NetCDF dataset type ( NcVariable ) :: var !! NetCDF variable type ( NcGroup ) :: grp !! NetCDF group real ( dp ) :: Q_surf !! Surface runoff  Q_{\\text{surf}}  real ( dp ) :: t_conc !! Time of concentration  t_{\\text{tc}}  real ( dp ) :: q_peak !! Peak rainfall  q_{\\text{peak}}  real ( dp ) :: S_tot !! Total eroded sediment type ( Result ) :: r !! The Result object ! Change units of Q_surf from HMF from m3/s for the GridCell, to m3/day for the HRU, ! and only use 10% of it to drive soil erosion Q_surf = (( me % Qrunoff * me % usle_area_hru * 8640 / me % area )) ! [m3/day] ! Estimate the time of concentration t_conc = ( me % usle_L_sb ** 0.6 * me % usle_n_sb ** 0.6 ) / ( 18 * me % usle_slp_sb ) & + ( 0.62 * me % usle_L_ch * me % n_river ** 0.75 ) / ( me % usle_area_sb ** 0.125 * me % usle_slp_ch ** 0.375 ) ! Estimate the peak flow q_peak = me % usle_alpha_half ( t ) * Q_surf * me % usle_area_sb / ( 3.6 * t_conc ) ! Bring this all together to calculate eroded sediment, converted to kg/timestep (from metric ton/day) S_tot = ( 118 * C % timeStep / 864 ) * ( Q_surf * q_peak * me % usle_area_hru ) ** 0.56 & * me % usle_K * me % usle_C ( t ) * me % usle_P * me % usle_LS * me % usle_CFRG ! TODO: Need to convert sediment yield for the HRU to sediment yield for the grid cell. ! Simply scaling linearly from HRU area to grid cell area like below isn't realistic ! (not everywhere in the grid cell is going to be contributing as much as whatever ! HRU we're doing the calculation for). me % erodedSediment = me % imposeSizeDistribution ( S_tot * me % area / me % usle_area_hru ) call r % addToTrace ( \"Eroding soil on timestep #\" // trim ( str ( t ))) end function !> Impose a size class distribution on a total mass to split it up !! into separate size classes. If a size distribution has been specified !! for this SoilProfile, use that, otherwise, use the global size distribution. function imposeSizeDistributionSoilProfile1 ( me , mass ) result ( distribution ) class ( SoilProfile1 ) :: me !! This SoilProfile instance real ( dp ) :: mass !! The mass to split into size classes integer :: i !! Loop iterator for size classes real ( dp ) :: distribution ( C % nSizeClassesSpm ) !! The resulting distribution do i = 1 , C % nSizeClassesSpm distribution ( i ) = mass * me % distributionSediment ( i ) * 0.01 end do ! TODO: Check mass = sum(distribution(i)) - actually, just check sum(distributionSpm(i)) = 100 end function !> Get the data from the input file and set object properties !! accordingly, including allocation of arrays that depend on !! input data function parseInputDataSoilProfile1 ( me ) result ( r ) class ( SoilProfile1 ) :: me !! This SoilProfile instance type ( NcDataset ) :: nc !! NetCDF dataset type ( NcVariable ) :: var !! NetCDF variable type ( NcGroup ) :: grp !! NetCDF group real ( dp ), allocatable :: usle_C_min (:) !! Minimum cover factor for USLE real ( dp ), allocatable :: usle_C_av (:) !! Average cover factor for USLE integer :: usle_rock !! % rock in top of soil profile, to calculate usle_CFRG param real ( dp ), allocatable :: usle_rsd (:) !! Residue on soil surface [kg/ha] type ( Result ) :: r !! Result object to return ! Allocate the data which are time series. These must be allocatable (as opposed to ! being declared that length) to work with the mo_netcdf getData() procedure. allocate ( usle_C_min ( C % nTimeSteps )) allocate ( usle_C_av ( C % nTimeSteps )) allocate ( usle_rsd ( C % nTimeSteps )) ! Open the dataset nc = NcDataset ( C % inputFile , \"r\" ) ! Open dataset as read-only grp = nc % getGroup ( \"Environment\" ) ! Get the Environment group grp = grp % getGroup ( ref ( \"GridCell\" , me % x , me % y )) ! Get the containing GridCell's group me % ncGroup = grp % getGroup ( me % ref ) ! Get this SoilProfile's group ! Distribution used to split sediment mass into size classes if ( me % ncGroup % hasVariable ( 'distributionSediment' )) then var = me % ncGroup % getVariable ( 'distributionSediment' ) call var % getData ( me % distributionSediment ) ! Check the distribution adds up to 100% call r % addError ( & ERROR_HANDLER % equal ( & value = sum ( me % distributionSediment ), & criterion = 100 , & message = \"Specified size class distribution for sediments \" & // \"does not sum to 100%.\" & ) & ) else ! Default to value specified in globals me % distributionSediment = C % defaultDistributionSediment ! Should have been checked that it sums to 100% end if ! -- SOIL EROSION DATA ---------------------------------------------------------! ! C     Cover and land management factor, defined as the ratio of soil loss !       from land cropped under specified conditions to the corresponding loss !       from clean-tilled, continuous flow. Should be time-dependent (as crop !       cover changes). [-] if ( me % ncGroup % hasVariable ( 'usle_C' )) then ! First, check if time series of C-factors is available var = me % ncGroup % getVariable ( 'usle_C' ) call var % getData ( me % usle_C ) else ! Else, we can estimate C if ( me % ncGroup % hasVariable ( 'usle_C_min' )) then ! Use minimum C to estimate C var = me % ncGroup % getVariable ( 'usle_C_min' ) call var % getData ( usle_C_min ) else if ( me % ncGroup % hasVariable ( 'usle_C_av' )) then ! Average annual C can be used to estimate minimum C var = me % ncGroup % getVariable ( 'usle_C_av' ) call var % getData ( usle_C_av ) usle_C_min = 1.463 * log ( usle_C_av ) + 0.1034 else ! If neither exist, default C_min to 1 (fallow soil) call r % addError ( ErrorInstance ( & code = 201 , & message = \"Values for usle_C_min or usle_C_av not found in input file. \" // & \"usle_C_min defaulting to 1 (fallow soil).\" , & isCritical = . false . & )) usle_C_min = 1 end if if ( me % ncGroup % hasVariable ( 'usle_rsd' )) then ! Residue on surface also needed to esimate C [kg/ha] var = me % ncGroup % getVariable ( 'usle_rsd' ) call var % getData ( usle_rsd ) else ! Default to zero (no residue = no crops) call r % addError ( ErrorInstance ( & code = 201 , & message = \"Value for usle_rsd not found in input file. \" // & \"Defaulting to 0 (no crops).\" , & isCritical = . false . & )) usle_rsd = 0 end if ! Defaults to 0.8, based on C_min = 1 and rsd = 0. me % usle_C = exp (( log ( 0.8 ) - log ( usle_C_min )) * exp ( - 0.00115 * usle_rsd ) + log ( usle_C_min )) end if ! K     Soil erodibility factor, which depends on soil structure and is treated as !       time-independent. [t ha h ha-1 MJ-1 mm-1] if ( me % ncGroup % hasVariable ( 'usle_K' )) then var = me % ncGroup % getVariable ( 'usle_K' ) call var % getData ( me % usle_K ) else call r % addError ( ErrorInstance ( & code = 201 , & message = \"Value for usle_K not found in input file.\" & )) end if ! P     Support practice factor, the ratio of soil loss with a specific support !       practice to the corresponding loss with up-and-down slope culture. Support !       practices: Contour tillage, strip-cropping, terrace systems. [-] if ( me % ncGroup % hasVariable ( 'usle_P' )) then var = me % ncGroup % getVariable ( 'usle_P' ) call var % getData ( me % usle_P ) else call r % addError ( ErrorInstance ( & code = 201 , & message = \"Value for usle_P not found in input file. \" // & \"Defaulting to 1 (no support practice).\" , & isCritical = . false . & )) me % usle_P = 1 end if ! LS    Topographic factor, a function of the terrain's topography. [-] if ( me % ncGroup % hasVariable ( 'usle_LS' )) then var = me % ncGroup % getVariable ( 'usle_LS' ) call var % getData ( me % usle_LS ) else call r % addError ( ErrorInstance ( & code = 201 , & message = \"Value for usle_LS not found in input file.\" & )) end if ! CFRG  Coase fragment factor, CFRG = exp(0.035 * % rock in first soil layer). [-] if ( me % ncGroup % hasVariable ( 'usle_rock' )) then var = me % ncGroup % getVariable ( 'usle_rock' ) ! % rock in top of soil profile [-] call var % getData ( usle_rock ) me % usle_CFRG = exp ( - 0.052 * usle_rock ) ! Coarse fragment factor [-] else call r % addError ( ErrorInstance ( & code = 201 , & message = \"Value for usle_rock not found in input file. \" // & \"Defaulting to 0 (no rock in top soil layer).\" , & isCritical = . false . & )) me % usle_CFRG = 1 ! Default to 1 (rock_usle = 0) end if ! Params affecting q_peak ! alpha_half        Fraction of daily rainfall happening in maximum half hour. [-] if ( me % ncGroup % hasVariable ( 'usle_alpha_half' )) then var = me % ncGroup % getVariable ( 'usle_alpha_half' ) call var % getData ( me % usle_alpha_half ) else call r % addError ( ErrorInstance ( & code = 201 , & message = \"Value for usle_alpha_half not found in input file. \" // & \"Defaulting to 0.33.\" , & isCritical = . false . & )) me % usle_alpha_half = 0.33 ! Defaults to 0.33 end if ! Area of the HRU [ha] if ( me % ncGroup % hasVariable ( 'usle_area_hru' )) then var = me % ncGroup % getVariable ( 'usle_area_hru' ) call var % getData ( me % usle_area_hru ) else call r % addError ( ErrorInstance ( & code = 201 , & message = \"Value for usle_area_hru not found in input file.\" & )) end if ! Subbassin area [km2] if ( me % ncGroup % hasVariable ( 'usle_area_sb' )) then var = me % ncGroup % getVariable ( 'usle_area_sb' ) call var % getData ( me % usle_area_sb ) else if ( me % ncGroup % hasVariable ( 'usle_area_hru' )) then ! Default to area_hru, if that is present call r % addError ( ErrorInstance ( & code = 201 , & message = \"Value for usle_area_sb not found in input file. \" // & \"Defaulting to usle_area_hru (\" // trim ( str ( me % usle_area_hru )) // \" ha).\" , & isCritical = . false . & )) me % usle_area_sb = me % usle_area_hru * 0.01 ! Convert from ha to km2 else ! Otherwise, throw a critical error call r % addError ( ErrorInstance ( & code = 201 , & message = \"Value for usle_area_sb not found in input file. \" & )) end if ! Subbasin slope length [m] if ( me % ncGroup % hasVariable ( 'usle_L_sb' )) then var = me % ncGroup % getVariable ( 'usle_L_sb' ) call var % getData ( me % usle_L_sb ) else call r % addError ( ErrorInstance ( & code = 201 , & message = \"Value for usle_L_sb not found in input file. \" // & \"Defaulting to 50 m.\" , & isCritical = . false . & )) me % usle_L_sb = 50 end if ! Manning's coefficient for the subbasin. [-] if ( me % ncGroup % hasVariable ( 'usle_n_sb' )) then var = me % ncGroup % getVariable ( 'usle_n_sb' ) call var % getData ( me % usle_n_sb ) else ! Default to 0.01 (fallow, no residue) call r % addError ( ErrorInstance ( & code = 201 , & message = \"Value for usle_n_sb not found in input file. \" // & \"Defaulting to 0.01 (fallow, no residue).\" , & isCritical = . false . & )) me % usle_n_sb = 0.01 end if ! Slope of the subbasin [m/m]. Defaults to GridCell slope. if ( me % ncGroup % hasVariable ( 'usle_slp_sb' )) then var = me % ncGroup % getVariable ( 'usle_slp_sb' ) call var % getData ( me % usle_slp_sb ) else ! Default to GridCell slope, if present call r % addError ( ErrorInstance ( & code = 201 , & message = \"Value for usle_slp_sb not found in input file. \" // & \"Defaulting to GridCell slope (\" // trim ( str ( me % slope )) // \").\" , & isCritical = . false . & )) me % usle_slp_sb = me % slope end if !> Slope of the channel [m/m]. Defaults to GridCell slope. if ( me % ncGroup % hasVariable ( 'usle_slp_ch' )) then var = me % ncGroup % getVariable ( 'usle_slp_ch' ) call var % getData ( me % usle_slp_ch ) else ! Default to GridCell slope, if present call r % addError ( ErrorInstance ( & code = 201 , & message = \"Value for usle_slp_ch not found in input file. \" // & \"Defaulting to GridCell slope (\" // trim ( str ( me % slope )) // \").\" , & isCritical = . false . & )) me % usle_slp_ch = me % slope end if !> Hillslope length of the channel [km] if ( me % ncGroup % hasVariable ( 'usle_L_ch' )) then var = me % ncGroup % getVariable ( 'usle_L_ch' ) call var % getData ( me % usle_L_ch ) else call r % addError ( ErrorInstance ( & code = 201 , & message = \"Value for usle_L_ch not found in input file. \" & )) end if ! Check if RUSLE2015's eroded sediment data has been provided, for comparison's sake if ( me % ncGroup % hasVariable ( 'rusle2015_erodedSediment' )) then var = me % ncGroup % getVariable ( 'rusle2015_erodedSediment' ) call var % getData ( me % rusle2015_erodedSediment ) end if call r % addToTrace ( 'Parsing input data' ) ! Add this procedure to the trace end function end module","tags":"","loc":"sourcefile/classsoilprofile1.f08.html"},{"title":"spcSoilLayer.f08 – NanoFASE","text":"Modules spcSoilLayer Source Code spcSoilLayer.f08 Source Code module spcSoilLayer ! superclass for SoilLayer subclasses ! defines properties and methods required in any implmentation ! of a SoilLayer class ! the SoilLayer class routes, water, eroded soil (and ultimately nanoparticles) through a layer of soil ! IMPORTED MODULES ! Description ! ----------- use Globals ! global declarations use netcdf ! input/output handling use mo_netcdf ! input/output handling use ResultModule ! error handling classes, required for use ErrorInstanceModule ! generation of trace error messages implicit none ! force declaration of all variables type , abstract , public :: SoilLayer ! type declaration for superclass character ( len = 256 ) :: ref ! a name for the object ! PROPERTIES ! Description ! ----------- type ( integer ) :: GridX ! enclosing grid cell x reference type ( integer ) :: GridY ! enclosing grid cell y reference type ( real ( dp )) :: depth ! the layer depth (m) type ( real ( dp )) :: bdens ! the bulk density (kg/m3) type ( real ( dp )) :: pH ! the porewater pH type ( real ( dp )) :: SOM ! the soil organic matter content (% w/w) ! CONTAINED OBJECTS ! Description ! ----------- contains ! METHODS ! Description ! ----------- procedure ( createSoilLayer ), deferred :: create ! create the SoilLayer object. Exposed name: create procedure ( destroySoilLayer ), deferred :: destroy ! remove the SoilLayer object and all contained objects. Exposed name: destroy procedure ( updateSoilLayer ), deferred :: update ! Update on every timestep (e.g., perform routing of water through soil) end type type SoilLayerElement ! container type for class(SoilLayer), the actual type of the SoilLayer class class ( SoilLayer ), allocatable :: item ! a variable of type SoilLayer can be of any object type inheriting from the end type abstract interface function createSoilLayer ( me ) result ( r ) import SoilLayer , Result class ( SoilLayer ) :: me ! The SoilLayer instance. type ( Result ) :: r end function function destroySoilLayer ( me ) result ( r ) import SoilLayer , Result class ( SoilLayer ) :: me ! The SoilLayer instance. type ( Result ) :: r end function function updateSoilLayer ( me ) result ( r ) import SoilLayer , Result class ( SoilLayer ) :: me ! The SoilLayer instance. type ( Result ) :: r end function end interface end module","tags":"","loc":"sourcefile/spcsoillayer.f08.html"},{"title":"spcSoilProfile.f08 – NanoFASE","text":"Modules spcSoilProfile Source Code spcSoilProfile.f08 Source Code module spcSoilProfile ! superclass for SoilProfile subclasses ! defines properties and methods required in any implmentation ! of a SoilProfile class ! a SoilProfile class acts as a container for a collection of SoilLayer objects which collectively define the ! layout of the SoilProfile ! the SoilLayer class routes, water, eroded soil (and ultimately nanoparticles) through a layer of soil ! IMPORTED MODULES ! Description ! ----------- use Globals ! global declarations use spcSoilLayer ! use containing object type implicit none ! force declaration of all variables ! SoilLayer superclass type , abstract , public :: SoilProfile ! type declaration for superclass character ( len = 256 ) :: ref ! A reference name for the object integer :: x ! GridCell x reference integer :: y ! GridCell y reference integer :: p ! SoilProfile reference (not needed currently as only one SoilProfile per GridCell) type ( NcGroup ) :: ncGroup ! The NetCDF group for this object type ( SoilLayerElement ), allocatable :: colSoilLayers (:) ! array of SoilLayerElement objects to hold the soil layers type ( integer ) :: nSoilLayers ! Number of contained soil layers real ( dp ) :: Qrunoff ! Runoff from the hydrological model for this timestep real ( dp ) :: slope ! The slope of the containing GridCell real ( dp ) :: n_river ! Manning's roughness coefficient for the river real ( dp ) :: area ! The surface area of the SoilProfile real ( dp ), allocatable :: usle_C (:) ! Cover and land management factor time series [-] real ( dp ) :: usle_K ! Soil erodibility factor [t ha h ha-1 MJ-1 mm-1] real ( dp ) :: usle_LS ! Topographic factor [-] real ( dp ) :: usle_P ! Support practice factor [-] real ( dp ) :: usle_CFRG ! Coarse fragment factor [-] real ( dp ), allocatable :: usle_alpha_half (:) ! Fraction of rainfall falling during maximum half hour [-] real ( dp ) :: usle_area_hru ! Area of the HRU corresponding to this GridCell real ( dp ) :: usle_area_sb ! Area of the subbasin corresponding to this GridCell real ( dp ) :: usle_L_sb ! Hillslope length for the subbasin real ( dp ) :: usle_n_sb ! Manning's roughness coefficient for the subbasin real ( dp ) :: usle_slp_sb ! Slope of the subbasin real ( dp ) :: usle_slp_ch ! Slope of the channel real ( dp ) :: usle_L_ch ! Hillslope length for the channel real ( dp ), allocatable :: rusle2015_erodedSediment (:) ! RUSLE2015 sediment yield for this GridCell (2010): https://esdac.jrc.ec.europa.eu/content/soil-erosion-water-rusle2015 real ( dp ), allocatable :: erodedSediment (:) ! Sediment yield eroded on this timestep [kg/timestep] integer , allocatable :: distributionSediment (:) ! Distribution to split sediment into contains procedure ( createSoilProfile ), deferred :: create ! create the SoilProfile object. Exposed name: create procedure ( destroySoilProfile ), deferred :: destroy ! remove the SoilProfile object and all contained objects. Exposed name: destroy procedure ( updateSoilProfile ), deferred :: update ! Update on every timestep (e.g., perform routing of water through soil) procedure ( erodeSoilProfile ), deferred :: erode ! Erode soil on a particular timestep procedure ( imposeSizeDistributionSoilProfile ), deferred :: imposeSizeDistribution ! Impose size distribution on mass of sediment procedure ( parseInputDataSoilProfile ), deferred :: parseInputData ! Parse the data from the input file and store in object properties end type type SoilProfileElement ! container type for class(SoilProfile), the actual type of the SoilProfile class class ( SoilProfile ), allocatable :: item ! a variable of type SoilProfile can be of any object type inheriting from the end type abstract interface !> Creating the SoilProfile parses input data and fills !! the corresponding object properties, as well as setting !! up the contained SoilLayers. function createSoilProfile ( me , x , y , p , slope , n_river , area ) result ( r ) use Globals import SoilProfile , Result class ( SoilProfile ) :: me !! The SoilProfile instance. integer :: x !! Containing GridCell x position integer :: y !! Containing GridCell y position integer :: p !! SoilProfile reference real ( dp ) :: slope !! Slope of the containing GridCell [m/m] real ( dp ) :: n_river !! Manning's roughness coefficient for the GridCell's rivers [-] real ( dp ) :: area !! The area of the SoilProfile's surface type ( Result ) :: r !! Result object to return end function function destroySoilProfile ( me ) result ( r ) import SoilProfile , Result class ( SoilProfile ) :: me !! The SoilProfile instance type ( Result ) :: r !! Result object to return end function !> Perform the SoilProfile's simulation for one timestep function updateSoilProfile ( me , t , Qrunoff ) result ( r ) use Globals import SoilProfile , Result class ( SoilProfile ) :: me !! This SoilProfile instance integer :: t !! The current timestep real ( dp ) :: Qrunoff !! Runoff generated on this timestep type ( Result ) :: r !! Result object to return ! NEEDS QRUNOFF end function !> Erode soil for the current timestep function erodeSoilProfile ( me , t ) result ( r ) import SoilProfile , Result class ( SoilProfile ) :: me !! This SoilProfile instance integer :: t !! The current timestep type ( Result ) :: r !! Result object to return end function !> Impose a size class distribution on a total mass to split it up !! into separate size classes. If a size distribution has been specified !! for this SoilProfile, use that, otherwise, use the global size distribution. function imposeSizeDistributionSoilProfile ( me , mass ) result ( distribution ) use Globals import SoilProfile class ( SoilProfile ) :: me real ( dp ) :: mass real ( dp ) :: distribution ( C % nSizeClassesSpm ) end function !> Parses the input data for the SoilProfile from the data file function parseInputDataSoilProfile ( me ) result ( r ) import SoilProfile , Result class ( SoilProfile ) :: me !! This SoilProfile instance type ( Result ) :: r !! Result object to return end function end interface end module","tags":"","loc":"sourcefile/spcsoilprofile.f08.html"},{"title":"classDiffuseSource.f08 – NanoFASE","text":"Modules classDiffuseSource Source Code classDiffuseSource.f08 Source Code module classDiffuseSource use Globals use ResultModule implicit none private type , public :: DiffuseSource private contains ! Proceudres procedure :: destroy => destroyDiffuseSource end type contains function destroyDiffuseSource ( me ) result ( r ) class ( DiffuseSource ) :: me type ( Result ) :: r ! Destroy end function end module","tags":"","loc":"sourcefile/classdiffusesource.f08.html"},{"title":"classPointSource.f08 – NanoFASE","text":"Modules classPointSource Source Code classPointSource.f08 Source Code module classPointSource use Globals use ResultModule implicit none private type , public :: PointSource private contains ! Proceudres procedure :: destroy => destroyPointSource end type contains function destroyPointSource ( me ) result ( r ) class ( PointSource ) :: me type ( Result ) :: r ! Destroy end function end module","tags":"","loc":"sourcefile/classpointsource.f08.html"},{"title":"spcEnvironment.f08 – NanoFASE","text":"Modules spcEnvironment Source Code spcEnvironment.f08 Source Code module spcEnvironment use Globals use ResultModule use spcGridCell implicit none private type , public , abstract :: Environment integer , allocatable :: gridSize (:) ! Size of the grid as defined in input data file (must be allocatable for mo_netcdf) type ( GridCellElement ), allocatable :: colGridCells (:,:) ! Array of GridCellElements objects to hold polymorphic GridCells contains procedure ( createEnvironment ), deferred :: create procedure ( destroyEnvironment ), deferred :: destroy procedure ( updateEnvironment ), deferred :: update end type abstract interface !> Interface to create an Environment object function createEnvironment ( me ) result ( r ) import Environment , Result class ( Environment ), target :: me type ( Result ) :: r end function !> Interface to destroy an Environment object function destroyEnvironment ( me ) result ( r ) import Environment , Result class ( Environment ) :: me type ( Result ) :: r end function !> Interface to perform simulations in Environment function updateEnvironment ( me , t ) result ( r ) import Environment , Result class ( Environment ) :: me integer :: t type ( Result ) :: r end function end interface end module","tags":"","loc":"sourcefile/spcenvironment.f08.html"},{"title":"classEnvironment1.f08 – NanoFASE","text":"Modules classEnvironment1 Source Code classEnvironment1.f08 Source Code module classEnvironment1 use mo_netcdf use Globals use UtilModule use spcEnvironment use ResultModule use classGridCell1 implicit none private type , public , extends ( Environment ) :: Environment1 private contains procedure :: create => createEnvironment1 procedure :: destroy => destroyEnvironment1 procedure :: update => updateEnvironment1 end type contains !> Create the environment, which sets up the grid and river structure. !! The Environment instance must be a target so that SubRiver inflows !! can point to another SubRiver object ([see here](https://stackoverflow.com/questions/45761050/pointing-to-a-objects-type-variable-fortran/)) function createEnvironment1 ( me ) result ( r ) class ( Environment1 ), target :: me !! This Environment instace. Must be target so SubRivers can be pointed at. type ( Result ) :: r !! Result object to return type ( NcDataset ) :: nc !! NetCDF dataset type ( NcVariable ) :: var !! NetCDF variable type ( NcGroup ) :: grp , gcGrp !! NetCDF group integer :: x , y , s , i !! Iterators for GridCells, SubRivers and inflows integer :: iX , iY , iS !! Indices for inflow grid and SubRiver coordinates character ( len = 100 ) :: gridCellRef !! To store GridCell name in, e.g. \"GridCell_x_y\" integer :: gridCellType !! Integer representing the GridCell type logical :: isValidInflow !! Is inflow SubRiver is a neighbouring river type ( ErrorInstance ), allocatable :: errors (:) !! Errors to return ! No errors to begin with allocate ( errors ( 0 )) ! Set up the grid structure nc = NcDataset ( C % inputFile , \"r\" ) ! Open dataset as read-only grp = nc % getGroup ( \"Environment\" ) ! Get the Environment group var = grp % getVariable ( \"gridSize\" ) ! Get the grid size from the Environment call var % getData ( me % gridSize ) ! Set the size of Environment variable that holds the grid cells allocate ( me % colGridCells ( me % gridSize ( 1 ), me % gridSize ( 2 ))) ! Loop through the x dimensions of the grid do x = 1 , me % gridSize ( 1 ) ! Loop through the y dimensions of the grid do y = 1 , me % gridSize ( 2 ) gridCellRef = \"GridCell_\" // trim ( str ( x )) // & \"_\" // trim ( str ( y )) ! Check if the GridCell is defined in the data file before creating ! it and adding to colGridCells. If it doesn't exist, specify it is ! an empty GridCell. if ( grp % hasGroup ( trim ( gridCellRef ))) then ! Get the type of the GridCell (e.g., GridCell1, GridCell2) to ! create, from the data file. gcGrp = grp % getGroup ( trim ( gridCellRef )) var = gcGrp % getVariable ( \"type\" ) call var % getData ( gridCellType ) select case ( gridCellType ) case ( 1 ) allocate ( me % colGridCells ( x , y )% item , source = GridCell1 ( x , y )) case default ! TODO: Not valid type, throw an error end select else allocate ( me % colGridCells ( x , y )% item , source = GridCell1 ( x , y , isEmpty = . true .)) end if end do end do ! *** SL: ! don't we need to actually create the GridCell objects ! (and by extension the SubRivers etc.) here? or is it that ! that last block of code does that, in association with the ! 'interface GridCell1' in classGridCell1.f08? At the moment it Also ! looks as though the line ! ! allocate(me%colGridCells(x,y)%item, source=GridCell1(x,y)) ! ! will only work specifically with GridCell objects of type GridCell1? ! There's no appearent way of specifying the actual type of the GridCell... ! ...which we will need to do as we want to have (and use in anger) ! a number of different actual GridCell types ! *** ! Now we need to create links between SubRivers (wasn't possible before creating GridCells ! and their SubRivers). We will point SubRivers' inflows array elements to GridCells' colSubRivers ! array elements. ! TODO: Do something with result object! And audit that inflows are coming from rational cells do x = 1 , size ( me % colGridCells , 1 ) ! Loop through the rows do y = 1 , size ( me % colGridCells , 2 ) ! Loop through the columns if (. not . me % colGridCells ( x , y )% item % isEmpty ) then do s = 1 , size ( me % colGridCells ( x , y )% item % colSubRivers ) ! Loop through the SubRivers associate ( subRiver => me % colGridCells ( x , y )% item % colSubRivers ( s )% item ) do i = 1 , subRiver % nInflows ! Loop through the inflows ! Get the inflow coordinates iX = subRiver % inflowRefs ( i )% gridX iY = subRiver % inflowRefs ( i )% gridY iS = subRiver % inflowRefs ( i )% subRiver ! *** SL: ! is this the best place to do the auditing? ! I'm thinking that there could be errors that need careful thinking about ! in order to structure the code to pick them up, ! an example would be where a SubRiver is incorrectly linked to more than one ! downstream SubRiver. This could happen because of the way we are linking ! i.e. that the links are held in the downstream SubRiver and point at the \"upstream\" ! SubRiver(s). (Actually, all this means is that no two pointers from a SubRiver to an upstream ! SubRiver can be the same). ! Worth having a sit-down to go through how to structure this auditing. ! *** isValidInflow = . true . ! Check that (iX, iY) is a neighbouring or the same GridCell if ( abs ( iX - x ) > 1 . or . abs ( iY - y ) > 1 ) isValidInflow = . false . ! If the inflow is coming from different cell, is it from the outflow to that cell? if (( iX /= x . or . iY /= y ) & . and . ( me % colGridCells ( iX , iY )% item % nSubRivers /= iS )) isValidInflow = . false . ! If invalid inflow, generate an error if (. not . isValidInflow ) then errors = [ errors , ErrorInstance ( & code = 401 , & message = \"Invalid SubRiver inflow from \" & // trim ( adjustl ( me % colGridCells ( iX , iY )% item % colSubRivers ( iS )% item % ref )) // & \" to \" // trim ( adjustl ( subRiver % ref )) // & \". Inflow must be from a neighbouring SubRiver.\" & )] end if ! Point this SubRiver's inflows pointer to the corresponding SubRiver subRiver % inflows ( i )% item => me % colGridCells ( iX , iY )% item % colSubRivers ( iS )% item end do end associate end do end if end do end do call r % addErrors ( errors ) ! Add any errors that have occurred call ERROR_HANDLER % trigger ( errors = errors ) end function !> Destroy the Environment instance function destroyEnvironment1 ( me ) result ( r ) class ( Environment1 ) :: me type ( Result ) :: r ! Destroy logic here end function !> Perform simulations for the Environment function updateEnvironment1 ( me , t ) result ( r ) class ( Environment1 ) :: me !! This Environment instance integer :: t !! Current time step type ( Result ) :: r integer :: x , y , s ! Perform the main routing procedure do x = 1 , size ( me % colGridCells , 1 ) ! Loop through the rows do y = 1 , size ( me % colGridCells , 2 ) ! Loop through the columns r = me % colGridCells ( x , y )% item % update ( t ) ! Run routing simulation for each GridCell end do end do ! Finalise the routing by setting outflows to temporary outflows that were stored ! to avoid routing using the wrong timestep's outflow as an inflow. do x = 1 , size ( me % colGridCells , 1 ) ! Loop through the rows do y = 1 , size ( me % colGridCells , 2 ) ! Loop through the columns r = me % colGridCells ( x , y )% item % finaliseUpdate () ! finaliseUpdate() loops through SubRivers end do end do ! *** SL comments re SubRiver routing and the SubRiver%routing() function: ! the SubRiver%routing() command needs to go into a separate function (in GridCell not Environment???) that executes whatever ! transport commands are needed to route water and sediment etc. through and in a specific GridCell. ! At the moment we can focus solely on water and suspended sediment routing through a river system, ! but ultimately we need to loop through all GridCells of all types and handle routing for all possible ! situations, e.g. soil-> river/lake, in-lake water movements, estuarine transport, and marine transport. ! This is going to need some careful thinking because at the moment, considering only riverine transport, ! we are only dealing with a situation where water and sediment move in a single direction. For some groups ! of GridCell types we need to consider two-way exchange of material - particularly for the marine GridCells. ! We may well need, for example, to treat the marine cells as a distinct collection within Environment in ! order to achieve this. ! *** end function end module","tags":"","loc":"sourcefile/classenvironment1.f08.html"},{"title":"classBedSedimentLayer1.f08 – NanoFASE","text":"Modules classBedSedimentLayer1 Source Code classBedSedimentLayer1.f08 Source Code !> class definition for BedSedimentLayer1 module classBedSedimentLayer1 use spcBedSedimentLayer ! use BedSedimentLayer superclass use Globals use UtilModule use ResultModule use ErrorInstanceModule implicit none ! force declaration of all variables type , public , extends ( BedSedimentLayer ) :: & BedSedimentLayer1 ! type declaration for class - extends abstract superclass ! private real(dp), allocatable :: C_f_l(:)                    ! LOCAL capacity for fine sediment [m3 m-2] ! private real(dp), allocatable :: C_w_l(:)                    ! LOCAL capacity for water [m3 m-2] contains ! methods deferred from superclass procedure , public :: & create => createBedSedimentLayer1 ! constructor method procedure , public :: & destroy => destroyBedSedimentLayer1 ! finaliser method procedure , public :: & addSediment => addSediment1 ! add fine sediment to the layer procedure , public :: & removeSediment => removeSediment1 ! remove fine sediment from layer end type contains !> initialise a BedSedimentLayer object: !!  - sets number of particle size classes !!  - reads in fixed layer volume !!  - reads in volumes of fine sediment and water in each size class !!  - sets volume of coarse material function createBedSedimentLayer1 ( Me , & n , & nsc , & FSType , & C_tot , & f_comp , & pd_comp , & Porosity , & V_f , & M_f ) result ( r ) class ( BedSedimentLayer1 ) :: Me !! the BedSedimentLayer instance type ( Result ) :: r !! The Result object. character ( len = 256 ) :: n !! a name for the object integer , intent ( in ) :: nsc !! the number of particle size classes integer , intent ( in ) :: FSType !! the type identification number of the FineSediment(s) real ( dp ), intent ( in ) :: C_tot !! the total volume of the layer real ( dp ), intent ( in ) :: f_comp (:,:) !! set of fractional compositions. Index 1 = size class, Index 2 = compositional fraction real ( dp ), intent ( in ), allocatable :: pd_comp (:) !! set of fractional particle densities real ( dp ), intent ( in ), optional :: Porosity !! layer porosity, if being used to define layer real ( dp ), intent ( in ), optional :: V_f (:) !! set of fine sediment volumes, if being used to define layer real ( dp ), intent ( in ), optional :: M_f (:) !! set of fine sediment masses, if being used to define layer type ( ErrorInstance ) :: er ! LOCAL ErrorCriteria object for error handling. type ( FineSediment1 ), allocatable :: fs1 ! LOCAL object of type FineSediment1, for implementation of polymorphism character ( len = 256 ) :: tr ! LOCAL name of this procedure, for trace real ( dp ) :: fwr ! LOCAL fine sediment to water ratio integer :: S ! LOCAL loop counter ! ! Function purpose ! ------------------------------------------------------------------------------- ! initialise a BedSedimentLayer object and its constituent ! FineSediment objects ! ! Function inputs ! ------------------------------------------------------------------------------- ! Function takes as inputs: ! n (character)         a name unambiguously identifying the object ! nsc (integer)         the number of size classes of sediment ! FStype (integer)      the subtype of the spcFineSediment Superclass to use !                       to create fine sediment objects ! C_tot (real, dp)      The total volume of the layer [m3 m-2] ! V_f(:) (real, dp)     OPTIONAL array of initial fine sediment volumes [m3 m-2] ! M_f(:) (real, dp)     OPTIONAL array of initial fine sediment masses [kg m-2] ! F_comp(:,:) (real, dp) array of fractional compositions for each size class ! Porosity (real, dp)   OPTIONAL sediment porosity ! ! Function outputs/outcomes ! ------------------------------------------------------------------------------- ! No specific outputs: results are initialisation of variables and objects ! ! Notes ! ------------------------------------------------------------------------------- ! This function fills all available space in the layer with fine sediment, ! water and coarse material. There are two calling conventions: ! 1.    Specify V_f(:) or M_f(:) and porosity. Water volumes are computed from !       porosity. Any remaining capacity is filled by coarse material. ! 2.    Specify V_f(:) or M_f(:) only. Space not occupied by fine sediment is !       occupied by water. ! If both V_f and M_f are specified then V_f will be used. ! ------------------------------------------------------------------------------- tr = \"create\" ! procedure binding name as trace if ( len_trim ( n ) == 0 ) then call r % addError ( ErrorInstance ( & code = 1 , & message = \"An object name has not & been provided\" , & trace = [ \"classBedSedimentLayer1%create\" ] & )) ! error if name is not provided return ! critical error, so exit here end if Me % name = n if ( nsc <= 0 ) then ! CRITICAL ERROR HERE: nsc <= 0 call r % addError ( ErrorInstance ( & code = 1 , & message = \"Invalid number of particle & size classes\" & )) end if if ( C_tot == 0 ) then ! CRITICAL ERROR HERE: C_tot = 0 call r % addError ( ErrorInstance ( & code = 1 , & message = \"Layer volume is zero\" & )) end if if ((. not . present ( V_f )) . and . (. not . present ( M_f ))) then call r % addError ( ErrorInstance ( & code = 1 , & message = \"One of fine sediment volume & and mass must be specified\" & )) ! create error instance end if if ( present ( V_f )) then if ( size ( V_f ) /= nsc ) then ! array of fine sediment masses must have correct size call r % addError ( ErrorInstance ( & code = 1 , & message = \"Array of fine sediment & volumes is the wrong & size\" & )) ! create error instance end if end if if ( present ( M_f )) then if ( size ( M_f ) /= nsc ) then ! array of fine sediment masses must have correct size call r % AddError ( ErrorInstance ( & code = 1 , & message = \"Array of fine sediment & masses is the wrong & size\" & ) & ) ! create error instance end if end if if ( size ( f_comp , 1 ) /= nsc ) then ! number of size classes must be consistent call r % AddError ( ErrorInstance ( & code = 1 , & message = \"Array of fractional & compositions is the wrong & size\" & ) & ) ! create error instance end if if ( size ( f_comp , 2 ) /= size ( pd_comp )) then ! number of compositional fractions must be consistent call r % AddError ( ErrorInstance ( & code = 1 , & message = \"Arrays of fractional & compositions and particle & densities have different & sizes\" & ) & ) ! create error instance end if if ( present ( Porosity )) then if ( Porosity <= 0 . or . Porosity >= 1 ) then call r % AddError ( ErrorInstance ( & code = 1 , & message = \"Porosity is out of range\" & ) & ) ! create error instance end if end if tr = Me % name // \"%\" // tr ! add name to trace string if ( r % hasCriticalError ()) then ! if a critical error has been thrown call r % addToTrace ( tr ) ! add trace to Result return ! exit, as a critical error has occurred end if Me % nSizeClasses = nsc ! store number of size classes Me % nfComp = size ( f_comp , 2 ) ! store number of fractional composition terms Me % C_total = C_tot ! assign the total volume tr = Me % name // & \"%createBedSedimentLayer1%colFineSediment\" ! trace message allocate ( Me % colFineSediment ( 1 : nsc ), stat = Me % allst ) ! set up fine sediment collection if ( Me % allst /= 0 ) then er = ErrorInstance ( 1 , & \"Allocation error\" , & . false ., & [ tr ] & ) ! create warning if error thrown call r % addError ( er ) ! add to Result end if tr = Me % name // & \"%createBedSedimentLayer1%C_f_l\" ! trace message allocate ( Me % C_f_l ( 1 : nsc ), stat = Me % allst ) ! allocate space for fine sediment capacity if ( Me % allst /= 0 ) then er = ErrorInstance ( 1 , & \"Allocation error\" , & . false ., & [ tr ] & ) ! create warning if error thrown call r % addError ( er ) ! add to Result end if tr = Me % name // & \"%createBedSedimentLayer1%C_w_l\" ! trace message allocate ( Me % C_w_l ( 1 : nsc ), stat = Me % allst ) ! allocate space for water capacity if ( Me % allst /= 0 ) then er = ErrorInstance ( 1 , & \"Allocation error\" , & . false ., & [ tr ] & ) ! create warning if error thrown call r % addError ( er ) ! add to Result end if tr = Me % name // & \"%createBedSedimentLayer1%pd_comp\" ! trace message allocate ( Me % pd_comp ( 1 : size ( pd_comp )), stat = Me % allst ) ! allocate space for particle densities of components if ( Me % allst /= 0 ) then er = ErrorInstance ( 1 , & \"Allocation error\" , & . false ., & [ tr ] & ) ! create warning if error thrown call r % addError ( er ) ! add to Result end if if ( r % hasCriticalError ()) return ! exit if allocation has thrown an error do S = 1 , nsc associate ( O => Me % colFineSediment ( S )% item ) ! association for the FineSediment object we are working with ! this is done to reduce code length and increase readability select case ( FSType ) ! loop through possible FineSediment object types case ( 1 ) ! Type FineSediment1 tr = Me % name // & \"%createBedSedimentLayer1%pd_comp\" ! trace message allocate ( fs1 , stat = Me % allst ) ! create FineSediment1 object if ( Me % allst /= 0 ) then er = ErrorInstance ( 1 , & \"Allocation error\" , & . false ., & [ tr ] & ) ! create warning if error thrown call r % addError ( er ) ! add to Result if ( r % hasCriticalError ()) return ! exit if allocation has thrown an error end if call r % addErrors ( & . errors . fs1 % create ( & ! run constructor for this object Me % name , & Me % pd_comp & ) & ) call move_alloc ( fs1 , & Me % colFineSediment ( S )% item ) ! move the object into the colFineSediment collection; this deallocates fs1 case default ! not a recognised FineSediment type call r % addError ( ErrorInstance ( & code = 1 , & message = \"Invalid & FineSediment & object type & specified\" & ) & ) ! add ErrorInstance call r % addToTrace ( tr ) ! add trace to Result return ! critical error, so exit end select if ( present ( V_f )) then call r % addErrors (. errors . & O % set ( Vf_in = V_f ( S ), & f_comp_in = f_comp ( S ,:) & ) & ) ! if V_f values are defined, set up FineSediment using V_f if ( r % hasCriticalError ()) then ! if a critical error has been thrown call r % addToTrace ( tr ) ! add trace to Result return ! exit, as a critical error has occurred end if elseif ( present ( M_f )) then ! QUERY: can we return from Set_M into an ErrorCriteria instance and then test for criticality !        in order to determine whether to exit immediately? call r % addErrors (. errors . & O % set ( Mf_in = M_f ( S ), & f_comp_in = f_comp ( S ,:) & ) & ) ! otherwise if M_f values are defined, set up FineSediment using M_f if ( r % hasCriticalError ()) then ! if a critical error has been thrown call r % addToTrace ( tr ) ! add trace to Result return ! exit, as a critical error has occurred end if end if end associate Me % C_f_l ( S ) = V_f ( S ) ! set the sediment capacities, using the local value end do if ( Me % V_f_layer () > C_tot ) then ! CRITICAL ERROR HERE: if Me%V_f_layer > C_tot call r % addError ( ErrorInstance ( & code = 1 , & message = \"Fine sediment volume & exceeds capacity\" & ) & ) ! add ErrorInstance return ! critical error, so exit end if if ( r % hasCriticalError ()) then ! if a critical error has been thrown call r % addToTrace ( tr ) ! add trace to Result return ! exit, as a critical error has occurred end if if ( present ( Porosity )) then ! has a porosity value been supplied? fwr = Porosity / ( 1 - Porosity ) ! yes, use porosity to compute factor for sediment:water ratio else ! fwr = ( Me % C_total - Me % C_f_layer ()) / Me % C_f_layer () ! no, so use C_total and C_f_layer to compute factor for end if ! sediment:water ratio do S = 1 , nsc ! compute V_w for each size fraction using the sediment:water ratio associate ( O => Me % colFineSediment ( S )% item ) ! association for the FineSediment object we are working with call r % addErrors (. errors . & O % set ( Vw_in = O % V_f () * fwr )) ! is used to compute the volume of associated water if ( r % hasCriticalError ()) then ! if a critical error has been thrown call r % addToTrace ( tr ) ! add trace to Result return ! exit, as a critical error has occurred end if end associate end do do S = 1 , nsc ! loop through all size fractions Me % C_w_l ( S ) = Me % colFineSediment ( S )% item % V_w () ! set the water capacities, using the local variable end do if ( Me % V_m_layer () > C_tot ) then ! CRITICAL ERROR HERE: if Me%V_m_layer > C_tot call r % addError ( ErrorInstance ( & code = 1 , & message = \"Fine sediment & & water volume & exceeds capacity\" & ) & ) ! add ErrorInstance call r % addToTrace ( tr ) ! add trace to Result return ! critical error, so exit end if Me % V_c = C_tot - Me % V_m_layer () ! set the coarse material volume end function !> destroy this object function destroyBedSedimentLayer1 ( Me ) result ( r ) class ( BedSedimentLayer1 ) :: Me !! the BedSedimentLayer instance type ( Result ) :: r !! The Result object type ( ErrorInstance ) :: er ! LOCAL ErrorCriteria object for error handling. character ( len = 256 ) :: tr ! LOCAL name of this procedure, for trace character ( len = 18 ), parameter :: & ms = \"Deallocation error\" ! LOCAL CONSTANT error message ! ! Function purpose ! ------------------------------------------------------------------------------- ! Deallocate all allocated variables in this object. ! ! Function inputs ! ------------------------------------------------------------------------------- ! no inputs ! ! Function outputs/outcomes ! ------------------------------------------------------------------------------- ! F returns the amounts of sediment and water that could not be added ! ! Notes ! ------------------------------------------------------------------------------- ! No notes. ! ------------------------------------------------------------------------------- tr = Me % name // & \"%destroyBedSedimentLayer1%colFineSediment\" ! trace message deallocate ( Me % colFineSediment , stat = Me % allst ) ! deallocate all allocatable variables if ( Me % allst /= 0 ) then er = ErrorInstance ( 1 , & ms , & . false ., & [ tr ] & ) ! create warning if error thrown call r % addError ( er ) ! add to Result end if tr = Me % name // & \"%destroyBedSedimentLayer1%pd_comp\" ! trace message deallocate ( Me % pd_comp , stat = Me % allst ) if ( Me % allst /= 0 ) then er = ErrorInstance ( 1 , & ms , & . false ., & [ tr ] & ) ! create warning if error thrown call r % addError ( er ) ! add to Result end if tr = Me % name // & \"%destroyBedSedimentLayer1%C_f_l\" ! trace message deallocate ( Me % C_f_l , stat = Me % allst ) if ( Me % allst /= 0 ) then er = ErrorInstance ( 1 , & ms , & . false ., & [ tr ] & ) ! create warning if error thrown call r % addError ( er ) ! add to Result end if tr = Me % name // & \"%destroyBedSedimentLayer1%C_w_l\" ! trace message deallocate ( Me % C_w_l , stat = Me % allst ) if ( Me % allst /= 0 ) then er = ErrorInstance ( 1 , & ms , & . false ., & [ tr ] & ) ! create warning if error thrown call r % addError ( er ) ! add to Result end if end function !> add sediment and water to this layer function addSediment1 ( Me , S , F ) result ( r ) implicit none class ( BedSedimentLayer1 ) :: Me !! the BedSedimentLayer instance integer , intent ( in ) :: S !! the particle size class type ( FineSediment1 ), intent ( inout ) :: F !! FineSediment - holds material to be added type ( Result ) :: r !! The Result object real ( dp ) :: add_M_f ! LOCAL mass of fine sediment being added real ( dp ) :: add_V_f ! LOCAL volume of fine sediment to be added real ( dp ) :: add_V_w ! LOCAL volume of water to be added real ( dp ) :: M_f_SC ! LOCAL mass of fine sediment in receiving size class real ( dp ) :: V_f_SC ! LOCAL volume of fine sediment in receiving size class real ( dp ) :: A_f_SC ! LOCAL capacity for fine sediment in receiving size class real ( dp ) :: V_w_SC ! LOCAL volume of water in receiving size class real ( dp ) :: A_w_SC ! LOCAL capacity for water in receiving size class real ( dp ) :: V_f_added ! LOCAL volume of water added real ( dp ) :: Mf ! LOCAL temporary variable real ( dp ), allocatable :: t_comp (:) ! LOCAL temporary variable integer :: x ! LOCAL loop counter character ( len = 256 ) :: tr ! LOCAL name of this procedure, for trace ! ! Function purpose ! ------------------------------------------------------------------------------- ! Add fine sediment of a specified size fraction, and water, to this layer. ! ! Function inputs ! ------------------------------------------------------------------------------- ! Function takes as inputs: ! S (integer)       the size class to which sediment is to be added ! F (FineSediment1) object representing the FineSediment to be added ! ! Function outputs/outcomes ! ------------------------------------------------------------------------------- ! F returns the amounts of sediment and water that could not be added ! ! Notes ! ------------------------------------------------------------------------------- ! No notes. ! ------------------------------------------------------------------------------- tr = Me % name // \"%addSediment1\" ! trace for this procedure if ( S <= 0 . or . S > Me % nSizeClasses ) then ! CRITICAL ERROR HERE: if S <= 0 or S > nSizeClasses call r % addError ( ErrorInstance ( code = 1 , & message = \"The size class is out of & range\" & )) end if if ( size ( F % f_comp ) /= Me % nFComp ) then ! CRITICAL ERROR HERE: if S <= 0 or S > nSizeClasses call r % addError ( ErrorInstance ( code = 1 , & message = \"The number of & compositional fractions & in input is incorrect\" & )) end if add_V_f = F % V_f () ! static local copy of added fine sediment volume if ( add_V_f <= 0 ) then ! CRITICAL ERROR HERE: if add_V_f < 0 call r % addError ( ErrorInstance ( code = 1 , & message = \"The added fine sediment & volume in size class \" & // trim ( str ( S )) // & \" is less than zero\" & )) end if add_V_w = F % V_w () ! static local copy of added water volume if ( add_V_w <= 0 ) then ! CRITICAL ERROR HERE: if add_V_w < 0 call r % addError ( ErrorInstance ( code = 1 , & message = \"The added water & volume in size class \" & // trim ( str ( S )) // & \" is less than zero\" & )) end if if ( r % hasCriticalError ()) then ! if AddSediment throws a critical error call r % addToTrace ( tr ) ! add trace to all errors return ! and exit end if tr = Me % name // & \"%createBedSedimentLayer1%t_comp\" ! trace message allocate ( t_comp ( 1 : Me % nfComp ), stat = Me % allst ) ! for storage of modified fractional composition of modified sediment if ( Me % allst /= 0 ) then call r % addError ( ErrorInstance ( 1 , & \"Allocation error\" , & . false ., & [ tr ] & )) ! create warning if error thrown return ! critical error, so return end if A_f_SC = Me % A_f ( S ) ! static local copy of fine sediment capacity A_w_SC = Me % A_w ( S ) ! static local copy of water capacity associate ( O => Me % colFineSediment ( S )% item ) M_f_SC = O % M_f () ! fine sediment mass in layer V_f_SC = O % V_f () ! fine sediment volume in layer V_w_SC = O % V_w () ! water volume in layer if ( add_V_f > A_f_SC ) then ! added volume exceeds the available capacity; cannot all be added V_f_SC = Me % C_f_l ( S ) ! set fine sediment volume to capacity add_V_f = add_V_f - A_f_SC ! volume that could not be added V_f_added = V_f_SC - A_f_SC ! volume added else ! added volume does not exceed the fine sediment capacity; can all be added V_f_SC = V_f_SC + add_V_f ! addition of fine sediment volume add_V_f = 0 ! return zero volume not added V_f_added = add_V_f ! volume added end if if ( add_V_w > A_w_SC ) then ! added volume exceeds the available capacity; cannot all be added V_w_SC = Me % C_w_l ( S ) ! set water volume to capacity add_V_w = add_V_w - A_w_SC ! volume that could not be added else ! added volume does not exceed the fine sediment capacity; can all be added V_w_SC = V_w_SC + add_V_w ! addition of water volume add_V_w = 0 ! return zero volume not added end if Mf = V_f_added * F % rho_part () ! read in added mass - prevents multiple calls to object do x = 1 , Me % nfComp ! in this subsequent loop t_comp ( x ) = M_f_SC * O % f_comp ( x ) t_comp ( x ) = t_comp ( x ) + Mf * F % f_comp ( x ) t_comp ( x ) = t_comp ( x ) / ( M_f_SC + Mf ) ! modified fraction of component no. x end do call r % addErrors (. errors . O % set ( Vf_in = V_f_SC , & Vw_in = V_w_SC , & f_comp_in = t_comp & ) & ) ! copy modified properties to fine sediment, add any error to Result object if ( r % hasCriticalError ()) then ! if a critical error has been thrown call r % addToTrace ( tr ) ! add trace to all errors return ! and exit end if end associate call r % addErrors (. errors . F % set ( Vf_in = add_V_f , & Vw_in = add_V_w & ) & ) ! return volumes of fine sediment and water not added, add any error to Result object if ( r % hasCriticalError ()) then ! if a critical error has been thrown call r % addToTrace ( tr ) ! add trace to all errors return ! and exit end if end function !> remove sediment and water from this layer function removeSediment1 ( Me , S , G ) result ( r ) implicit none class ( BedSedimentLayer1 ) :: Me ! the BedSedimentLayer instance integer , intent ( in ) :: S ! the particle size class type ( FineSediment1 ), intent ( in ) :: G ! fine sediment to be removed type ( Result1D ) :: r ! The Result object. Result%data(1) = fine sediment that was removed; Result%data(2) = fine sediment that could not be removed type ( FineSediment1 ) :: F ! LOCAL returns fine sediment that was removed real ( dp ) :: V_f_SC ! LOCAL fine sediment volume in layer real ( dp ) :: V_f_SC_r ! LOCAL fine sediment volume removed real ( dp ) :: V_w_SC ! LOCAL water volume in layer real ( dp ) :: V_w_SC_r ! LOCAL water volume removed character ( len = 256 ) :: tr ! LOCAL error trace ! Function purpose ! ------------------------------------------------------------------------------- ! Removes fine sediment and associated water from this layer. ! ! Function inputs ! ------------------------------------------------------------------------------- ! Function takes as inputs: ! S (integer)       the size class from which sediment is to be removed ! G (FineSediment1) sediment to be removed ! ! Function outputs/outcomes ! ------------------------------------------------------------------------------- ! r(1) returns the sediment that was removed ! r(2) returns the sediment that could not be removed ! ! Notes ! ------------------------------------------------------------------------------- ! No notes. ! ------------------------------------------------------------------------------- tr = Me % name // \"%removeSediment1\" ! trace for this procedure if ( S <= 0 . or . S > Me % nSizeClasses ) then ! CRITICAL ERROR HERE: if S <= 0 or S > nSizeClasses call r % addError ( ErrorInstance ( & code = 1 , & message = \"The size class is out of & range\" & )) end if V_f_SC_r = G % V_f () ! static local copy of fine sediment volume to be removed if ( V_f_SC_r <= 0 ) then ! CRITICAL ERROR HERE: if V_f_SC_r < 0 call r % addError ( ErrorInstance ( & code = 1 , & message = \"The removed fine sediment & volume in size class \" & // trim ( str ( S )) // & \" is less than zero\" & )) end if V_w_SC_r = G % V_w () ! static local copy of water volume to be removed if ( V_w_SC_r <= 0 ) then ! CRITICAL ERROR HERE: if V_w_SC_r < 0 call r % addError ( ErrorInstance ( & code = 1 , & message = \"The removed water volume & in size class \" & // trim ( str ( S )) // & \" is less than zero\" & )) end if if ( r % hasCriticalError ()) then ! if a critical error has been thrown call r % addToTrace ( tr ) ! add a trace message to any errors return ! exit here end if associate ( O => Me % colFineSediment ( S )% item ) V_f_SC = O % V_f () ! static local copy of fine sediment volume V_w_SC = O % V_w () ! static local copy of water volume if ( V_f_SC_r > V_f_SC ) V_f_SC_r = V_f_SC ! set actual volume of fine sediment to be removed if ( V_w_SC_r > V_w_SC ) V_w_SC_r = V_w_SC ! set actual volume of water to be removed call r % addErrors (. errors . O % set ( & Vf_in = V_f_SC - V_f_SC_r , & Vw_in = V_w_SC - V_w_SC_r & ) & ) ! update fine sediment in layer ! fractional composition unchanged if ( r % hasCriticalError ()) then ! if a critical error has been thrown call r % addToTrace ( tr ) ! add a trace message to any errors return ! exit here end if tr = Me % name // \"%removeSediment1%r\" ! trace message call r % addErrors (. errors . F % set ( & Vf_in = V_f_SC_r , & Vw_in = V_w_SC_r , & f_comp_in = O % f_comp & ) & ) ! set properties of the sediment being removed, including fractional composition if ( r % hasCriticalError ()) then ! if a critical error has been thrown call r % addToTrace ( tr ) ! add a trace message to any errors return ! exit here end if end associate call r % addErrors (. errors . G % set ( & Vf_in = G % V_f () - V_f_SC_r , & Vw_in = G % V_w () - V_w_SC_r & ) & ) ! return the volume that could not be removed if ( r % hasCriticalError ()) then ! if a critical error has been thrown call r % addToTrace ( tr ) ! add a trace message to any errors return ! exit here end if r = Result ( data = [ F , G ]) ! Result%data(1) = fine sediment that was removed; Result%data(2) = fine sediment that could not be removed end function end module","tags":"","loc":"sourcefile/classbedsedimentlayer1.f08.html"},{"title":"spcBedSedimentLayer.f08 – NanoFASE","text":"Modules spcBedSedimentLayer Source Code spcBedSedimentLayer.f08 Source Code !> abstract superclass definition for BedSedimentLayer !! defines the properties and methods shared by all BedSedimentLayer objects !! objects of this class cannot be instantiated, only objects of its subclasses module spcBedSedimentLayer use Globals use ResultModule ! error handling classes, required for use ErrorInstanceModule ! generation of trace error messages use classFineSediment1 ! USEs all subclasses of FineSediment implicit none ! force declaration of all variables type FineSedimentElement class ( FineSediment1 ), allocatable :: item !! Storing polymorphic class(FineSediment) in derived type so that a set of end type ! different extended types of FineSediment can be stored in an array. type , abstract , public :: BedSedimentLayer !! type declaration for superclass character ( len = 256 ) :: name !! a name for the object ! define variables for 'has a' objects: Biota and Reactor ! properties real ( dp ), allocatable :: C_f_l (:) !! capacity for fine sediment [m3 m-2] real ( dp ), allocatable :: C_w_l (:) !! capacity for water [m3 m-2] class ( FineSedimentElement ), allocatable :: & colFineSediment (:) !! collection of FineSediment objects real ( dp ) :: C_total !! total capacity [m3 m-2] real ( dp ) :: V_c !! coarse material volume [m3 m-2] real ( dp ), allocatable :: pd_comp (:) !! particle densities of sediment components [kg m-3] integer :: nSizeClasses !! number of sediment size classes integer :: nfComp !! number of fractional composition terms for sediment integer :: allst !! array allocation status contains ! non-deferred methods: defined here. Can be overwritten in subclasses procedure , public :: A_f => GetAf ! available capacity for a fine sediment size fraction procedure , public :: A_w => GetAw ! available capacity for water associated with a fine sediment size fraction procedure , public :: C_f => GetCf ! return total capacity for a fine sediment size fraction procedure , public :: C_w => GetCw ! return total capacity for water associated with a fine sediment size fraction procedure , public :: volSLR => GetvolSLR ! return volumetric solid:liquid ratio for this layer; applies to all size classes procedure , public :: C_f_layer => GetCflayer ! return total fine sediment capacity in the layer procedure , public :: M_f_layer => GetMflayer ! return total fine sediment mass in the layer procedure , public :: V_f_layer => GetVflayer ! return total fine sediment volume in the layer procedure , public :: V_w_layer => GetVwlayer ! return total water volume in the layer procedure , public :: C_w_layer => GetCwlayer ! return total water capacity in the layer procedure , public :: V_m_layer => GetVmlayer ! return total fine sediment and water volume in the layer procedure , public :: V_layer => GetVlayer ! return sum of fine sediment, water and coarse material volumes in the layer ! deferred methods: must be defined in all subclasses procedure ( createBedSedimentLayer ), public , deferred :: & create ! constructor method procedure ( destroyBedSedimentLayer ), public , deferred :: & destroy ! finaliser method procedure ( AddSedimentToLayer ), public , deferred :: & AddSediment ! add fine sediment to the layer procedure ( RemoveSedimentFromLayer ), public , deferred :: & RemoveSediment ! remove fine sediment from layer end type abstract interface !> create a BedSedimentLayer object and its incorporated BedSediment objects: !!  - sets number of particle size classes !!  - reads in fixed layer volume !!  - reads in volumes of fine sediment and water in each size class !!  - sets volume of coarse material function createBedSedimentLayer ( Me , & n , & nsc , & FSType , & C_tot , & f_comp , & pd_comp , & Porosity , & V_f , & M_f ) result ( r ) use Globals import BedSedimentLayer , ErrorInstance , FineSediment1 , Result class ( BedSedimentLayer ) :: Me !! the BedSedimentLayer instance character ( len = 256 ) :: n !! a name for the object integer , intent ( in ) :: nsc !! the number of particle size classes integer , intent ( in ) :: FSType !! the type identification number of the FineSediment(s) real ( dp ), intent ( in ) :: C_tot !! the total volume of the layer real ( dp ), intent ( in ), optional :: V_f (:) !! set of fine sediment volumes, if being used to define layer real ( dp ), intent ( in ), optional :: M_f (:) !! set of fine sediment masses, if being used to define layer real ( dp ), intent ( in ) :: f_comp (:,:) !! set of fractional compositions. Index 1 = size class, Index 2 = compositional fraction real ( dp ), intent ( in ), allocatable :: pd_comp (:) !! set of fractional particle densities real ( dp ), intent ( in ), optional :: Porosity !! layer porosity, if being used to define layer type ( Result ) :: r !! The Result object. type ( ErrorInstance ) :: er ! LOCAL ErrorCriteria object for error handling. type ( FineSediment1 ) :: fs1 ! LOCAL object of type FineSediment1, for implementation of polymorphism real ( dp ) :: slr ! LOCAL volumetric solid:liquid ratio character ( len = 256 ) :: tr ! LOCAL name of this procedure, for trace logical :: criterr ! LOCAL .true. if one or more critical errors tripped ! ! Function purpose ! ------------------------------------------------------------------------------- ! initialise a BedSedimentLayer object and its constituent ! FineSediment objects ! ! Function inputs ! ------------------------------------------------------------------------------- ! Function takes as inputs: ! n (character)         a name unambiguously identifying the object ! nsc (integer)         the number of size classes of sediment ! FStype (integer)      the subtype of the spcFineSediment Superclass to use !                       to create fine sediment objects ! C_tot (real, dp)      The total volume of the layer [m3 m-2] ! V_f(:) (real, dp)     OPTIONAL array of initial fine sediment volumes [m3 m-2] ! M_f(:) (real, dp)     OPTIONAL array of initial fine sediment masses [kg m-2] ! F_comp(:,:) (real, dp) array of fractional compositions for each size class ! Porosity (real, dp)   OPTIONAL sediment porosity ! ! Function outputs/outcomes ! ------------------------------------------------------------------------------- ! No specific outputs: results are initialisation of variables and objects ! ! Notes ! ------------------------------------------------------------------------------- ! This function fills all available space in the layer with fine sediment, ! water and coarse material. There are two calling conventions: ! 1.    Specify V_f(:) or M_f(:) and porosity. Water volumes are computed from !       porosity. Any remaining capacity is filled by coarse material. ! 2.    Specify V_f(:) or M_f(:) only. Space not occupied by fine sediment is !       occupied by water. ! If both V_f and M_f are specified then V_f will be used. ! ------------------------------------------------------------------------------- end function !> destroy this object function destroyBedSedimentLayer ( Me ) result ( r ) import BedSedimentLayer , Result class ( BedSedimentLayer ) :: Me type ( Result ) :: r ! ! Function purpose ! ------------------------------------------------------------------------------- ! Deallocate all allocated variables in this object. ! ! Function inputs ! ------------------------------------------------------------------------------- ! no inputs ! ! Function outputs/outcomes ! ------------------------------------------------------------------------------- ! F returns the amounts of sediment and water that could not be added ! ! Notes ! ------------------------------------------------------------------------------- ! No notes. ! ------------------------------------------------------------------------------- end function !> add sediment and water to this layer function addSedimentToLayer ( Me , S , F ) result ( r ) use Globals import BedSedimentLayer , FineSediment1 , Result class ( BedSedimentLayer ) :: Me !! the BedSedimentLayer instance integer , intent ( in ) :: S !! the particle size class type ( FineSediment1 ), intent ( inout ) :: F !! FineSediment - holds material to be added type ( Result ) :: r !! The Result object ! ! Function purpose ! ------------------------------------------------------------------------------- ! Add fine sediment of a specified size fraction, and water, to this layer. ! ! Function inputs ! ------------------------------------------------------------------------------- ! Function takes as inputs: ! S (integer)             the size class to which sediment is to be added ! F (FineSedimentElement) object representing the FineSediment to be added ! ! Function outputs/outcomes ! ------------------------------------------------------------------------------- ! F returns the amounts of sediment and water that could not be added ! ! Notes ! ------------------------------------------------------------------------------- ! No notes. ! ------------------------------------------------------------------------------- end function !> remove sediment and water from this layer function RemoveSedimentFromLayer ( Me , S , G ) result ( r ) use Globals import BedSedimentLayer , FineSediment1 , Result1D class ( BedSedimentLayer ) :: Me !! the BedSedimentLayer instance integer , intent ( in ) :: S !! the particle size class type ( FineSediment1 ), intent ( in ) :: G !! fine sediment to be removed; returns fine sediment that could not be removed type ( Result1D ) :: r !! The Result object. Result%data(1) = fine sediment that was removed; Result%data(2) = fine sediment that could not be removed ! Function purpose ! ------------------------------------------------------------------------------- ! Removes fine sediment and associated water from this layer. ! ! Function inputs ! ------------------------------------------------------------------------------- ! Function takes as inputs: ! S (integer)             the size class from which sediment is to be removed ! G (FineSedimentElement) object representing the sediment to be removed, !                         returns sediment that could not be removed ! F (FineSedimentElement) object returning the sediment that was removed ! ! Function outputs/outcomes ! ------------------------------------------------------------------------------- ! F returns the sediment that was removed ! G returns the sediment could not be removed ! ! Notes ! ------------------------------------------------------------------------------- ! No notes. ! ------------------------------------------------------------------------------- end function end interface contains !> return the available capacity for fine sediment of a specified size class pure function GetAf ( Me , s ) result ( A_f ) class ( BedSedimentLayer ), intent ( in ) :: Me !! the BedSedimentLayer instance integer , intent ( in ) :: s !! size class for which to retrieve available capacity real ( dp ) :: A_f !! return value A_f = Me % C_f_l ( s ) - Me % colFineSediment ( s )% item % V_f () !! compute capacity ! CRITICAL ERROR if A_f < 0 end function !> return the available capacity for water associated with fine sediment of a specified size class pure function GetAw ( Me , s ) result ( A_w ) class ( BedSedimentLayer ), intent ( in ) :: Me !! the BedSedimentLayer instance integer , intent ( in ) :: s !! size class for which to retrieve available capacity real ( dp ) :: A_w !! return value A_w = Me % C_w_l ( s ) - Me % colFineSediment ( s )% item % V_w () !! compute capacity ! CRITICAL ERROR if A_w < 0 end function !> return the total capacity for fine sediment of a specified size class pure function GetCf ( Me , s ) result ( C_f ) class ( BedSedimentLayer ), intent ( in ) :: Me !! the BedSedimentLayer instance integer , intent ( in ) :: s !! size class for which to retrieve available capacity real ( dp ) :: C_f !! return value C_f = Me % C_f_l ( s ) !! compute capacity end function !> returns the total capacity for water associated with fine sediment of a specified size class pure function GetCw ( Me , s ) result ( C_w ) class ( BedSedimentLayer ), intent ( in ) :: Me !! the BedSedimentLayer instance integer , intent ( in ) :: s !! size class for which to retrieve available capacity real ( dp ) :: C_w !! return value C_w = Me % C_w_l ( s ) !! compute capacity end function !> return the volumetric solid:liquid ratio for the layer pure function GetvolSLR ( Me ) result ( volSLR ) class ( BedSedimentLayer ), intent ( in ) :: Me !! the BedSedimentLayer instance real ( dp ) :: volSLR !! return value volSLR = Me % C_f_l ( 1 ) / Me % C_w_l ( 1 ) ! compute ratio end function !> return the sediment mass in the layer across all size fractions pure function GetMflayer ( Me ) result ( Mf_layer ) class ( BedSedimentLayer ), intent ( in ) :: Me !! the BedSedimentLayer instance real ( dp ) :: Mf_layer !! return value integer :: x ! LOCAL loop counter do x = 1 , Me % nSizeClasses Mf_layer = Mf_layer + & Me % colFineSediment ( x )% item % M_f () ! sum across all size classes end do end function !> return the sediment capacity in the layer across all size fractions pure function GetCflayer ( Me ) result ( Cf_layer ) class ( BedSedimentLayer ), intent ( in ) :: Me !! the BedSedimentLayer instance real ( dp ) :: Cf_layer !! return value integer :: s ! loop counter do s = 1 , Me % nSizeClasses Cf_layer = Cf_layer + Me % C_f ( s ) ! sum across all size classes end do end function !> return the sediment volume in the layer across all size fractions pure function GetVflayer ( Me ) result ( Vf_layer ) class ( BedSedimentLayer ), intent ( in ) :: Me !! the BedSedimentLayer instance real ( dp ) :: Vf_layer !! return value integer :: s ! loop counter do s = 1 , Me % nSizeClasses Vf_layer = Vf_layer + & Me % colFineSediment ( s )% item % V_f () ! sum across all size classes end do end function !> return the water volume in the layer across all sediment size fractions pure function GetVwlayer ( Me ) result ( Vw_layer ) class ( BedSedimentLayer ), intent ( in ) :: Me !! the BedSedimentLayer instance real ( dp ) :: Vw_layer !! return value integer :: s ! loop counter do s = 1 , Me % nSizeClasses Vw_layer = Vw_layer + & Me % colFineSediment ( s )% item % V_w () ! sum across all size classes end do end function !> return the water capacity in the layer across all sediment size fractions pure function GetCwlayer ( Me ) result ( Cw_layer ) class ( BedSedimentLayer ), intent ( in ) :: Me !! the BedSedimentLayer instance real ( dp ) :: Cw_layer !! return value integer :: s ! loop counter do s = 1 , Me % nSizeClasses Cw_layer = Cw_layer + Me % C_w_l ( s ) ! sum across all size classes end do end function !> return the fine sediment & water volume in the layer across all size fractions pure function GetVmlayer ( Me ) result ( Vm_layer ) class ( BedSedimentLayer ), intent ( in ) :: Me !! the BedSedimentLayer instance real ( dp ) :: Vm_layer !! return value integer :: s ! loop counter do s = 1 , Me % nSizeClasses Vm_layer = Vm_layer + & Me % colFineSediment ( s )% item % V_f () + & Me % colFineSediment ( s )% item % V_w () ! sum across all size classes end do end function !> return the total volume of the layer pure function GetVlayer ( Me ) result ( V_layer ) class ( BedSedimentLayer ), intent ( in ) :: Me !! the BedSedimentLayer instance real ( dp ) :: V_layer !! return value integer :: s ! loop counter V_layer = Me % V_c ! start by adding coarse material volume do s = 1 , Me % nSizeClasses V_layer = V_layer + & Me % colFineSediment ( s )% item % V_f () + & Me % colFineSediment ( s )% item % V_w () ! sum across all size classes end do end function end module","tags":"","loc":"sourcefile/spcbedsedimentlayer.f08.html"},{"title":"classFineSediment1.f08 – NanoFASE","text":"Modules classFineSediment1 Source Code classFineSediment1.f08 Source Code !> definition for class FineSediment1. Nonpolymorphic. module classFineSediment1 use Globals use ResultModule implicit none ! force declaration of all variables type , public :: FineSediment1 ! type declaration for class character ( len = 256 ) :: name !! a name for the object real ( dp ), private :: M_f_l !! LOCAL fine sediment mass [kg m-2] real ( dp ), private :: V_w_l !! LOCAL volume of water associated with fine sediment [m3 m-2] real ( dp ), allocatable :: f_comp (:) !! fractional composition [-] real ( dp ), allocatable :: pd_comp_l (:) !! LOCAL storage of fractional particle densities [kg m-3] integer :: nfComp !! LOCAL number of fractional composition terms integer :: allst !! array allocation status contains procedure , public :: create => createFineSediment1 ! sets up by reading variables required for computations procedure , public :: set => setFS1 ! set properties, using either fine sediment volume or mass !        procedure, public :: setByV => setFSVol1                     ! set properties, using a fine sediment volume !        procedure, public :: setByM => setFSMass1                    ! set properties, using a fine sediment mass procedure , public :: V_f => getFSVol1 ! returns the fine sediment volume [m3 m-2] procedure , public :: M_f => getFSMass1 ! returns the fine sediment mass [kg m-2] procedure , public :: V_w => getWVol1 ! returns the water volume [kg m-2] procedure , public :: rho_part => pdens1 ! returns the fine sediment particle density [kg m-3] procedure , public :: audit_comp => audit_fcomp1 ! check the fractional composition procedure , public :: IsEmpty => empty1 ! check for presence of sediment and water procedure , public :: ClearAll => ClearAll1 ! clear all fine sediment and water from the object procedure , public :: mix => Mix1 ! mix this sediment into another end type contains !> initialise this object function createFineSediment1 ( Me , n , pd_comp_in ) & result ( r ) implicit none class ( FineSediment1 ) :: Me !! self-reference character ( len = 256 ) :: n !! a name identifier for the object; identifies this object uniquely real ( dp ), intent ( in ), allocatable :: pd_comp_in (:) !! input array of particle densities for compositional fractions real ( dp ), allocatable :: pd_comp (:) type ( Result ) :: r !! Result object type ( ErrorInstance ) :: er ! To store errors in character ( len = 256 ) :: tr ! LOCAL name of this procedure, for trace ! ! Function purpose ! ------------------------------------------------------------------------------- ! initialise a FineSediment object. Set the object name, number of compositional ! fractions, and particle density for each compositional fraction. ! ! Function inputs ! ------------------------------------------------------------------------------- ! n (character)            a name unambiguously identifying the object ! nsc (integer)            the number of size classes of sediment ! pd_comp_in(:) (real, dp) 1D array of particle density [kg m-3] for !                          compositional fractions ! ! Function outputs/outcomes ! ------------------------------------------------------------------------------- ! initialised FineSediment1 object. Returns Result object containing ! ErrorInstance if no object name has been provided. ! ! Notes ! ------------------------------------------------------------------------------- ! No notes. ! ------------------------------------------------------------------------------- if ( len_trim ( n ) == 0 ) then call r % addError ( ErrorInstance ( & code = 1 , & message = \"An object name has not been & provided\" , & trace = [ \"classFineSediment1%create\" ])) ! error if name is not provided return ! critical error, so exit here end if Me % name = n ! set object name Me % NFComp = size ( pd_comp_in ) ! set number of compositional fractions allocate ( pd_comp ( Me % nfComp ), stat = Me % allst ) ! allocate space for particle densities of compositional fractions if ( Me % allst /= 0 ) then er = ErrorInstance ( 1 , & \"Allocation error\" , & trace = [ Me % name // & \"%createBedSedimentLayer1%colFineSediment\" ] & ) ! create error call r % addError ( er ) ! add to Result return ! critical error, so exit end if pd_comp = pd_comp_in ! read in particle densities of compositional fractions end function !> set the properties of the object function setFS1 ( Me , Mf_in , Vf_in , Vw_in , f_comp_in ) & result ( r ) ! QUERY: can this function be pure? class ( FineSediment1 ) :: Me ! self-reference real ( dp ), intent ( in ), optional :: Mf_in ! the fine sediment mass real ( dp ), intent ( in ), optional :: Vf_in ! the fine sediment volume real ( dp ), intent ( in ), optional :: Vw_in ! the water volume. Optional; if not present, stored composition is used real ( dp ), intent ( in ), optional :: f_comp_in (:) ! input fractional composition. Optional; if not present, stored composition is used type ( Result ) :: r ! Result object type ( ErrorInstance ) :: er ! LOCAL ErrorInstance object ! ! Function purpose ! ------------------------------------------------------------------------------- ! set one or more of the fundamental properties of a FineSediment1 object ! these properties are: !   1. the sediment mass [kg] - which can be set either directly !      or by setting the sediment volume !   2. the volume of water associated with the sediment within a sediment layer !   3. the sediment fractional composition [-] ! ! Function inputs ! ------------------------------------------------------------------------------- ! ! Mf_in [optional]         the fine sediment mass [kg m-2] ! Vf_in [optional]         the fine sediment volume [m3 m-2] ! Vw_in [optional]         the associated water volume [m3 m-2] ! f_comp_in [optional]     the fractional composition [-] ! ! Function outputs/outcomes ! ------------------------------------------------------------------------------- ! if no critical error(s), function sets the requested properties of this ! FineSediment1 object. ! a critical error is thrown if: !   1. both Mf_in and Vf_in are specified; !   2. either Mf_in, Vf_in or Vw_in are equal to or less than zero; !   3. f_comp_in is specified, but its array dimension does not match the number !      of fractional compositions; !   4. f_comp_in is specified, but its contained values do not sum to unity. ! ! Notes ! ------------------------------------------------------------------------------- ! No notes. ! ------------------------------------------------------------------------------- if (( present ( Mf_in )) . and . ( present ( Vf_in ))) then ! both sediment mass and volume specified - cannot use both er = ErrorInstance ( & code = 1 , & message = \"Sediment mass and volume both & specified\" , & trace = [ Me % name ] & ) ! compose error call r % addError ( er ) ! add it to the result return ! and exit end if if ( present ( Mf_in )) then if ( Mf_in <= 0 ) then ! Mf_in is invalid er = ErrorInstance ( & code = 103 , & message = \"Sediment mass is out of range\" , & trace = [ Me % name ] & ) ! compose error call r % addError ( er ) ! add it to the result return ! and exit end if end if if ( present ( Vf_in )) then if ( Vf_in <= 0 ) then ! Vf_in is invalid er = ErrorInstance ( & code = 103 , & message = \"Sediment volume is out of range\" , & trace = [ Me % name ] & ) ! compose error call r % addError ( er ) ! add it to the result return ! and exit end if end if if ( present ( Vw_in )) then if ( Vw_in <= 0 ) then ! Vw_in is invalid er = ErrorInstance ( & code = 103 , & message = \"Water volume is out of range\" , & trace = [ Me % name ] & ) ! compose error call r % addError ( er ) ! add it to the result return ! and exit end if end if if ( present ( f_comp_in )) then if ( size ( f_comp_in ) /= Me % NFComp ) then er = ErrorInstance ( & code = 106 , & message = \"Size of fractional composition & array incorrect\" , & trace = [ Me % name // \"%SetFS1\" ] & ! check size of compositional array against stored no. of fraction ) call r % addError ( er ) ! add it to the result return ! and exit, as this is a critical error else ! if no error thrown, then Me % f_comp = f_comp_in ! store the composition locally er = Me % audit_comp () ! audit sum (fractional composition) = 1, return error instance if ( er % isError ()) then ! if an error was thrown call er % addToTrace ( Me % name // \"%SetFS1\" ) ! add a trace call r % addError ( er ) ! add it to the result return ! and exit, as this is a critical error end if end if end if if ( present ( Mf_in )) Me % M_f_l = Mf_in ! Storing fine sediment mass, if specified if ( present ( Vf_in )) Me % M_f_l = Vf_in * Me % rho_part () ! Storing fine sediment volume, if specified if ( present ( Vw_in )) Me % V_w_l = Vw_in ! Volume of water, if specified end function !> return the fine sediment volume [m3 m-2] pure function getFSVol1 ( Me ) result ( Vf ) class ( FineSediment1 ), intent ( in ) :: Me !! self-reference real ( dp ) :: Vf !! the return value ! function to return the fine sediment volume [m3 m-2] ! Output: Vf = Fine sediment volume Vf = Me % M_f_l / Me % rho_part () ! fine sediment volume computation end function !> return the fine sediment mass [kg m-2] pure function getFSMass1 ( Me ) result ( Mf ) class ( FineSediment1 ), intent ( in ) :: Me !! self-reference real ( dp ) :: Mf !! the return value ! function to return the fine sediment mass [kg m-2] ! Output: Mf = Fine sediment mass Mf = Me % M_f_l ! fine sediment mass computation end function !> return the water volume [m3 m-2] pure function getWVol1 ( Me ) result ( Vw ) class ( FineSediment1 ), intent ( in ) :: Me !! self-reference real ( dp ) :: Vw !! the return value ! function to return the water volume [m3 m-2] ! Output: Vw = water volume Vw = Me % V_w_l ! water volume computation end function !> compute particle density from components and their densities pure function pdens1 ( Me ) result ( rho_part ) class ( FineSediment1 ), intent ( in ) :: Me !! self-reference real ( dp ) :: rho_part !! return value: the particle density [kg m-3] integer :: x ! LOCAL loop counter rho_part = 0 ! initialise output variable do x = 1 , Me % NFComp rho_part = rho_part + Me % f_comp ( x ) * Me % pd_comp_l ( x ) ! summing contributions to particle density end do end function !> check that the array of fractional compositions sums to unity pure function audit_fcomp1 ( Me ) result ( er ) class ( FineSediment1 ), intent ( in ) :: Me !! self-reference type ( ErrorInstance ) :: er !! ErrorInstance object, returns error if t_fcomp /= 1 integer :: F ! LOCAL loop counter real ( dp ) :: t_fcomp ! LOCAL sum of fractional compositions do F = 1 , Me % NFComp t_fcomp = t_fcomp + Me % f_comp ( F ) ! summing fractional compositions end do if ( t_fcomp /= 1 ) then er = ErrorInstance ( & code = 106 , & message = \"Fractional composition does & not sum to unity.\" , & trace = [ trim ( Me % name )] & ) ! check t_fcomp = 1 end if end function !> check whether this object contains any fine sediment or water of the specified size class pure function Empty1 ( Me ) result ( t ) class ( FineSediment1 ), intent ( in ) :: Me !! self-reference logical :: t !! return value. True= V_f/M_f = V_w = 0. False= V_f/M_f > 0 .or. V_w > 0 t = . false . if ( Me % M_f_l == 0 . and . Me % V_w_l == 0 ) t = . true . end function !> clear all properties subroutine ClearAll1 ( Me ) class ( FineSediment1 ) :: Me !! the FineSediment instance integer :: X ! LOCAL loop counter Me % M_f_l = 0 ! clear fine sediment mass Me % V_w_l = 0 ! clear water volume do X = 1 , Me % nfComp ! clear fractional composition Me % f_comp ( X ) = 0 end do end subroutine !> mix two FineSediment objects together function Mix1 ( Me , FS ) result ( r ) class ( FineSediment1 ) :: Me !! self-reference type ( FineSediment1 ), intent ( in ) :: FS !! FineSediment1 to be mixed with this one type ( Result0D ) :: r !! Result object type ( ErrorInstance ) :: er ! LOCAL error instance object integer :: x ! LOCAL loop counter real ( dp ) :: M_f_mix ! LOCAL mixed sediment mass real ( dp ) :: V_w_mix ! LOCAL mixed water volume real ( dp ), allocatable :: f_comp_mix (:) ! LOCAL mixed fractional composition ! ! Function purpose ! ------------------------------------------------------------------------------- ! mix this FineSediment with another and return the result ! ! ------------------------------------------------------------------------------- ! Function takes as inputs: ! FS    FineSediment object with which this one is to be mixed. ! ! ! Function outputs/outcomes ! ------------------------------------------------------------------------------- ! Function returns Result0D object containing the mixed FineSediment ! ! Function throws critical error if: ! 1.    fine sediment mass in FS <= 0. ! 2.    water volume in FS < 0. ! 3.    the number of fractional compositions in FS differs from that in Me. ! 4.    the sum of fractional components in FS /= 1. ! 5.    any particle density in FS <= 0. ! 6.    allocation of f_comp_mix fails. ! Notes ! ------------------------------------------------------------------------------- ! No notes. ! ------------------------------------------------------------------------------- if ( FS % M_f () <= 0 ) then ! mixing sediment mass is invalid er = ErrorInstance ( & code = 103 , & message = \"Mixing sediment mass is invalid\" , & trace = [ Me % name // \"%Mix1\" ] & ) ! compose error call r % addError ( er ) ! add it to the result end if ! note that V_f does not need to be checked if ( FS % V_w () < 0 ) then ! mixing water volume is invalid - note procedure does accept that volume can be zero er = ErrorInstance ( & code = 103 , & message = \"Mixing water volume is invalid\" , & trace = [ Me % name // \"%Mix1\" ] & ) ! compose error call r % addError ( er ) ! add it to the result end if if ( Me % nfComp /= FS % nfComp ) then ! inconsistency in number of compositional fractions er = ErrorInstance ( & code = 106 , & message = \"Inconsistent numbers of compositional & fractions\" , & trace = [ Me % name // \"%Mix1\" ] & ) ! compose error call r % addError ( er ) ! add it to the result end if er = FS % audit_comp () ! audit sum (fractional composition) = 1, return error instance if ( er % isError ()) then ! if an error was thrown call er % addToTrace ( Me % name // \"%Mix1\" ) ! add a trace call r % addError ( er ) ! add it to the result end if if ( r % hasCriticalError ()) return ! exit if a critical error has been thrown do x = 1 , FS % nfComp if ( FS % pd_comp_l ( x ) <= 0 ) then ! check all particle densities are valid er = ErrorInstance ( & code = 103 , & message = \"A mixing particle density is & invalid\" , & trace = [ Me % name // \"%Mix1\" ] & ) ! compose error call r % addError ( er ) ! add it to the result return ! and exit end if end do allocate ( f_comp_mix ( Me % nfComp ), stat = Me % allst ) ! allocate f_comp_mix if ( Me % allst /= 0 ) then er = ErrorInstance ( 1 , & message = \"Allocation error\" , & trace = [ Me % name // \"%Mix1\" ] & ) ! create error call r % addError ( er ) ! add to Result return ! critical error, so exit end if do x = 1 , Me % nfComp f_comp_mix ( x ) = ( Me % M_f () * Me % f_comp ( x ) + & FS % M_f () * FS % f_comp ( x )) / & ( Me % M_f () + FS % M_f ()) ! mass-weighted fractional composition of mixed sediment end do M_f_mix = Me % M_f () + FS % M_f () ! mixed sediment mass V_w_mix = Me % V_w () + FS % V_w () ! mixed water volume call r % addErrors (. errors . FS % set ( Mf_in = M_f_mix , & Vw_in = V_w_mix , & f_comp_in = f_comp_mix & ) & ) ! set the properties of the returned FineSediment object if ( r % hasCriticalError ()) return ! exit if critical error thrown r = Result ( data = FS ) ! feed FineSediment object into Result end function end module","tags":"","loc":"sourcefile/classfinesediment1.f08.html"},{"title":"spcFineSediment.f08 – NanoFASE","text":"Modules spcFineSediment Source Code spcFineSediment.f08 Source Code !> abstract superclass definition for FineSediment !! defines the properties and methods shared by all BedSedimentLayer objects !! objects of this class cannot be instantiated, only objects of its subclasses module spcFineSediment use Globals use netcdf ! input/output handling use mo_netcdf ! input/output handling use ResultModule ! error handling classes, required for use ErrorInstanceModule ! generation of trace error messages implicit none ! force declaration of all variables type , abstract , public :: FineSediment !! type declaration for superclass character ( len = 256 ) :: name !! a name for the object real ( dp ) :: M_f_l !! fine sediment mass [kg m-2] real ( dp ) :: V_w_l !! LOCAL volume of water associated with fine sediment [m3 m-2] real ( dp ), allocatable :: f_comp (:) !! fractional composition [-] real ( dp ), allocatable :: pd_comp_l (:) !! LOCAL storage of fractional particle densities [kg m-3] integer :: NFComp !! LOCAL number of fractional composition terms contains ! deferred methods: must be defined in all subclasses procedure ( createFineSediment ), deferred :: create ! sets up by reading variables required for computations procedure ( setFSVol ), deferred :: SetV ! set properties by assigning a fine sediment volume procedure ( setFSMass ), deferred :: SetM ! set properties by assigning a fine sediment mass procedure ( getFSVol ), deferred :: V_f ! returns the fine sediment volume [m3 m-2] procedure ( getFSMass ), deferred :: M_f ! returns the fine sediment mass [kg m-2] procedure ( getWVol ), deferred :: V_w ! returns the water volume [kg m-2] procedure ( pdens ), deferred :: rho_part ! returns the fine sediment particle density [kg m-3] procedure ( audit_fcomp ), deferred :: audit_comp ! audits the fractional composition procedure ( Empty ), deferred :: IsEmpty ! check for presence of sediment and water procedure ( ClearAll ), deferred :: Clear ! clear all fine sediment and water from the object ! non-deferred methods: defined here. Can be overwritten in subclasses end type abstract interface !> initialise this object function createFineSediment ( Me , n , pd_comp_in ) & result ( r ) use Globals import FineSediment , Result class ( FineSediment ) :: Me !! self-reference character ( len = 256 ) :: n !! a name for the object real ( dp ), intent ( in ), allocatable :: pd_comp_in (:) !! input array of particle densities for compositional fractions type ( Result ) :: r !! Result object end function !> set the properties, using fine sediment volume [m3 m-2] function setFSVol ( Me , Vf_in , Vw_in , f_comp_in ) result ( r ) use Globals import FineSediment , Result class ( FineSediment ) :: Me !! self-reference type ( Result ) :: r !! Result object real ( dp ), optional :: Vf_in !! the fine sediment volume real ( dp ), optional :: Vw_in !! the water volume real ( dp ), optional , allocatable :: f_comp_in (:) !! input fractional composition. Optional; if not present, stored composition is used end function !> set the properties, using fine sediment mass [kg m-2] function setFSMass ( Me , Mf_in , Vw_in , f_comp_in ) result ( r ) use Globals import FineSediment , Result class ( FineSediment ) :: Me !! self-reference type ( Result ) :: r !! Result object real ( dp ), optional :: Mf_in !! the fine sediment mass real ( dp ), optional :: Vw_in !! the water volume real ( dp ), optional , allocatable :: f_comp_in (:) !! input fractional composition. Optional; if not present, stored composition is used end function !> return the fine sediment volume [m3 m-2] function getFSVol ( Me ) result ( Vf ) use Globals import FineSediment class ( FineSediment ) :: Me !! self-reference real ( dp ) :: Vf !! the return value end function !> return the fine sediment mass [kg m-2] function getFSMass ( Me ) result ( Mf ) use Globals import FineSediment class ( FineSediment ) :: Me !! self-reference real ( dp ) :: Mf !! the return value end function !> return the water volume [m3 m-2] function getWVol ( Me ) result ( Vw ) use Globals import FineSediment class ( FineSediment ) :: Me !! self-reference real ( dp ) :: Vw !! the return value end function !> return the particle density [kg m-3] function pdens ( Me ) result ( rp ) use Globals import FineSediment class ( FineSediment ) :: Me !! self-reference real ( dp ) :: rp !! return value: the particle density [kg m-3] end function !> audit the fractional composition function Audit_fcomp ( Me ) use Globals import FineSediment class ( FineSediment ) :: Me !! self-reference integer :: F ! LOCAL loop counter real ( dp ) :: t_fcomp ! LOCAL sum of fractional compositions end function !> check whether this object contains any fine sediment or water of the specified size class function Empty ( Me ) result ( t ) import FineSediment class ( FineSediment ) :: Me !! self-reference logical :: t ! return value. True= V_f/M_f = V_w = 0. False= V_f/M_f > 0 .or. V_w > 0 end function !> clear all fine sediment and water from the object subroutine ClearAll ( Me ) import FineSediment class ( FineSediment ) :: Me !! self-reference integer :: X ! LOCAL loop counter end subroutine end interface end module","tags":"","loc":"sourcefile/spcfinesediment.f08.html"},{"title":"classRiverReach1.f08 – NanoFASE","text":"Modules classRiverReach1 Source Code classRiverReach1.f08 Source Code !> Module responsible for the RiverReach1 object module classRiverReach1 use mo_netcdf use Globals use UtilModule use ResultModule use ErrorInstanceModule use spcRiverReach implicit none private !> RiverReach1 object is responsible for sediment transport along river and !! sediment deposition to bed sediment. type , public , extends ( RiverReach ) :: RiverReach1 contains procedure , public :: create => createRiverReach1 procedure , public :: destroy => destroyRiverReach1 procedure , public :: update => update1 procedure :: calculateWidth => calculateWidth1 procedure :: calculateDepth => calculateDepth1 procedure :: calculateVelocity => calculateVelocity1 procedure :: calculateSettlingVelocity => calculateSettlingVelocity1 procedure :: calculateArea => calculateArea1 procedure :: calculateVolume => calculateVolume1 end type contains !> Create a RiverReach with x, y, s, r coordinates from the datafile. function createRiverReach1 ( me , x , y , s , r , l , QrunoffTimeSeries ) result ( res ) class ( RiverReach1 ) :: me !! The RiverReach1 instance. integer :: x !! Containing GridCell x-position index. integer :: y !! Containing GridCell y-position index. integer :: s !! Containing SubRiver index. integer :: r !! RiverReach index. real ( dp ) :: l !! Length of the RiverReach (without meandering). real ( dp ), allocatable :: QrunoffTimeSeries (:) !! Any GridCell runoff (that has already been split to the correct RiverReach size) type ( Result0D ) :: D !! Depth [m]. type ( Result0D ) :: v !! River velocity [m/s]. type ( Result0D ) :: W !! River width [m]. integer :: i ! Loop iterator. type ( Result ) :: res !! The Result object. type ( NcDataset ) :: NC ! NetCDF dataset type ( NcVariable ) :: var ! NetCDF variable type ( NcGroup ) :: grp ! NetCDF group type ( ErrorInstance ) :: error ! To return errors real ( dp ), allocatable :: spmDensities (:) ! Array of sediment particle densities for each size class ! First, let's set the RiverReach's reference and the length me % ref = trim ( ref ( \"RiverReach\" , x , y , s , r )) me % l = l ! Allocate the arrays of size classes and set SPM to 0 to begin with allocate ( me % rho_spm ( C % nSizeClassesSpm ), & me % spmIn ( C % nSizeClassesSpm ), & me % spmOut ( C % nSizeClassesSpm ), & me % m_spm ( C % nSizeClassesSpm ), & stat = me % allst ) me % rho_spm = 0 ! Set SPM density and mass to 0 to begin with me % m_spm = 0 allocate ( me % QrunoffTimeSeries , source = QrunoffTimeSeries ) ! This reach's runoff ! Get the specific RiverReach parameters from data - only the stuff ! that doesn't depend on time ! TODO: Check these groups exist (hasGroup()). Move data extraction to database object. nc = NcDataset ( C % inputFile , \"r\" ) ! Open dataset as read-only grp = nc % getGroup ( \"Environment\" ) grp = grp % getGroup ( trim ( ref ( \"GridCell\" , x , y ))) ! Get the GridCell we're in grp = grp % getGroup ( trim ( ref ( \"SubRiver\" , x , y , s ))) ! Get the SubRiver we're in me % ncGroup = grp % getGroup ( trim ( me % ref )) ! Finally, get the actual RiverReach group var = me % ncGroup % getVariable ( \"slope\" ) ! Get the slope call var % getData ( me % S ) if ( me % ncGroup % hasVariable ( \"f_m\" )) then ! If there is a meandering factor, get that var = me % ncGroup % getVariable ( \"f_m\" ) ! If not, it defaults to 1 (no meandering). call var % getData ( me % f_m ) end if ! Get the time series of SPM inflows allocate ( me % m_spmTimeSeries ( C % nTimeSteps , C % nSizeClassesSpm )) if ( me % ncGroup % hasVariable ( \"spm\" )) then var = me % ncGroup % getVariable ( \"spm\" ) call var % getData ( me % m_spmTimeSeries ) me % m_spmTimeSeries = me % m_spmTimeSeries * C % timeStep ! SPM should be in kg/s, thus need to convert to kg/timestep else me % m_spmTimeSeries = 0 end if ! Initial density can't be updated in we have volume from Qin, so this is left to the update() procedure ! TODO: Where should Manning's n come from? From Constants for the moment: me % n = C % n_river end function !> Destroy this RiverReach1 function destroyRiverReach1 ( me ) result ( r ) class ( RiverReach1 ) :: me !! This RiverReach1 instance type ( Result ) :: r !! The Result object ! TODO: Write some destroy logic end function !> Update the RiverReach on this timestep t, based on the inflow Q and SPM provided function update1 ( me , Qin , spmIn , t ) result ( r ) class ( RiverReach1 ) :: me !! This RiverReach1 instance real ( dp ) :: Qin !! Inflow to this reach real ( dp ) :: spmIn ( C % nSizeClassesSpm ) !! Inflow SPM to this reach integer :: t !! What time step are we on? type ( Result ) :: r !! Result object to return type ( Result0D ) :: D ! Result objects for depth integer :: n ! Size class loop it  erator integer :: nDisp ! Number of displacements to split reach into integer :: i ! Iterator for displacements real ( dp ) :: dQin ! Qin for each displacement real ( dp ) :: dSpmIn ( C % nSizeClassesSpm ) ! spmIn for each displacement real ( dp ) :: settlingVelocity ( C % nSizeClassesSpm ) ! Settling velocity for each size class real ( dp ) :: k_settle ( C % nSizeClassesSpm ) ! Settling constant for each size class real ( dp ) :: dSpmOut ( C % nSizeClassesSpm ) ! SPM outflow for the displacement me % Qrunoff = me % QrunoffTimeSeries ( t ) ! Get the runoff for this time step. me % Qin = Qin + me % Qrunoff ! Set this reach's inflow me % spmIn = spmIn + me % m_spmTimeSeries ( t ,:) ! Inflow SPM from upstream reach + inflow from data file ! TODO: m_spm shouldn't really be used as a symbol for what is a mass flux, ! change the name to something else, e.g. spmInTimeSeries. ! Calculate the depth, velocity, area and volume me % W = me % calculateWidth ( me % Qin / C % timeStep ) D = me % calculateDepth ( me % W , me % S , me % Qin / C % timeStep ) me % D = . dp . D ! Get real(dp) data from Result object call r % addError (. error . D ) ! Add any error that occurred me % v = me % calculateVelocity ( me % D , me % Qin / C % timeStep , me % W ) me % area = me % calculateArea ( me % D , me % W ) me % volume = me % calculateVolume ( me % D , me % W , me % l , me % f_m ) ! If Qin for this timestep is bigger than the reach volume, then we need to ! split into a number of displacements nDisp = ceiling ( me % Qin / me % volume ) dQin = me % Qin / nDisp ! Inflow to the first displacement dSpmIn = me % spmIn / nDisp ! SPM inflow to the first displacment me % Qout = 0 ! Reset Qout for this timestep me % spmOut = 0 ! Reset spmOut for this timestep do i = 1 , nDisp ! Update SPM according to inflow for this displacement, then calculate ! new SPM density based on this and the dimensions me % m_spm = me % m_spm + dSpmIn ! Add inflow SPM to SPM already in reach me % rho_spm = me % m_spm / me % volume ! Calculate the settling velocity and rate for each SPM size class do n = 1 , C % nSizeClassesSpm settlingVelocity ( n ) = me % calculateSettlingVelocity ( C % d_spm ( n ), me % rho_spm ( n ), C % T ) k_settle ( n ) = settlingVelocity ( n ) / me % D end do ! Remove settled SPM from the displacement. TODO: This will go to BedSediment eventually me % m_spm = me % m_spm - ( k_settle * C % timeStep / nDisp ) * me % m_spm me % rho_spm = me % m_spm / me % volume ! Recalculate the density ! If we've removed all of the SPM, set to 0 do n = 1 , C % nSizeClassesSpm if ( me % m_spm ( n ) < 0 ) then ! If we've removed all of the SPM, set to 0 me % m_spm ( n ) = 0 me % rho_spm ( n ) = 0 end if end do ! Other stuff, like resuspension and abstraction, to go here. ! Advect the SPM out of the reach at the outflow rate, until it has all gone ! TODO: Set dQout different to dQin based on abstraction etc. dSpmOut = dQin * me % rho_spm do n = 1 , C % nSizeClassesSpm if ( dSpmOut ( n ) . le . me % m_spm ( n )) then ! Update the SPM mass and density after it has been advected me % m_spm ( n ) = me % m_spm ( n ) - dSpmOut ( n ) me % rho_spm ( n ) = me % m_spm ( n ) / me % volume else ! If dSpmOut > current SPM mass, then actual spmOut must equal the SPM mass, ! i.e., all of the remaining SPM has been advected out of the reach dSpmOut ( n ) = me % m_spm ( n ) me % m_spm ( n ) = 0 ! SPM mass and density must now be zero me % rho_spm ( n ) = 0 end if end do ! Sum the displacement outflows and mass for the final outflow ! Currently, Qout = Qin. Maybe abstraction etc will change this me % Qout = me % Qout + dQin me % spmOut = me % spmOut + dSpmOut end do ! If there's no SPM left, add the \"all SPM advected\" warning do n = 1 , C % nSizeClassesSpm if ( me % m_spm ( n ) == 0 . and . me % spmIn ( n ) /= 0 ) then call r % addError ( ErrorInstance ( & code = 500 , & message = \"All SPM in size class \" // trim ( str ( n )) // \" (\" // trim ( str ( C % d_spm ( n ) * 1 e6 )) // & \" um) advected from RiverReach.\" , & isCritical = . false .) & ) end if end do ! Set the final SPM density me % rho_spm = me % m_spm / me % volume ! Add what we're doing here to the error trace call r % addToTrace ( \"Updating \" // trim ( me % ref ) // \" on timestep #\" // trim ( str ( t ))) end function !> Calculate the width  W  of the river based on the discharge: !!  !!      W = 1.22Q&#94;{0.557} !!  !! References: !! - [Dumont et al., 2012](https://doi.org/10.1080/02626667.2012.715747) !! - [Allen et al., 1994](https://doi.org/10.1111/j.1752-1688.1994.tb03321.x) pure function calculateWidth1 ( me , Q ) result ( W ) class ( RiverReach1 ), intent ( in ) :: me !! The RiverReach1 instance real ( dp ), intent ( in ) :: Q !! Grid cell discharge  Q  [m**3/s] real ( dp ) :: W !! The calculated width  W  [m] W = 1.22 * Q ** 0.557 ! Calculate the width end function !> Calculate water depth from Manning's roughness coefficient, !! using Newton's method: !!  !!      D_i = D_{i-1} - \\frac{f(D_{i-1})}{f'(D_{i-1})} !!  !! where !!  !!      f(D) = WD \\left( \\frac{WD}{W+2D} \\right)&#94;{2/3} \\frac{\\sqrt{S}}{n} - Q = 0 !!  !! and !!  !!      f'(D) = \\frac{\\sqrt{S}}{n} \\frac{(DW)&#94;{5/3}(6D + 5W)}{3D(2D + W)&#94;{5/3}} !!  pure function calculateDepth1 ( me , W , S , Q ) result ( r ) class ( RiverReach1 ), intent ( in ) :: me !! The RiverReach1 instance. real ( dp ), intent ( in ) :: W !! River width  W  [m]. real ( dp ), intent ( in ) :: S !! River slope  S  [-]. real ( dp ), intent ( in ) :: Q !! Flow rate  Q  [m3/s]. real ( dp ) :: D_i ! The iterative river depth  D_i  [m]. real ( dp ) :: f ! The function to find roots for  f(D) . real ( dp ) :: df ! The derivative of  f(D)  with respect to  D . real ( dp ) :: alpha ! Constant extracted from f and df integer :: i ! Loop iterator to make sure loop isn't endless. integer :: iMax ! Maximum number of iterations before error. real ( dp ) :: epsilon ! Proximity to zero allowed. type ( ErrorInstance ) :: error ! Variable to store error in. character ( len = 100 ) :: iChar ! Loop iterator as character (for error message). character ( len = 100 ) :: fChar ! f(D) value as character (for error message). character ( len = 100 ) :: epsilonChar ! Proximity of f(D) to zero as character (for error message). type ( Result0D ) :: r !! The Result object. ! TODO: Allow user (e.g., data file) to specify max iterations and precision? D_i = 1.0_dp ! Take a guess at D being 1m to begin i = 1 ! Iterator for Newton solver iMax = 10000 ! Allow 10000 iterations epsilon = 1.0e-9_dp ! Proximity to zero allowed alpha = W ** ( 5.0_dp / 3.0_dp ) * sqrt ( S ) / me % n ! Extract constant to simplify f and df. f = alpha * D_i * (( D_i / ( W + 2 * D_i )) ** ( 2.0_dp / 3.0_dp )) - Q ! First value for f, based guessed D_i ! Loop through and solve until f(D) is within e-9 of zero, or max iterations reached do while ( abs ( f ) > epsilon . and . i <= iMax ) f = alpha * D_i * (( D_i / ( W + 2 * D_i )) ** ( 2.0_dp / 3.0_dp )) - Q ! f(D) based on D_{m-1} df = alpha * (( D_i ) ** ( 5.0_dp / 3.0_dp ) * ( 6 * D_i + 5 * W )) / ( 3 * D_i * ( 2 * D_i + W ) ** ( 5.0_dp / 3.0_dp )) D_i = D_i - f / df ! Calculate D_i based on D_{m-1} i = i + 1 end do if ( isnan ( D_i )) then ! If method diverges (results in NaN) write ( iChar , * ) i error = ErrorInstance ( & code = 300 , & message = \"Newton's method diverged to NaN after \" // trim ( adjustl ( iChar )) // \" iterations.\" & ) else if ( i > iMax ) then ! If max number of iterations reached write ( iChar , * ) iMax write ( fChar , * ) f write ( epsilonChar , * ) epsilon error = ErrorInstance ( & code = 300 , & message = \"Newton's method failed to converge - maximum number of iterations (\" & // trim ( adjustl ( iChar )) // \") exceeded. \" & // \"Precision (proximity to zero) required: \" // trim ( adjustl ( epsilonChar )) & // \". Final value: \" // trim ( adjustl ( fChar )) // \".\" & ) else error = ERROR_HANDLER % getNoError () ! Otherwise, no error occurred end if r = Result ( & ! Return the resulting data and error (or no error) data = D_i , & error = error & ) call r % addToTrace ( \"Calculating river depth\" ) end function !> Calculate the velocity of the river: !!  !!      v = \\frac{Q}{WD} !!  pure function calculateVelocity1 ( me , D , Q , W ) result ( v ) class ( RiverReach1 ), intent ( in ) :: me !! The RiverReach1 instance real ( dp ), intent ( in ) :: D !! River depth  D  [m] real ( dp ), intent ( in ) :: Q !! Flow rate  Q  [m**3/s] real ( dp ), intent ( in ) :: W !! River width  W  [m] real ( dp ) :: v !! The calculated velocity  v  [m/s] v = Q / ( W * D ) end function !> Calculate the settling velocity of sediment particles for an individual !! size class: !!  !!      W_{text{spm}} = \\frac{\\nu}{d} d_{*}&#94;3 (38.1 + 0.93 d_{*}&#94;{12/7})&#94;{-7/8} !!  !! where !!  !!      d_{*} = \\left( \\frac{\\Delta g}{\\nu&#94;2} \\right)&#94;{1/3} d !!  !! and !!  !!      \\Delta = \\frac{\\rho_{\\text{spm}}}{\\rho} - 1 !!  !! Reference: [Zhiyao et al, 2008](https://doi.org/10.1016/S1674-2370(15)30017-X). function calculateSettlingVelocity1 ( me , d , rho_spm , T ) result ( W_spm ) class ( RiverReach1 ), intent ( in ) :: me !! The RiverReach1 instance. real ( dp ), intent ( in ) :: d !! Sediment particle diameter [m]. real ( dp ), intent ( in ) :: rho_spm !! Sediment particle density [kg/m**3]. real ( dp ), intent ( in ) :: T !! Temperature [C]. real ( dp ) :: dStar ! Dimensionless particle diameter. real ( dp ) :: W_spm !! Calculated settling velocity [m/s]. ! Settling only occurs if density of SPM is greater than density of water if ( rho_spm > C % rho_w ( T )) then dStar = (( rho_spm / C % rho_w ( T ) - 1 ) * C % g / C % nu_w ( T ) ** 2 ) ** ( 1.0_dp / 3.0_dp ) * d ! Calculate the dimensional particle diameter W_spm = ( C % nu_w ( T ) / d ) * dStar ** 3 * ( 3 8.1_dp + 0.93_dp & ! Calculate the settling velocity * dStar ** ( 1 2.0_dp / 7.0_dp )) ** ( - 7.0_dp / 8.0_dp ) else W_spm = 0.0_dp end if end function !> Calculate the volume of a RiverReach, assuming a rectangular profile: !!  !!      \\text{volume} = DWlf_m !!  pure function calculateVolume1 ( me , D , W , l , f_m ) result ( volume ) class ( RiverReach1 ), intent ( in ) :: me !! The RiverReach1 instance real ( dp ), intent ( in ) :: D !! River depth [m] real ( dp ), intent ( in ) :: W !! River width [m] real ( dp ), intent ( in ) :: l !! River length, without meandering [m] real ( dp ), intent ( in ) :: f_m !! Meandering factor [-] real ( dp ) :: volume !! The calculated volume [m3] volume = D * W * l * f_m end function !> Calculate the area of a cross-section of the RiverReach, assuming !! a rectangular profile: !!  !!      \\text{area} = DW !!  pure function calculateArea1 ( me , D , W ) result ( area ) class ( RiverReach1 ), intent ( in ) :: me !! The RiverReach1 instance real ( dp ), intent ( in ) :: D !! River depth [m] real ( dp ), intent ( in ) :: W !! River width [m] real ( dp ) :: area !! The calculated area [m3] area = D * W end function end module","tags":"","loc":"sourcefile/classriverreach1.f08.html"},{"title":"spcRiverReach.f08 – NanoFASE","text":"Modules spcRiverReach Source Code spcRiverReach.f08 Source Code module spcRiverReach ! superclass for RiverReach subclasses ! defines properties and methods required in any implmentation ! of a RiverReach class ! a RiverReach class computes water velocity, depth and sediment dynamics for ! a defined length of (homogeneous) flowing water ! IMPORTED MODULES ! Description ! ----------- use Globals ! global declarations use netcdf ! input/output handling use mo_netcdf ! input/output handling use ResultModule ! error handling classes, required for use ErrorInstanceModule ! generation of trace error messages ! use spcBedSediment implicit none ! force declaration of all variables ! type BedSedimentElement                                         ! container type for class(BedSediment), the actual type of the bed sediment superclass !     class(BedSediment), private, allocatable :: item ! end type type , abstract , public :: RiverReach ! type declaration for superclass character ( len = 256 ) :: ref ! Reference for this object, of the form RiverReach_x_y_s_r ! PROPERTIES ! Description ! ----------- real ( dp ) :: S ! Slope of reach [m/m] real ( dp ) :: Qin ! Inflow from upstream reach [m3/timestep] real ( dp ) :: Qout ! Outflow to the next reach [m3/timestep] real ( dp ) :: Qrunoff ! Runoff from hydrological model [m3/s] real ( dp ), allocatable :: QrunoffTimeSeries (:) ! Time series runoff data from file [m3/s] real ( dp ), allocatable :: spmIn (:) ! Inflow SPM from upstream reach [kg/timestep] real ( dp ), allocatable :: spmOut (:) ! Outflow SPM to next reach [kg/timestep] real ( dp ), allocatable :: m_spm (:) ! Mass of the SPM currently in reach [kg] real ( dp ), allocatable :: m_spmTimeSeries (:,:) ! Time series of SPM inputs [kg/s] real ( dp ) :: W ! Width of reach [m] real ( dp ) :: D ! Depth of water column [m] real ( dp ) :: v ! Water velocity [m/s] real ( dp ) :: l ! Length of the river, without meandering factor [m] real ( dp ) :: f_m = 1 ! Meandering factor used for calculating river volume. Default to 1 (no meandering). real ( dp ) :: area ! The cross-sectional area of water in the reach [m2] real ( dp ) :: volume ! The volume of water in the reach [m3] real ( dp ), allocatable :: rho_spm (:) ! Sediment particle densities [kg/m3] real ( dp ) :: n ! Manning's roughness coefficient, for natural streams and major rivers. ! [Reference](http://www.engineeringtoolbox.com/mannings-roughness-d_799.html). integer :: allst ! array allocation status, must be public so RiverReach1,2 etc can use it ! TODO: Add allst handling to error handler ! CONTAINED OBJECTS ! Description ! ----------- ! type(BedSedimentElement) :: objBedSediment                  ! contained BedSediment object type ( NcGroup ) :: ncGroup ! The NETCDF group for this RiverReach contains ! METHODS ! Description ! ----------- procedure ( createRiverReach ), deferred :: create ! create the RiverReach object. Exposed name: create procedure ( destroyRiverReach ), deferred :: destroy ! remove the RiverReach object and all contained objects. Exposed name: destroy ! Interface names have to be globally unique as interfaces aren't aligned with modules ! PRIVATE ROUTINES ! Description ! ----------- procedure ( update ), deferred :: update ! Run the RiverReach simulation for one timestep procedure ( calculateDepth ), deferred :: calculateDepth ! compute the depth of the water column procedure ( calculateWidth ), deferred :: calculateWidth ! compute the width of the reach procedure ( calculateVelocity ), deferred :: calculateVelocity ! compute the water velocity procedure ( calculateSettlingVelocity ), deferred :: calculateSettlingVelocity ! compute the sediment settling velocities procedure ( calculateVolume ), deferred :: calculateVolume ! Calculate the volume of the reach procedure ( calculateArea ), deferred :: calculateArea ! Calculate the area of the reach's cross-section ! GETTERS procedure :: getVolume => getVolumeRiverReach ! Should getters all be non-abstract, seeing as all they're procedure :: getQOut => getQOutRiverReach ! doing is returning a type variable? procedure :: getSpmOut => getSpmOutRiverReach ! Return the SPM discharge end type abstract interface function createRiverReach ( me , x , y , s , r , l , QrunoffTimeSeries ) result ( res ) use Globals import RiverReach , Result , Result0D class ( RiverReach ) :: me !! The RiverReach instance integer :: x , y , s , r !! GridCell, SubRiver and RiverReach identifiers real ( dp ) :: l !! The RiverReach length [m] real ( dp ), allocatable :: QrunoffTimeSeries (:) !! Any initial runoff [m3/s] type ( Result ) :: res !! The Result object end function function destroyRiverReach ( Me ) result ( r ) import RiverReach , Result class ( RiverReach ) :: Me !! The RiverReach instance type ( Result ) :: r !! The Result object to return end function function update ( me , Qin , spmIn , t ) result ( r ) use Globals import RiverReach , Result class ( RiverReach ) :: me !! This RiverReach instance real ( dp ) :: Qin !! Inflow to this reach [m3/timestep] integer :: t !! What time step are we on? real ( dp ) :: spmIn ( C % nSizeClassesSpm ) !! Inflow SPM to this reach [kg/timestep] type ( Result ) :: r !! The Result object end function pure function calculateDepth ( Me , W , S , Q ) result ( r ) use Globals import RiverReach , Result0D class ( RiverReach ), intent ( in ) :: Me !! The RiverReach instance real ( dp ), intent ( in ) :: W !! River width [m] real ( dp ), intent ( in ) :: S !! River slope [-] real ( dp ), intent ( in ) :: Q !! Flow rate [m3/s] type ( Result0D ) :: r !! The result object end function function calculateWidth ( Me , Q ) result ( W ) use Globals import RiverReach , Result0D class ( RiverReach ), intent ( in ) :: Me !! The RiverReach instance real ( dp ), intent ( in ) :: Q !! Flow rate [m3/s] type ( ErrorInstance ) :: error !! Variable to store error in real ( dp ) :: W !! Calculated width [m] end function pure function calculateVolume ( me , D , W , l , f_m ) result ( volume ) use Globals import RiverReach , Result0D class ( RiverReach ), intent ( in ) :: me !! The RiverReach instance real ( dp ), intent ( in ) :: D !! River depth [m] real ( dp ), intent ( in ) :: W !! River width [m] real ( dp ), intent ( in ) :: l !! River length, without meandering [m] real ( dp ), intent ( in ) :: f_m !! Meandering factor [-] real ( dp ) :: volume !! Calculated volume [m3] end function pure function calculateArea ( me , D , W ) result ( area ) use Globals import RiverReach , Result0D class ( RiverReach ), intent ( in ) :: me !! The RiverReach instance real ( dp ), intent ( in ) :: D !! River depth [m] real ( dp ), intent ( in ) :: W !! River width [m] real ( dp ) :: area !! Calculated area [m2] end function pure function calculateVelocity ( me , D , Q , W ) result ( v ) use Globals import RiverReach class ( RiverReach ), intent ( in ) :: me !! The RiverReach instance real ( dp ), intent ( in ) :: D !! River depth [m] real ( dp ), intent ( in ) :: Q !! Flow rate [m3/s] real ( dp ), intent ( in ) :: W !! River width [m] real ( dp ) :: v !! The calculated velocity [m/s] end function function calculateSettlingVelocity ( Me , d , rho_spm , T ) result ( W_spm ) use Globals import RiverReach , Result0D class ( RiverReach ), intent ( in ) :: me !! The RiverReach instance real ( dp ), intent ( in ) :: d !! Sediment particle diameter [m] real ( dp ), intent ( in ) :: rho_spm !! Sediment particle density [kg/m3] real ( dp ), intent ( in ) :: T !! Temperature [C] real ( dp ) :: dStar !! Dimensionless particle diameter [-] real ( dp ) :: W_spm !! Calculated settling velocity [m/s] end function end interface contains !> Return the volume of the RiverReach. function getVolumeRiverReach ( me ) result ( volume ) class ( RiverReach ) :: me real ( dp ) :: volume volume = me % volume end function !> Return the outflow. function getQOutRiverReach ( me ) result ( Qout ) class ( RiverReach ) :: me real ( dp ) :: Qout Qout = me % Qout end function !> Return the SPM discahrge. function getSpmOutRiverReach ( me ) result ( spmOut ) class ( RiverReach ) :: me real ( dp ) :: spmOut ( size ( me % spmOut )) spmOut = me % spmOut end function end module","tags":"","loc":"sourcefile/spcriverreach.f08.html"},{"title":"classSubRiver1.f08 – NanoFASE","text":"Modules classSubRiver1 Source Code classSubRiver1.f08 Source Code module classSubRiver1 ! SubRiver1 subclass ! implements spcSubRiver superclass ! of a SubRiver class ! a SubRiver class acts as a container for a collection of RiverReach objects which collectively define a ! contiguous stretch of flowing waters within each grid cell ! IMPORTED MODULES ! Description ! ----------- use Globals ! global declarations use UtilModule ! useful utilities use netcdf ! input/output handling use mo_netcdf ! input/output handling use ResultModule ! error handling classes, required for use ErrorInstanceModule ! generation of trace error messages use spcSubRiver ! Module containing SubRiver abstract interface use classRiverReach1 implicit none ! force declaration of all variables type , extends ( SubRiver ), public :: SubRiver1 ! type declaration for subclass contains ! METHODS ! Description ! ----------- procedure , public :: create => createSubRiver1 ! create the SubRiver1 object. Exposed name: create procedure , public :: destroy => destroySubRiver1 ! remove the SubRiver1 object and all contained objects. Exposed name: destroy procedure , public :: update => updateSubRiver1 ! route water and suspended solids through the SubRiver. Exposed name: routing procedure , public :: finaliseUpdate => finaliseUpdateSubRiver1 ! Finalise the routing by setting temp outflows to actual outflows ! Description ! ----------- procedure , private :: auditrefs ! internal property function: sense check the inflow and outflow GridCell references ! THIS PROCEDURE IS NOT DEFINED IN THE ABSTRACT CLASS AS IT IS PRIVATE. CAN IT STILL BE INHERITED? end type !> Interface so that we can create new SubRivers by `sr = SubRiver1()` interface SubRiver1 module procedure newSubRiver1 end interface contains !> Return a newly-created SubRiver1 object. This is bound to SubRiver1 interface !! TODO: Do something with result object function newSubRiver1 ( x , y , s , length , QrunoffTimeSeries ) result ( me ) type ( SubRiver1 ) :: me !! The new SubRiver to return integer :: x , y , s !! Location of the SubRiver real ( dp ) :: length !! Length of the SubRiver (without meandering) real ( dp ), allocatable :: QrunoffTimeSeries (:) !! Any initial runoff from the hydrological model type ( Result ) :: r !! Result object ! Create the new SubRiver r = me % create ( x , y , s , length , QrunoffTimeSeries ) end function function createSubRiver1 ( me , x , y , s , length , QrunoffTimeSeries ) result ( r ) ! create the SubRiver object by reading data in from file class ( SubRiver1 ) :: me ! the SubRiver instance type ( integer ), intent ( in ) :: x ! the row number of the enclosing GridCell type ( integer ), intent ( in ) :: y ! the column number of the enclosing GridCell type ( integer ), intent ( in ) :: s ! reference SubRiver number real ( dp ) :: length ! The length of the SubRiver (without meandering) real ( dp ), allocatable :: QrunoffTimeSeries (:) ! Initial runoff from the hydrological model type ( Result ) :: r ! the result object real ( dp ), allocatable :: riverReachRunoffTimeSeries (:) ! Runoff for each RiverReach type ( NcDataset ) :: NC ! NetCDF dataset type ( NcVariable ) :: var ! NetCDF variable type ( NcGroup ) :: grp ! NetCDF group type ( NcGroup ) :: subRiverGrp ! NetCDF group specifically for this SubRiver type ( integer ) :: i , t ! loop counter type ( character ( len = 100 )) :: sr1 ! string to dynamically compile and hold group names (must be specific length) type ( character ( len = 100 )) :: sr2 ! string to dynamically compile and hold group names type ( RiverReach1 ), allocatable :: r1 ! private RiverReach1 type, used for dynamic assignment character ( len = 5 ) :: charMaxRiverReaches ! character string to store max number of RiverReaches allowed in ! Function purpose ! ------------------------------------------------------------- ! parameterise a SubRiver object in a specified grid cell, ! including the creation of RiverReach objects ! ! Function inputs ! ------------------------------------------------------------- ! x  : x reference to the enclosing grid cell ! y  : y reference to the enclosing grid cell ! s  : reference SubRiver number ! ! Function outputs/outcomes ! ------------------------------------------------------------- ! Fully specified SubRiver object, comprising: ! Collection of RiverReach objects: me%colReaches. ! Set of up to three inflow references inflowRefs(:), ! comprising Grid x and y references and  SubRiver number ! reference, or null if SubRiver is a headwater. allocate ( me % spmOut ( C % nSizeClassesSPM ), & ! Initialise SPM arrays to size of size classes me % spmIn ( C % nSizeClassesSpm ), & me % tmpSpmOut ( C % nSizeClassesSpm ), & me % tmpm_spm ( C % nSizeClassesSpm ), & me % m_spm ( C % nSizeClassesSpm ), & stat = me % allst ) me % ref = trim ( ref ( \"SubRiver\" , x , y , s )) ! Create SubRiver reference name, SubRiver_x_y_s me % length = length ! Set the length allocate ( me % QrunoffTimeSeries , source = QrunoffTimeSeries ) ! Set the runoff me % spmOut = 0 ! Initialise SPM to zero me % spmIn = 0 ! Get and validate the input data ! TODO: Auditing of input data is a bit of a mess at the moment, but I'm ! leaving as-is until data input is moved to some kind of Database object. ! Then we can pre-validate data files before running the model (if we want to). nc = NcDataset ( C % inputFile , \"r\" ) ! Open dataset as read-only grp = nc % getGroup ( \"Environment\" ) grp = grp % getGroup ( \"GridCell_\" // trim ( str ( x )) // \"_\" // trim ( str ( y ))) subRiverGrp = grp % getGroup ( me % ref ) ! point to the SubRiver group var = subRiverGrp % getVariable ( \"nInflows\" ) ! point to the variable nInflows: the number of inflows call var % getData ( me % nInflows ) ! pull data into variable: number of inflows call ERROR_HANDLER % trigger ( & ! Check nInflows is 1, 2 or 3 error = ERROR_HANDLER % limit ( & ! TODO: Also check nInflows equals number of inflow_x groups (or just get rid of nInflows) me % nInflows , 0 , 3 , & \"Number of RiverReach inflows must be between 0 and 3.\" , & \"Creating \" // trim ( me % ref ) & )) allocate ( me % inflowRefs ( me % nInflows ), stat = me % allst ) ! allocate required space to hold the inflow references for this SubRiver allocate ( me % inflows ( me % nInflows ), stat = me % allst ) ! likewise for the array of inflow pointers var = subRiverGrp % getVariable ( \"reachTypes\" ) ! point to the array ReachTypes: the type identifiers for the RiverReach objects in this SubRiver call var % getData ( me % reachTypes ) ! pull the Reach type references into SubRiver object me % nReaches = size ( me % reachTypes ) ! get the number of reaches from the ReachType array size call ERROR_HANDLER % trigger ( & ! Check nReaches is >0 but <maxRiverReaches (specified in config file(?)) error = ERROR_HANDLER % limit ( & ! TODO: Get number of SubRivers from outflow GridCell to check SubRiver number isn't greater me % nReaches , 0 , C % maxRiverReaches , & \"Number of RiverReaches must be positive but less than \" & // trim ( str ( C % maxRiverReaches )), & \"Creating \" // trim ( me % ref ) & )) if ( me % nInflows > 0 ) then do i = 1 , me % nInflows ! loop to read the Inflow references for this SubRiver sr1 = \"inflow_\" // trim ( str ( i )) ! create character variable 'Inflow1', 'Inflow2' etc. if (. not . subRiverGrp % hasGroup ( sr1 )) then ! Check if inflow_i group exists call ERROR_HANDLER % trigger ( error = ErrorInstance ( & ! We need to immediatedly trigger error if not, as otherwise code = 202 , & ! NetCDF library will trigger a less useful one instead message = \"Group \" // trim ( sr1 ) // \" representing inflow not found in data file. \" // & \"Make sure nInflows matches number of inflow groups.\" , & trace = [ \"Creating \" // trim ( me % ref )] & )) end if grp = subRiverGrp % getGroup ( sr1 ) ! point to the Inflow1, Inflow2 etc. group var = grp % getVariable ( \"gridX\" ) ! point to the variable defining the row of the grid cell call var % getData ( me % inflowRefs ( i )% GridX ) ! pull GridX reference into SubRiver object ! AUDIT GridX here - must be >0 and <= the highest grid cell number call r % addError ( & ! Check GridX is >0. Need to think about where highest grid cell number is specified. ERROR_HANDLER % positive ( & value = me % inflowRefs ( i )% GridX , & message = \"Inflow grid cell row number x must be positive.\" & ) & ) var = grp % getVariable ( \"gridY\" ) ! point to the variable defining the column of the grid cell call var % getData ( me % inflowRefs ( i )% GridY ) ! pull GridY reference into SubRiver object ! AUDIT GridY here - must be >0 and <= the highest grid cell number call r % addError ( & ! Check GridY is >0. Need to think about where highest grid cell number is specified. ERROR_HANDLER % positive ( & value = me % inflowRefs ( i )% GridY , & message = \"Inflow grid cell column number y must be positive.\" & ) & ) var = grp % getVariable ( \"subRiver\" ) ! point to the variable defining the SubRiver acting as an input call var % getData ( me % inflowRefs ( i )% SubRiver ) ! pull SubRiver reference into SubRiver object ! AUDIT SubRiver here - must be either null (-999, indicating SubRiver is a headwater), or >0 and <= nSubRivers call r % addError ( & ! Check SubRiver number is >0. If it's a headwater, then won't nInflows = 0 (and thus we'll never enter this loop)? ERROR_HANDLER % positive ( & ! TODO: Get number of SubRivers from inflow GridCell to check SubRiver number isn't greater value = me % inflowRefs ( i )% SubRiver , & message = \"Inflow SubRiver number must be positive.\" & ) & ) call r % addToTrace ( \"Processing \" // sr1 ) ! Add this inflow to the error trace ! I've assumed here that this is the only way to read in single elements of a user-defined type, i.e. by listing each as a separate variable. ! But can a single user-defined type (i.e. GridX, GridY and SubRiver) be listed as a single object in the .json file and ! read in as a single variable? Then \"nInflows\" could be listed in the .json file as a dimension, in the way that \"ReachTypes\" is, and the number of inflows ! inferred from the size of the inflowRefs(:) array after the inflow references have been read in. end do end if ! AUDIT size(ReachTypes)=nReaches here ! &#94; nReaches is set as size(ReachTypes) now - is there any reason not to do this? allocate ( me % colReaches ( 1 : me % nReaches ), stat = me % allst ) ! Set colReaches to be of size nReaches allocate ( riverReachRunoffTimeSeries ( size ( me % QrunoffTimeSeries ))) do t = 1 , size ( me % QrunoffTimeSeries ) ! Split the runoff between the reaches if ( me % QrunoffTimeSeries ( t ) > 0 ) then riverReachRunoffTimeSeries ( t ) = me % QrunoffTimeSeries ( t ) / me % nReaches else riverReachRunoffTimeSeries ( t ) = 0 end if end do do i = 1 , me % nReaches ! loop through each RiverReach in each SubRiver to create the reaches select case ( me % reachTypes ( i )) ! look at the type identifier for the yth RiverReach case ( 1 ) allocate ( r1 , stat = me % allst ) ! RiverReach1 type - create the object r = r1 % create ( x , y , s , i , me % length / me % nReaches , riverReachRunoffTimeSeries ) ! call the RiverReach1 constructor call move_alloc ( r1 , me % colReaches ( i )% item ) ! move the RiverReach1 object to the yth element of the colReaches collection case default ! Add error if RiverReach type index is invalid call r % addError ( ErrorInstance ( & code = 901 , & message = \"Invalid RiverReach type index (\" // trim ( str ( me % reachTypes ( i ))) // \") provided.\" , & trace = [ \"Creating \" // trim ( ref ( \"RiverReach\" , x , y , s , i ))] & )) end select end do call r % addToTrace ( \"Creating \" // trim ( me % ref )) end function function destroySubRiver1 ( me ) result ( r ) class ( SubRiver1 ) :: me ! the SubRiver instance type ( Result ) :: r ! the Result object type ( integer ) :: i ! loop counter do i = 1 , me % nReaches ! loop through each RiverReach r = me % colReaches ( i )% item % destroy () ! call destroy routine in the SubRiver object end do ! TODO: Something here to compile all returned Result objects into one? end function ! TODO: Sort out object storage of spmIn and Q_in function updateSubRiver1 ( me , t ) result ( r ) ! routes inflow(s) through the specified SubRiver class ( SubRiver1 ) :: me ! the SubRiver instance integer :: t ! What time step are we on? type ( Result ) :: r ! the Result object type ( Result ) :: reachR ! Result object for each reach real ( dp ) :: Qin ( me % nReaches + 1 ) ! The inflow, final element for outflow [m3/timestep] real ( dp ) :: spmIn ( me % nReaches + 1 , C % nSizeClassesSpm ) ! The SPM inflow per size class, final element for outflow [kg/timestep] type ( integer ) :: i ! loop counter real ( dp ) :: tmpSpmIn ( C % nSizeClassesSpm ) ! Temporary variable to pass as argument, avoiding array temporary warning (https://stackoverflow.com/questions/28859524/fortran-runtime-warning-temporary-array) ! Function purpose ! ------------------------------------------------------------- ! route water and suspended material from the upstream ! SubRiver(s), and from overland flow and erosion, through ! this SubRiver ! ! Function inputs ! ------------------------------------------------------------- ! Function uses inflows(:), which point to inflow SubRivers, ! to interrogate other SubRivers for their discharge and suspended material ! fluxes. ! ! Function outputs/outcomes ! ------------------------------------------------------------- ! Qout : outflow discharge (m3) ! spmOut(:) : outflow SPM fluxes (kg) ! These variables are stored at object level for interrogation ! by the downstream SubRiver Qin = 0 ! Initialise Q and SPM to zero, before we add the inflows and sources spmIn = 0 me % tmpm_spm = 0 ! m_spm is obtained from summing across RiverReaches, so set to zero before ! starting the summation. Reason for temporary var detailed below. ! Routing procedure: !   - Loop through inflows and sum Q and SPM !   - Pass the inflows to the first RiverReach, which internally calculates an !     outflow (and updates volume, densities, etc), which is then passed to the !     next RiverReach, and so on. !   - Outflow from final RiverReach used to set *temporary* outflow Q and SPM variables. !     These are temporary so that they don't affect inflow to other SubRivers until all !     SubRiver calculations are complete, after which a procedure in GridCell's update() !     method stores them in me%Qout and me%spmOut. do i = 1 , me % nInflows ! Loop through the inflows to retrieve and sum discharges Qin ( 1 ) = Qin ( 1 ) + me % inflows ( i )% item % getQOut () ! Pull in discharge from upstream SubRiver to first RiverReach ! SubRiver%Qout isn't set until all SubRivers have been routed, thus ensuring this is Qout for the correct timestep spmIn ( 1 ,:) = spmIn ( 1 ,:) + me % inflows ( i )% item % getSpmOut () ! pull in SPM fluxes from upstream SubRiver end do do i = 1 , me % nReaches ! main routing loop ! Main simulation call to the RiverReach, which recalculates dimensions ! and outflows based on the inflow Q and SPM tmpSpmIn = spmIn ( i ,:) ! Temporary array to avoid warning when using assumed shape as argument reachR = me % colReaches ( i )% item % update ( Qin ( i ), tmpSpmIn , t ) call r % addErrors (. errors . reachR ) ! Add any error that occured to the Result object to return Qin ( i + 1 ) = me % colReaches ( i )% item % getQOut () ! Set the next reach's inflows from this reach's outflow spmIn ( i + 1 ,:) = me % colReaches ( i )% item % getSpmOut () me % tmpm_spm = me % tmpm_spm + me % colReaches ( i )% item % m_spm ! Sum the SPM mass across the reaches to get total SPM mass for the SubRiver end do ! Temporary storage for QOut and spmOut, until all SubRivers have been routed and we can ! be sure that updating Qout won't result in the wrong timestep's Qout being used as Qin ! to a downstream SubRiver me % tmpQOut = Qin ( me % nReaches + 1 ) ! store the final outflow volume [m3] me % tmpSpmOut = spmIn ( me % nReaches + 1 , :) ! output SPM flux (kg) of size class 'n' for this displacement call r % addToTrace ( \"Updating \" // trim ( me % ref ) // \" on timestep #\" // trim ( str ( t ))) end function !> Set the outflow and SPM mass from the temporary variables that were set by the !! routing procedure. This step is kept separate from the routing so that the !! wrong outflow isn't used as an inflow for another SubRiver whilst the SubRivers !! are looped through. function finaliseUpdateSubRiver1 ( me ) result ( r ) class ( SubRiver1 ) :: me !! This SubRiver1 instace type ( Result ) :: r !! The Result object me % Qout = me % tmpQout me % spmOut = me % tmpSpmOut me % m_spm = me % tmpm_spm end function ! ****************************************************** function auditrefs ( me ) result ( r ) class ( SubRiver1 ) :: me ! the SubRiver instance type ( Result ) :: r ! the result object ! the purpose of this function is to sense check the inflow and outflow references, i.e. do they form ! robust, consistent links to adjacent grid cells? ! but perhaps this could be a function within the Environment module that audits all links at the same time ! on startup? i.e. call Audit(<GridCell>) for all GridCells? end function end module","tags":"","loc":"sourcefile/classsubriver1.f08.html"},{"title":"spcSubRiver.f08 – NanoFASE","text":"Modules spcSubRiver Source Code spcSubRiver.f08 Source Code module spcSubRiver ! superclass for SubRiver subclasses ! defines properties and methods required in any implmentation ! of a River class ! a River class acts as a container for a collection of RiverReach objects which collectively define the ! layout of the flowing waters within each grid cell ! the RiverReach class routes, water, suspended sediments (and ultimately nanoparticles) through the flowing waters within ! the grid cell ! IMPORTED MODULES ! Description ! ----------- use Globals ! global declarations use netcdf ! input/output handling use mo_netcdf ! input/output handling use ResultModule ! error handling classes, required for use ErrorInstanceModule ! generation of trace error messages use spcRiverReach ! use containing object type implicit none ! force declaration of all variables type RiverReachElement ! container type for class(RiverReach), the actual type of the RiverReach class class ( RiverReach ), allocatable :: item ! a variable of type RiverReachElement can be of any object type inheriting from the end type ! RiverReach superclass type RoutingRef ! an internal user-defined type, defining a reference to a SubRiver sending water to this type ( integer ) :: gridX ! SubRiver, or receiving water from it. Comprises row (X) and column (Y) references to the GridCell type ( integer ) :: gridY ! containing the sending/receiving subriver type ( integer ) :: subRiver ! (as this SubRiver) and the in-cell SubRiver reference number end type ! SubRiverPointer used for SubRiver inflows array, so the elements within can point to other GridCell's colSubRiver elements type SubRiverPointer class ( SubRiver ), pointer :: item => null () ! as item is a pointer, this definition can come before type(SubRiver) end type type , abstract , public :: SubRiver ! type declaration for superclass character ( len = 100 ) :: ref ! SubRiver reference of the format SubRiver_x_y_n, where x is GridCell row, ! y is GridCell column and n is SubRiver number in GridCell ! PROPERTIES ! Description ! ----------- real ( dp ) :: length ! The length of the SubRiver (without any meandering factor) type ( RoutingRef ), allocatable :: inflowRefs (:) ! array of references to source subrivers for this subriver (sources can be in a different grid cell) ! this is used temporarilly to enable me%inflows array to be filled with pointers, to save us getting ! them from the data file again integer :: nInflows ! the number of inflows to the SubRiver integer :: nReaches ! the number of reaches in the SubRiver integer , allocatable :: reachTypes (:) ! integer array of Reach type identifiers real ( dp ) :: Qin ! Inflow per timestep [m3] real ( dp ) :: Qout ! discharge from the Subriver [m3] real ( dp ), allocatable :: QrunoffTimeSeries (:) ! Complete time series runoff data [m3/timestep] real ( dp ) :: Qrunoff ! Initial runoff from the hydrological model [m3] real ( dp ) :: tmpQout ! Temporary variable to store Qout whilst other SubRivers are using previous timestep's Qout. ! Otherwise, Qin to a SubRiver might be set to the this timestep's Qout instead of the previous real ( dp ), allocatable :: spmIn (:) ! Inflow SPM masses [kg] for each size class real ( dp ), allocatable :: spmOut (:) ! Outflow SPM masses [kg], one per size class real ( dp ), allocatable :: tmpSpmOut (:) ! Temporary outflow SPM masses (see tmpQout description) real ( dp ), allocatable :: m_spm (:) ! Mass of SPM currently in SubRiver [kg], per size class real ( dp ), allocatable :: tmpm_spm (:) ! Temporary SPM mass [kg] ! need a function somewhere (probably in RiverReach) to convert SPM mass in a size class to particle number ! this is needed *** for settling rates *** and for heteroaggregation with nanoparticles integer :: allst ! array allocation status, must be public to be accessible by subclasses ! CONTAINED OBJECTS ! Description ! ----------- type ( RiverReachElement ), allocatable :: colReaches (:) ! array of RiverReachElement objects type ( SubRiverPointer ), allocatable :: inflows (:) ! array of pointers to inflows contains ! METHODS ! Description ! ----------- procedure ( createSubRiver ), deferred :: create ! create the SubRiver object. Exposed name: create procedure ( destroySubRiver ), deferred :: destroy ! remove the SubRiver object and all contained objects. Exposed name: destroy procedure ( updateSubRiver ), deferred :: update ! route water and suspended solids through a SubRiver. Exposed name: routing procedure ( finaliseUpdateSubRiver ), deferred :: finaliseUpdate ! Finalise the routing by setting temp outflows to actual outflows procedure :: getQOut => getQOutSubRiver ! Return the outflow Q [m3] procedure :: getSpmOut => getSpmOutSubRiver ! Return the outflow SPM for all size classes [kg] procedure :: getSpmOutBySizeClass => getSpmOutBySizeClassSubRiver ! Return the outflow SPM for an individual size class [kg] end type type SubRiverElement ! container type for class(SubRiver), the actual type of the SubRiver class class ( SubRiver ), allocatable :: item ! a variable of type SubRiver can be of any object type inheriting from the end type abstract interface function createSubRiver ( me , x , y , s , length , QrunoffTimeSeries ) result ( r ) ! create the SubRiver object by reading data in from file use Globals import SubRiver , Result class ( SubRiver ) :: me ! the SubRiver instance type ( integer ), intent ( in ) :: x ! the row number of the enclosing GridCell type ( integer ), intent ( in ) :: y ! the column number of the enclosing GridCell type ( integer ), intent ( in ) :: s ! reference SubRiver number real ( dp ) :: length ! The SubRiver length real ( dp ), allocatable :: QrunoffTimeSeries (:) ! Any initial runoff type ( Result ) :: r ! the result object end function function destroySubRiver ( me ) result ( r ) import SubRiver , Result class ( SubRiver ) :: me ! the SubRiver instance type ( Result ) :: r ! the result object end function function updateSubRiver ( me , t ) result ( r ) ! routes inflow(s) through the SubRiver import SubRiver , Result class ( SubRiver ) :: me ! the SubRiver instance integer :: t ! What time step are we on? type ( Result ) :: r ! the result object end function function finaliseUpdateSubRiver ( me ) result ( r ) import SubRiver , Result class ( SubRiver ) :: me type ( Result ) :: r end function end interface contains !> Get the discharge from the SubRiver. function getQOutSubRiver ( me ) result ( QOut ) class ( SubRiver ) :: me !! This SubRiver instance real ( dp ) :: QOut !! Discharge out of the SubRiver [m3] QOut = me % QOut end function !> Get the SPM discharge from the SubRiver. function getSpmOutSubRiver ( me ) result ( spmOut ) class ( SubRiver ) :: me !! This SubRiver instance real ( dp ) :: spmOut ( size ( me % spmOut )) !! SPM discharge for all size classes [kg] spmOut = me % spmOut end function !> Get the SPM discharge from the SubRiver, for a given size class. function getSpmOutBySizeClassSubRiver ( me , n ) result ( spmOut ) class ( SubRiver ) :: me !! This SubRiver instance integer :: n !! Size class real ( dp ) :: spmOut !! SPM discharge [kg] if ( allocated ( me % spmOut )) then spmOut = me % spmOut ( n ) end if end function end module","tags":"","loc":"sourcefile/spcsubriver.f08.html"},{"title":"classGridCell1.f08 – NanoFASE","text":"Modules classGridCell1 Source Code classGridCell1.f08 Source Code module classGridCell1 ! superclass for SubRiver subclasses ! defines properties and methods required in any implmentation ! of a River class ! a River class acts as a container for a collection of RiverReach objects which collectively define the ! layout of the flowing waters within each grid cell ! the RiverReach class routes, water, suspended sediments (and ultimately nanoparticles) through the flowing waters within ! the grid cell ! IMPORTED MODULES ! Description ! ----------- use Globals ! global declarations use UtilModule ! useful functions, e.g. str() use mo_netcdf ! input/output handling use ResultModule ! error handling classes, required for use ErrorInstanceModule ! generation of trace error messages use spcGridCell use classSoilProfile1 use classSubRiver1 implicit none ! force declaration of all variables type , public , extends ( GridCell ) :: GridCell1 ! type declaration for subclass ! ----------- contains ! METHODS ! Description ! ----------- procedure :: create => createGridCell1 ! create the GridCell object. Exposed name: create procedure :: destroy => destroyGridCell1 ! remove the GridCell object and all contained objects. Exposed name: destroy procedure :: update => updateGridCell1 ! route water and suspended solids through all SubRiver objects. Exposed name: update procedure :: finaliseUpdate => finaliseUpdateGridCell1 ! Set variables for this timestep that couldn't be updated whilst simulation running procedure :: parseInputData => parseInputDataGridCell1 ! Parse the input data and store in object properties end type !> Interface so that we can create new GridCells by `gc = GridCell1()` interface GridCell1 module procedure newGridCell1 end interface contains !> Return a newly-created GridCell1 object. !! TODO: Do something with result object function newGridCell1 ( x , y , isEmpty ) result ( me ) type ( GridCell1 ) :: me !! The new GridCell to return integer :: x , y !! Location of the GridCell logical , optional :: isEmpty !! Is anything to be simulated in this GridCell? type ( Result ) :: r !! Result object ! Create the new GridCell, specifying isEmpty if it's present (it default to false if not) if ( present ( isEmpty )) r = me % create ( x , y , isEmpty ) if (. not . present ( isEmpty )) r = me % create ( x , y ) end function !> Create a GridCell with coordinates x and y. function createGridCell1 ( me , x , y , isEmpty ) result ( r ) class ( GridCell1 ) :: me !! The GridCell instance. type ( Result ) :: r !! The Result object to return. integer :: x , y !! Location of the GridCell logical , optional :: isEmpty !! Is anything to be simulated in this GridCell? type ( SoilProfile1 ) :: soilProfile !! The soil profile contained in this GridCell integer :: s !! Iterator for SubRivers integer :: t !! Iterator for time series character ( len = 100 ) :: subRiverPrefix !! Prefix for SubRivers ref, e.g. SubRiver_1_1 real ( dp ) :: subRiverLength !! Length of the SubRivers real ( dp ), allocatable :: subRiverRunoffTimeSeries (:) !! Runoff to each SubRiver type ( Result ) :: srR !! Result object for individual SubRivers type ( SubRiver1 ), allocatable :: sr1 !! SubRiver1 object for storing created SubRiver1s in ! Allocate the object properties that need to be and set up defaults allocate ( me % QrunoffTimeSeries ( C % nTimeSteps )) allocate ( subRiverRunoffTimeSeries ( C % nTimeSteps )) allocate ( me % colSoilProfiles ( 1 )) me % Qrunoff = 0 ! Default to no runoff ! Set the GridCell's position, area, whether it's empty and its name me % gridX = x me % gridY = y me % area = C % gridCellSize ** 2 ! TODO: This will be changed to take into account lat-lon if ( present ( isEmpty )) me % isEmpty = isEmpty ! isEmpty defaults to false if not present me % ref = trim ( ref ( \"GridCell\" , x , y )) ! ref() interface is from the Util module ! Only carry on if there's stuff to be simulated for this GridCell if ( me % isEmpty . eqv . . false .) then r = me % parseInputData () ! Parse and store input data in this object ! Create a soil profile and add to this GridCell r = soilProfile % create ( me % gridX , me % gridY , 1 , me % slope , me % n_river , me % area ) allocate ( me % colSoilProfiles ( 1 )% item , source = soilProfile ) ! Add SubRivers to the GridCell (if any are present in the data file) ! Only proceed if there are no critical errors (which might be caused by parseInputData()) if (. not . r % hasCriticalError ()) then subRiverPrefix = \"SubRiver_\" // trim ( str ( me % gridX )) // & \"_\" // trim ( str ( me % gridY )) // \"_\" ! Set SubRiver size to half of the grid cell size if there's more than one SubRiver, ! otherwise the full size of the grid cell. TODO: Constrain number of SubRivers somewhere ! so this makes sense. if ( me % nSubRivers > 1 ) then subRiverLength = C % gridCellSize / 2.0_dp else subRiverLength = C % gridCellSize end if ! Loop through SubRivers, incrementing s (from SubRiver_x_y_s), until none found do s = 1 , me % nSubRivers ! Split the runoff between SubRivers do t = 1 , size ( me % QrunoffTimeSeries ) if ( me % QrunoffTimeSeries ( t ) > 0 ) then subRiverRunoffTimeSeries ( t ) = me % QrunoffTimeSeries ( t ) / me % nSubRivers else subRiverRunoffTimeSeries ( t ) = 0 end if end do ! Check that group actually exists ! TODO: Maybe perform this check somewhere else if ( me % ncGroup % hasGroup ( trim ( subRiverPrefix ) // trim ( str ( s )))) then allocate ( sr1 ) ! Create the new SubRiver srR = sr1 % create ( me % gridX , me % gridY , s , subRiverLength , subRiverRunoffTimeSeries ) call r % addErrors ( errors = . errors . srR ) ! Add any errors to final Result object call move_alloc ( sr1 , me % colSubRivers ( s )% item ) ! Allocate a new SubRiver to the colSubRivers array else call r % addError ( ErrorInstance ( & code = 501 , & message = \"No input data provided for \" // trim ( subRiverPrefix ) // trim ( str ( s )) // & \" - check nSubRivers is set correctly.\" & )) end if end do end if end if call r % addToTrace ( \"Creating \" // trim ( me % ref )) call ERROR_HANDLER % trigger ( errors = . errors . r ) end function function destroyGridCell1 ( Me ) result ( r ) class ( GridCell1 ) :: Me !! The GridCell instance. type ( Result ) :: r !! The Result object type ( integer ) :: x !! loop counter do x = 1 , me % nSubRivers r = Me % colSubRivers ( x )% item % destroy () ! remove all SubRiver objects and any contained objects end do do x = 1 , Me % nSoilProfiles r = Me % colSoilProfiles ( x )% item % destroy () ! remove all SoilProfile objects and any contained objects end do do x = 1 , Me % nPointSources r = Me % colPointSources ( x )% item % destroy () ! remove all PointSource objects and any contained objects end do r = Me % objDiffuseSource % item % destroy () ! remove the DiffuseSource object and any contained objects end function !> Perform the simulations required for an individual timestep t. function updateGridCell1 ( Me , t ) result ( r ) class ( GridCell1 ) :: Me ! The GridCell instance integer :: t ! The timestep we're on type ( Result ) :: srR ! Result object for SubRivers type ( Result ) :: r ! Result object type ( integer ) :: s ! Loop counter ! Check that the GridCell is not empty before simulating anything if (. not . me % isEmpty ) then ! Loop through all SoilProfiles (only one for the moment), run their ! simulations and store the eroded sediment in this object r = me % colSoilProfiles ( 1 )% item % update ( t , me % QrunoffTimeSeries ( t )) me % erodedSediment = me % colSoilProfiles ( 1 )% item % erodedSediment ! Loop through each SubRiver and run its update procedure do s = 1 , me % nSubRivers srR = me % colSubRivers ( s )% item % update ( t ) call r % addErrors ( errors = . errors . srR ) end do end if ! Add this procedure to the error trace and trigger any errors that occurred call r % addToTrace ( \"Updating \" // trim ( me % ref ) // \" on timestep #\" // trim ( str ( t ))) call ERROR_HANDLER % trigger ( errors = . errors . r ) end function !> Set the outflow from the temporary outflow variables that were setting by the !! update procedure. This step is kept separate from the routing so that the !! wrong outflow isn't used as an inflow for another SubRiver whilst the SubRivers !! are looped through. function finaliseUpdateGridCell1 ( me ) result ( r ) class ( GridCell1 ) :: me !! This SubRiver1 instace integer :: s !! Iterator of SubRivers type ( Result ) :: r !! The Result object if (. not . me % isEmpty ) then do s = 1 , me % nSubRivers r = me % colSubRivers ( s )% item % finaliseUpdate () end do end if end function !> Get the data from the input file and set object properties !! accordingly, including allocation of arrays that depend on !! input data. function parseInputDataGridCell1 ( me ) result ( r ) class ( GridCell1 ) :: me !! This GridCell1 object type ( NcDataset ) :: nc !! NetCDF dataset type ( NcVariable ) :: var !! NetCDF variable type ( NcGroup ) :: grp !! NetCDF group type ( Result ) :: r !! The result object ! Open the dataset nc = NcDataset ( C % inputFile , \"r\" ) ! Open dataset as read-only grp = nc % getGroup ( \"Environment\" ) me % ncGroup = grp % getGroup ( me % ref ) ! Get this GridCell's group ! Get the number of SubRivers for looping over if ( me % ncGroup % hasVariable ( \"nSubRivers\" )) then var = me % ncGroup % getVariable ( \"nSubRivers\" ) call var % getData ( me % nSubRivers ) else me % nSubRivers = 0 ! If nSubRivers isn't present, default to having no SubRivers end if allocate ( me % colSubRivers ( me % nSubRivers )) ! Allocate the colSubRivers array to the number of SubRivers in the GridCell ! Get the time-dependent runoff data from the file and put in array ready for use ! TODO: Runoff data currently m3/s, but maybe this should be m/s instead? if ( me % ncGroup % hasVariable ( \"runoff\" )) then var = me % ncGroup % getVariable ( \"runoff\" ) call var % getData ( me % QrunoffTimeSeries ) me % QrunoffTimeSeries = me % QrunoffTimeSeries * C % timeStep ! Convert to m3/timestep else me % QrunoffTimeSeries = 0 end if ! Slope of the GridCell [m/m] if ( me % ncGroup % hasVariable ( 'slope' )) then var = me % ncGroup % getVariable ( 'slope' ) call var % getData ( me % slope ) else call r % addError ( ErrorInstance ( & code = 201 , & message = \"Value for slope not found in input file.\" & )) end if ! Manning's roughness coefficient [-] if ( me % ncGroup % hasVariable ( 'n_river' )) then var = me % ncGroup % getVariable ( 'n_river' ) call var % getData ( me % n_river ) else call r % addError ( ErrorInstance ( & code = 201 , & message = \"Value for n_river not found in input file. \" // & \"Defaulting to 0.035 (natural streams and major rivers).\" , & isCritical = . false . & )) me % n_river = 0.035 end if end function end module","tags":"","loc":"sourcefile/classgridcell1.f08.html"},{"title":"spcGridCell.f08 – NanoFASE","text":"Modules spcGridCell Source Code spcGridCell.f08 Source Code module spcGridCell ! superclass for SubRiver subclasses ! defines properties and methods required in any implmentation ! of a River class ! a River class acts as a container for a collection of RiverReach objects which collectively define the ! layout of the flowing waters within each grid cell ! the RiverReach class routes, water, suspended sediments (and ultimately nanoparticles) through the flowing waters within ! the grid cell ! IMPORTED MODULES ! Description ! ----------- use Globals ! global declarations use mo_netcdf ! input/output handling use ResultModule ! error handling classes, required for use ErrorInstanceModule ! generation of trace error messages use spcSubRiver ! use containing object type use spcSoilProfile use classDiffuseSource use classPointSource implicit none ! force declaration of all variables ! SoilProfile superclass type PointSourceElement ! container type for class(PointSource), the actual type of the PointSource class class ( PointSource ), allocatable :: item ! a variable of type PointSource can be of any object type inheriting from the end type ! PointSource superclass type DiffuseSourceElement ! container type for class(DiffuseSource), the actual type of the DiffuseSource class class ( DiffuseSource ), allocatable :: item ! a variable of type DiffuseSource can be of any object type inheriting from the end type ! DiffuseSource superclass type , abstract , public :: GridCell ! type declaration for superclass character ( len = 256 ) :: ref ! a name for the object type ( NcGroup ) :: ncGroup ! The NetCDF group for this dataset ! PROPERTIES ! Description ! ----------- type ( integer ) :: gridX ! grid cell x reference type ( integer ) :: gridY ! grid cell y reference real ( dp ) :: area ! Area of the GridCell type ( SubRiverElement ), allocatable :: colSubRivers (:) ! array of SubRiverElement objects to hold the subrivers type ( SoilProfileElement ), allocatable :: colSoilProfiles (:) ! array of SoilProfileElement objects to hold the soil profiles ! NOTE current plan is to have single soil profile per Grid Cell. Declaring as an array for possible future flexibility. type ( PointSourceElement ), allocatable :: colPointSources (:) ! array of PointSourceElement objects to hold the point sources type ( DiffuseSourceElement ) :: objDiffuseSource ! DiffuseSourceElement object to hold the diffuse source type ( integer ) :: nSubRivers = 0 ! Number of contained sub rivers type ( integer ) :: nSoilProfiles = 0 ! Number of contained soil profiles type ( integer ) :: nPointSources = 0 ! Number of contained point sources type ( logical ) :: DiffS ! Yes=diffuse source present; NO=no diffuse source real ( dp ), allocatable :: QrunoffTimeSeries (:) ! Runoff from the hydrological model real ( dp ) :: Qrunoff ! Runoff from the hydrological model real ( dp ) :: slope ! The slope of the GridCell real ( dp ) :: n_river ! Manning's roughness coefficient for the river real ( dp ), allocatable :: erodedSediment (:) ! Sediment yield eroded on this timestep [kg/timestep], simulated by SoilProfile(s) logical :: isEmpty = . false . ! Is there anything going on in the GridCell or should we skip over when simulating? ! CONTAINED OBJECTS ! Description ! ----------- contains ! METHODS ! Description ! ----------- procedure ( createGridCell ), deferred :: create ! create the GridCell object. Exposed name: create procedure ( destroyGridCell ), deferred :: destroy ! remove the GridCell object and all contained objects. Exposed name: destroy procedure ( updateGridCell ), deferred :: update ! route water and suspended solids through all SubRiver objects. Exposed name: routing procedure ( finaliseUpdateGridCell ), deferred :: finaliseUpdate end type type GridCellElement ! Container type for polymorphic GridCells class ( GridCell ), allocatable :: item end type abstract interface function createGridCell ( me , x , y , isEmpty ) result ( r ) import GridCell , Result class ( GridCell ) :: me !! The GridCell instance. integer :: x , y !! The (x,y) position of the GridCell. logical , optional :: isEmpty !! Is anything to be simulated for this GridCell? type ( Result ) :: r end function function destroyGridCell ( me ) result ( r ) import GridCell , Result class ( GridCell ) :: me ! The GridCell instance. type ( Result ) :: r end function function updateGridCell ( me , t ) result ( r ) import GridCell , Result class ( GridCell ) :: me ! The GridCell instance. integer :: t ! What time step are we on? type ( Result ) :: r end function function finaliseUpdateGridCell ( me ) result ( r ) import GridCell , Result class ( GridCell ) :: me type ( Result ) :: r end function end interface end module","tags":"","loc":"sourcefile/spcgridcell.f08.html"},{"title":"classBiota1.f08 – NanoFASE","text":"Modules classBiota1 Source Code classBiota1.f08 Source Code module classBiota1 !! class definition for Biota1 use spcBiota ! use spcBiota interface implicit none ! force declaration of all variables type , public , extends ( Biota ) :: objBiota1 !! type declaration for class - extends interface contains procedure :: create => createObjBiota1 ! Different procedure name (createObjBiota1) need for each procedure :: destroy => destroyObjBiota1 ! class if overloading the binding name create. end type contains subroutine createObjBiota1 ( Me ) !! constructor method class ( objBiota1 ) :: Me !! This Biota1 instance Me % name = \"Biota 1\" ! Hard code name for testing purposes (see main.f08) end subroutine subroutine destroyObjBiota1 ( Me ) !! finaliser method class ( objBiota1 ) :: Me end subroutine end module","tags":"","loc":"sourcefile/classbiota1.f08.html"},{"title":"classBiota2.f08 – NanoFASE","text":"Modules classBiota2 Source Code classBiota2.f08 Source Code module classBiota2 !! class definition for Biota2 use spcBiota ! use spcBiota interface implicit none ! force declaration of all variables type , public , extends ( Biota ) :: objBiota2 !! type declaration for class - extends interface contains procedure :: create => createObjBiota2 ! Bind createObjBiota2 to create to overload create interface procedure :: destroy => destroyObjBiota2 end type contains subroutine createObjBiota2 ( Me ) !! constructor method class ( objBiota2 ) :: Me !! This Biota2 instance Me % name = \"Biota 2\" ! Hard code name for testing purposes (see main.f08) end subroutine subroutine destroyObjBiota2 ( Me ) !! finaliser method class ( objBiota2 ) :: Me !! This Biota2 instance end subroutine end module","tags":"","loc":"sourcefile/classbiota2.f08.html"},{"title":"spcBiota.f08 – NanoFASE","text":"Modules spcBiota Source Code spcBiota.f08 Source Code module spcBiota !! superclass definition for Biota implicit none ! force declaration of all variables type , abstract , public :: Biota !! type declaration for class ! class properties character ( len = 256 ) :: name ! a name for the object contains ! METHODS - all declared deferred procedure , public :: create => createBiota ! constructor method procedure , public :: destroy => destroyBiota ! finaliser method ! any other private subroutines or functions go here end type contains subroutine createBiota ( me ) class ( Biota ) :: me ! Do some stuff to create biota end subroutine subroutine destroyBiota ( me ) class ( Biota ) :: me ! Do some stuff to destory biota end subroutine end module","tags":"","loc":"sourcefile/spcbiota.f08.html"},{"title":"classReactor1.f08 – NanoFASE","text":"Modules classReactor1 Source Code classReactor1.f08 Source Code module classReactor1 ! class definition for Reactor1 use spcReactor ! use spcReactor superclass implicit none ! force declaration of all variables type , public , extends ( Reactor ) :: objReactor1 ! type declaration for class - extends interface contains procedure :: create => newObjReactor1 procedure :: destroy => destroyObjReactor1 end type contains subroutine newObjReactor1 ( Me ) ! constructor method class ( objReactor1 ) :: Me ! correct? Me % name = \"Reactor 1\" end subroutine subroutine destroyObjReactor1 ( Me ) ! finaliser method class ( objReactor1 ) :: Me ! correct? end subroutine end module","tags":"","loc":"sourcefile/classreactor1.f08.html"},{"title":"classReactor2.f08 – NanoFASE","text":"Modules classReactor2 Source Code classReactor2.f08 Source Code module classReactor2 ! class definition for Reactor2 use spcReactor ! use spcReactor superclass implicit none ! force declaration of all variables type , public , extends ( Reactor ) :: objReactor2 ! type declaration for class - extends interface contains procedure :: create => newObjReactor2 procedure :: destroy => destroyObjReactor2 end type contains subroutine newObjReactor2 ( Me ) ! constructor method class ( objReactor2 ) :: Me ! correct? Me % name = \"Reactor 2\" end subroutine subroutine destroyObjReactor2 ( Me ) ! finaliser method class ( objReactor2 ) :: Me ! correct? end subroutine end module","tags":"","loc":"sourcefile/classreactor2.f08.html"},{"title":"spcReactor.f08 – NanoFASE","text":"Modules spcReactor Source Code spcReactor.f08 Source Code module spcReactor ! class definition for Reactor1 implicit none ! force declaration of all variables type , abstract , public :: Reactor ! type declaration for interface ! class properties character ( len = 256 ) :: name ! a name for the object contains ! METHODS - all declared deferred procedure , public :: create => createReactor ! constructor method procedure , public :: destroy => destroyReactor ! finaliser method ! any other subroutines or functions go here end type contains subroutine createReactor ( me ) class ( Reactor ) :: me ! Do stuff to create reactor end subroutine subroutine destroyReactor ( me ) class ( Reactor ) :: me ! Do stuff to destroy reactor end subroutine end module","tags":"","loc":"sourcefile/spcreactor.f08.html"},{"title":"classBedSediment1.f08 – NanoFASE","text":"Calculate resuspension from bed sediment using\n Calculate the stream power (per unit area of stream bed) using Bagnold's Modules classBedSediment1 Source Code classBedSediment1.f08 Source Code module classBedSediment1 ! class definition for BedSediment1 use Globals use ResultModule use spcBedSediment ! use BedSediment superclass use classBedSedimentLayer1 implicit none ! force declaration of all variables private type , public , extends ( BedSediment ) :: & BedSediment1 ! type declaration for class - extends abstract superclass contains procedure , public :: create => createBedSediment1 ! constructor method procedure , public :: destroy => destroyBedSediment1 ! finaliser method procedure , public :: deposit => DepositSediment1 ! deposit sediment from water column procedure , public :: resuspend => ResuspendSediment1 ! resuspend sediment to water column !        procedure, public :: Resuspension => calculateResuspensionBedSediment1 !        procedure, public :: StreamPower => calculateStreamPowerBedSediment1 end type contains !> Create a BedSediment object. function createBedSediment1 ( Me , & n , & ln , & nsc , & nl , & bslType , & C_tot , & f_comp , & pd_comp , & Porosity , & V_f , & M_f ) result ( r ) class ( BedSediment1 ) :: Me !! self-reference type ( Result ) :: r !! returned Result object character ( len = 256 ), intent ( in ) :: n !! a name for the object character ( len = 256 ), allocatable :: ln (:) !! names for the layers. Index = layer integer , intent ( in ) :: nsc !! the number of particle size classes integer , intent ( in ) :: nl !! the number of layers integer , intent ( in ) :: bslType !! the type identification number of the BedSedimentLayer(s) real ( dp ), intent ( in ), allocatable :: C_tot (:) !! the total volume of each layer. Index = layer real ( dp ), intent ( in ), allocatable :: f_comp (:,:,:) !! set of fractional compositions !! Index 1 = size class, Index 2 = compositional fraction, Index 3 = layer real ( dp ), intent ( in ), allocatable :: pd_comp (:) !! set of fractional particle densities !! Index 1 = size class real ( dp ), intent ( in ), optional :: Porosity (:) !! layer porosity, if being used to define layer !! Index 1 = layer real ( dp ), intent ( in ), optional , allocatable :: V_f (:,:) !! set of fine sediment volumes, if being used to define layers !! Index 1 = size class, Index 2 = layer real ( dp ), intent ( in ), optional , allocatable :: M_f (:,:) !! set of fine sediment masses, if being used to define layers !! Index 1 = size class, Index 2 = layer integer :: L ! LOCAL loop counter type ( BedSedimentLayer1 ), allocatable :: bsl1 ! LOCAL object of type BedSedimentLayer1, for implementation of polymorphism type ( ErrorInstance ) :: er ! To store errors in character ( len = 256 ) :: tr ! error trace character ( len = 16 ), parameter :: ms = \"Allocation error\" ! allocation error message ! ! Function purpose ! ---------------------------------------------------------------------------------- ! deallocate all allocatable variables and call destroy methods for all ! enclosed objects ! ! Function inputs ! ---------------------------------------------------------------------------------- ! none ! ! Function outputs/outcomes ! ---------------------------------------------------------------------------------- ! ! returns a warning if any deallocation throws an error ! ! Notes ! ---------------------------------------------------------------------------------- ! ! TODO: ! check n exists (len_trim /= 0) ! check nsc > 0 ! check nl > 0 ! check all C_tot > 0 ! check one of V_f and M_f present !   if both present, use V_f, add warning message ! if V_f input: !    check size consistent with number of size classes !    check size consistent with number of layers !    check all V_f > 0 and (later in code) V_f < C_tot for all layers ! if M_f input: !    check size consistent with number of size classes !    check size consistent with number of layers !    check all M_f > 0 (TODO: must check derived V_f < C_tot for all layers) ! check size of ln consistent with number of layers ! check indices of f_comp correct ! check index of pd_comp consistent with index 2 of f_comp ! check size of Porosity consistent with number of layers ! for each layer in turn, call create method with relevant subarrays: tr = Me % name // \"createBedSediment1\" ! procedure name as trace Me % nSizeClasses = nsc ! set number of size classes Me % nfComp = size ( pd_comp ) ! set number of compositional fractions Me % nLayers = nl ! set number of layers allocate ( Me % colBedSedimentLayers ( nl ), stat = Me % allst ) ! create BedSedimentLayer collection if ( Me % allst /= 0 ) then er = ErrorInstance ( code = 1 , & message = [ ms ], & trace = [ tr ] & ) ! create warning if error thrown call r % addError ( er ) ! add to Result return ! critical error, so return end if do L = 1 , Me % nLayers select case ( bslType ) ! loop through possible BedSedimentLayer types case ( 1 ) ! type number 1 allocate ( bsl1 , stat = Me % allst ) ! allocate empty object of this type if ( Me % allst /= 0 ) then er = ErrorInstance ( code = 1 , & message = [ ms ], & trace = [ tr ] & ) ! create warning if error thrown call r % addError ( er ) ! add to Result return ! critical error, so return end if if ( present ( Porosity )) then if ( present ( V_f )) then call r % addErrors (. errors . & bsl1 % create ( ln ( L ), & nsc , & 1 , & ! FSTYPE C_tot ( L ), & f_comp (:,:, L ), & pd_comp , & Porosity = Porosity ( L ), & V_f = V_f (:, L ) & ) & ) ! if V_f and Porosity as present else call r % addErrors (. errors . & bsl1 % create ( ln ( L ), & nsc , & 1 , & ! FSTYPE C_tot ( L ), & f_comp (:,:, L ), & pd_comp , & Porosity = Porosity ( L ), & M_f = M_f (:, L ) & ) & ) ! if M_f and Porosity as present end if else if ( present ( V_f )) then call r % addErrors (. errors . & bsl1 % create ( ln ( L ), & nsc , & 1 , & ! FSTYPE C_tot ( L ), & f_comp (:,:, L ), & pd_comp , & V_f = V_f (:, L ) & ) & ) ! if V_f is present and Porosity is absent else call r % addErrors (. errors . & bsl1 % create ( ln ( L ), & nsc , & 1 , & ! FSTYPE C_tot ( L ), & f_comp (:,:, L ), & pd_comp , & M_f = M_f (:, L ) & ) & ) ! if M_f is present and Porosity is absent end if end if call move_alloc ( bsl1 , & Me % colBedSedimentLayers ( L )% item ) ! move bsl1 object into layers collection case default ! invalid BedSedimentLayer type specified call r % addError ( ErrorInstance ( code = 1 , & message = \"Invalid & FineSediment & object type & specified\" & ) & ) ! add ErrorInstance call r % addToTrace ( tr ) ! add trace to Result return ! critical error, so exit end select end do ! exit ! ---------------------------------------------------------------------------------- end function !> deallocate all allocatable variables and call destroy methods for all enclosed objects function destroyBedSediment1 ( Me ) result ( r ) class ( BedSediment1 ) :: Me !! self-reference type ( Result ) :: r !! returned Result object type ( ErrorInstance ) :: er ! LOCAL ErrorInstance object for error handling. character ( len = 256 ) :: tr ! LOCAL name of this procedure, for trace integer :: L ! LOCAL Loop iterator character ( len = 18 ), parameter :: ms = \"Deallocation error\" ! LOCAL CONSTANT error message ! ! Function purpose ! ---------------------------------------------------------------------------------- ! deallocate all allocatable variables and call destroy methods for all ! enclosed objects ! ! Function inputs ! ---------------------------------------------------------------------------------- ! none ! ! Function outputs/outcomes ! ---------------------------------------------------------------------------------- ! ! returns a warning if any deallocation throws an error ! ! Notes ! ---------------------------------------------------------------------------------- ! ! no notes ! ---------------------------------------------------------------------------------- do L = 1 , Me % nLayers call r % addErrors (. errors . & Me % colBedSedimentLayers ( L )% item % destroy ()) ! destroy enclosed BedSedimentLayers end do tr = Me % name // & \"%destroyBedSedimentLayer1%colBedSedimentLayers\" ! trace message deallocate ( Me % colBedSedimentLayers , stat = Me % allst ) ! deallocate all allocatable variables if ( Me % allst /= 0 ) then er = ErrorInstance ( code = 1 , & message = ms , & trace = [ tr ] & ) ! create warning if error thrown call r % addError ( er ) ! add to Result end if end function !> compute resuspension from bed sediment function resuspendSediment1 ( Me , M_resusp , FS ) result ( r ) class ( BedSediment1 ) :: Me ! self-reference real ( dp ), intent ( in ), allocatable :: M_resusp (:) ! array of sediment masses to be resuspended [kg m-2]. Index = size class[1,...,S] type ( FineSediment1 ), intent ( out ), allocatable :: FS (:,:) ! array returning resuspended fine sediment. Index 1 = size class, Index 2 = layer type ( Result ) :: r ! returned Result object type ( FineSediment1 ), allocatable :: F ! LOCAL FineSediment object representing material that has been resuspended type ( FineSediment1 ), allocatable :: G ! LOCAL FineSediment object representing material to be resuspended type ( ErrorInstance ) :: er ! To store errors in integer :: S ! LOCAL loop counter for size classes integer :: L ! LOCAL counter for layers character ( len = 256 ) :: tr ! LOCAL name of this procedure, for trace ! ! Function purpose ! ---------------------------------------------------------------------------------- ! Resuspend specified masses of fine sediment in each size class, and their ! associated water ! ! Function inputs ! ---------------------------------------------------------------------------------- ! Function takes as inputs: ! M_resusp (real, dp)      1D array of fine sediment masses to be resuspended ! ! Function outputs/outcomes ! ---------------------------------------------------------------------------------- ! ! returns a warning if the resuspended mass in a size class exceeds the mass in the ! sediment bed ! ! FS(:,:) returns resuspended fine sediments, split by size class and layer ! ! Notes ! ---------------------------------------------------------------------------------- ! QUESTION: FS, W and C do not bring any inputs into the function, so they are !           allocated here - but is this possible??? ! ---------------------------------------------------------------------------------- tr = Me % name // \"ResuspendSediment1\" ! error trace for this procedure if ( size ( M_resusp ) /= Me % nSizeClasses ) then ! number of size classes must be consistent call r % addError ( ErrorInstance ( & code = 1 , & message = \"Number of resuspended & sediment classes does not & match number of size classes & in sediment\" , & trace = [ tr ] & )) ! create error instance return end if ! exit if a critical error has been thrown allocate ( F , stat = Me % allst ) ! set up FineSediment1 variable F if ( Me % allst /= 0 ) then er = ErrorInstance ( 1 , & \"Allocation error\" , & . false ., & [ Me % name // & \"%resuspendSediment1%F\" ] & ) ! create warning if error thrown call r % addError ( er ) ! add to Result end if allocate ( G , stat = Me % allst ) ! set up FineSediment1 variable F if ( Me % allst /= 0 ) then er = ErrorInstance ( 1 , & \"Allocation error\" , & . false ., & [ Me % name // & \"%resuspendSediment1%G\" ] & ) ! create warning if error thrown call r % addError ( er ) ! add to Result end if if ( r % hasCriticalError ()) return ! exit if allocation error thrown do S = 1 , Me % nSizeClasses ! loop through all size classes call r % addErrors (. errors . G % set ( Mf_in = M_resusp ( S ) & ) & ) ! top layer: set up the temporary object G, with the resuspended mass if ( r % hasCriticalError ()) then call r % addToTrace ( tr ) return ! exit if a critical error has been thrown end if L = 1 ! start with top layer associate ( O => Me % colBedSedimentLayers ( L )% item ) ! association for brevity do while ( M_resusp ( S ) > 0 . and . L <= Me % nLayers ) ! loop through layers until all sediment resuspended or all layers considered call r % addErrors (. errors . & G % set ( Vw_in = M_resusp ( S ) / O % volSLR () & ) & ) ! add the water content to G ! and the volume of water to be resuspended along with the fine sediment if ( r % hasCriticalError ()) then call r % addToTrace ( tr ) return ! exit if a critical error has been thrown end if call r % addErrors (. errors . & O % removeSediment ( S , G , F ) & ) ! remove the resuspended sediment, put the resuspended sediment into F if ( r % hasCriticalError ()) then call r % addToTrace ( tr ) return ! exit if a critical error has been thrown end if call r % addErrors (. errors . & FS ( L , S )% set ( Mf_in = F % M_f (), & Vw_in = F % V_w (), & f_comp_in = F % f_comp & ) & ) ! set resuspended fine sediment mass, water volume and fractional composition if ( r % hasCriticalError ()) then call r % addToTrace ( tr ) return ! exit if a critical error has been thrown end if M_resusp ( S ) = M_resusp ( S ) - FS ( L , S )% M_f () ! keep count of fine sediment that has been resuspended L = L + 1 ! the residual resuspended sediment into G. Repeat until all sediment has been end do ! resuspended, or sediment has been removed from all layers if ( M_resusp ( S ) > 0 ) then er = ErrorInstance ( 1 , & \"All sediment of size class \" & // trim ( str ( S )) // \" resuspended\" , & . false ., & [ tr ] & ) ! warning (noncritical error) if bed has been stripped of size class S call r % addError ( er ) ! add the error to the Result end if end associate end do deallocate ( F , stat = Me % allst ) ! deallocate FineSediment1 variable F if ( Me % allst /= 0 ) then er = ErrorInstance ( code = 1 , & message = \"Deallocation error\" , & trace = [ Me % name // & \"%resuspendSediment1%F\" ] & ) ! create warning if error thrown call r % addError ( er ) ! add to Result end if deallocate ( G , stat = Me % allst ) ! deallocate FineSediment1 variable G if ( Me % allst /= 0 ) then er = ErrorInstance ( code = 1 , & message = \"Deallocation error\" , & trace = [ Me % name // & \"%resuspendSediment1%G\" ] & ) ! create warning if error thrown call r % addError ( er ) ! add to Result end if end function !> compute deposition to bed sediment, including burial and downward shifting of fine sediment and water function depositSediment1 ( Me , M_dep , f_comp_dep , V_w_tot ) result ( r ) class ( BedSediment1 ) :: Me !! self-reference real ( dp ), intent ( in ), allocatable :: M_dep (:) !! Depositing sediment mass by size class real ( dp ), intent ( in ), allocatable :: f_comp_dep (:,:) !! Depositing sediment fractional composition by size class !! Index 1 = size class, Index 2 = compositional fraction real ( dp ), intent ( out ) :: V_w_tot !! water requirement from the water column [m3 m-2] type ( Result ) :: r !! returned Result object type ( ErrorInstance ) :: er ! LOCAL ErrorInstance object for error handling type ( FineSediment1 ), allocatable :: DS (:) ! LOCAL FineSediment objects holding deposited material type ( FineSediment1 ), allocatable :: B ! LOCAL object to receive sediment being buried type ( FineSediment1 ), allocatable :: T ! LOCAL object to receive sediment being buried type ( FineSediment1 ), allocatable :: U ! LOCAL object to receive sediment that has been buried integer :: S ! LOCAL loop counter for size classes integer :: L ! LOCAL counter for layers integer :: A ! LOCAL second counter for layers real ( dp ) :: A_f_sed ! LOCAL available fine sediment capacity for size class real ( dp ) :: tempV ! LOCAL volume variable real ( dp ) :: V_f_b ! LOCAL available fine sediment capacity in the receiving layer [m3 m-2] real ( dp ) :: V_w_b ! LOCAL available water capacity in the receiving layer [m3 m-2] character ( len = 256 ) :: tr ! LOCAL name of this procedure, for trace ! ! Function purpose ! ------------------------------------------------------------------------------- ! Deposit specified masses of fine sediment in each size class, and their ! associated water. Function buries sediment and shifts remaining sediment down ! to make space for deposition, if required ! ! Function inputs ! ------------------------------------------------------------------------------- ! Function takes as inputs: ! D (FineSedimentElement)  FineSediment object representing the depositing fine !                          sediment and water ! ! Function outputs/outcomes ! ------------------------------------------------------------------------------- ! ! Notes ! ------------------------------------------------------------------------------- ! 1.    Currently does not account fully for sediment burial, in the sense that !       it does not tally mass, volume and composition of buried material. This !       will need to be added before burial losses of a chemical vector can be !       computed. !       ACTION: add code to mix FineSediments together and return a single !       FineSediment object. This code can be used to tally up the sediment that !       is lost through burial. ! 2.    The FineSediment objects in D should not contain any water, but if they !       do it is not a problem as it will be overwritten. ! ------------------------------------------------------------------------------- tr = Me % name // \"%DepositSediment1\" ! object and procedure binding name as trace if ( size ( M_dep ) /= Me % nSizeClasses ) & call r % addError ( ErrorInstance ( & code = 1 , & message = \"The number of fine & sediment masses does & not equal the number & of size classes\" & )) ! CRITICAL ERROR if size(D) <> nSizeClasses if ( size ( f_comp_dep , 1 ) /= Me % nSizeClasses ) & ! number of size classes must be consistent call r % addError ( ErrorInstance ( & code = 1 , & message = \"Input number of fractional & compositions does not match & number of size classes\" & )) if ( size ( f_comp_dep , 2 ) /= Me % nFComp ) & ! number of compositional fractions must be consistent call r % addError ( ErrorInstance ( & code = 1 , & message = \"Input number of fractional & compositions does not match & required number\" & )) if ( r % hasCriticalError ()) then ! if a critical error has been thrown call r % addToTrace ( tr ) ! add trace to Result return ! and exit end if allocate ( DS ( 1 : Me % nSizeClasses ), stat = Me % allst ) ! allocate space for FineSediment1 objects if ( Me % allst /= 0 ) then er = ErrorInstance ( code = 1 , & message = \"Allocation error\" , & trace = [ Me % name ] // & \"%depositSediment1%DS\" & ) ! create error call r % addError ( er ) ! add to Result end if allocate ( B , stat = Me % allst ) ! set up B if ( Me % allst /= 0 ) then er = ErrorInstance ( code = 1 , & message = \"Allocation error\" , & trace = [ Me % name ] // & \"%depositSediment1%B\" & ) ! create error call r % addError ( er ) ! add to Result end if allocate ( T , stat = Me % allst ) ! set up T if ( Me % allst /= 0 ) then er = ErrorInstance ( code = 1 , & message = \"Allocation error\" , & trace = [ Me % name ] // & \"%depositSediment1%T\" & ) ! create error call r % addError ( er ) ! add to Result end if allocate ( U , stat = Me % allst ) ! set up U if ( Me % allst /= 0 ) then er = ErrorInstance ( code = 1 , & message = \"Allocation error\" , & trace = [ Me % name ] // & \"%depositSediment1%T\" & ) ! create error call r % addError ( er ) ! add to Result end if if ( r % hasCriticalError ()) return ! exit if allocation error thrown do S = 1 , Me % nSizeClasses ! compose FineSediment1 objects from the inputs call r % addErrors (. errors . & DS ( S )% set ( Mf_in = M_dep ( S ), & f_comp_in = f_comp_dep ( S ,:) & ) & ) ! populate DS with depositing sediment and its fractional composition end do do S = 1 , Me % nSizeClasses call r % addError ( DS ( S )% audit_comp ()) ! audits fractional composition of deposition, returns error instance if ( r % hasCriticalError ()) then ! if fcomp_audit throws a critical error call r % addToTrace ( tr ) ! add trace to all errors return ! and exit end if end do do S = 1 , Me % nSizeClasses ! loop through all size classes if ( int ( DS ( S )% V_f () / Me % Cf_sediment ( S )) > 0 ) then ! check whether the depositing sediment in each size class exceeds the total do L = 1 , Me % nLayers ! capacity in the layer. If so, then remove all fine sediment, water and ! call Me%colBedSedimentLayers(L)%clearAll         ! fractional compositions from all layers for this size class ! TODO: tally up the sediment being buried at this point end do end if end do do S = 1 , Me % nSizeClasses A_f_sed = Me % Af_sediment ( S ) ! local copy of the capacity for this sediment size class in the whole bed if ( DS ( S )% V_f () > A_f_sed ) then ! do we need to bury sediment to create available capacity for deposition? call r % addErrors (. errors . & T % set ( Vf_in = DS ( S )% V_f () - A_f_sed , & Vw_in = 0.0_dp & ) & ) ! set up temporary FineSediment object with volume of fine sediment requiring burial ! to compute the volume of water requiring burial, we must loop through layers ! from the top, computing for each layer the volume of fine sediment that must be !  removed to allow space for deposition, and the volume of water associated with the ! fine sediment L = 1 ! loop through layers, downwards from the top do while ( T % V_f () > 0 ) ! use fine sediment volume in T as a counter associate ( O => Me % colBedSedimentLayers ( L )% item ) ! association to layer L if ( T % V_f () > O % C_f ( S )) then ! does the depositing fine sediment fit into this layer, ! after accounting for the capacity in layers above? ! no, so increase water removal requirement by the water capacity of this layer ! and decrease the count of remaining depositing fine sediment by the capacity call r % addErrors (. errors . & T % set ( Vf_in = T % V_f () - O % C_f ( S ), & Vw_in = T % V_w () + O % C_w ( S ) & ) & ) else ! yes, ! so increase the water burial requirement by the amount required to maintain the SLR in this layer ! and set the count of fine sediment to zero, to jump out of the loop tempV = T % V_f () / O % volSLR () ! temporary variable call r % addErrors (. errors . & T % set ( Vf_in = 0.0_dp , & Vw_in = T % V_w () + tempV & ) & ) end if end associate L = L + 1 end do ! now to actually bury fine sediment and water call r % addErrors (. errors . & T % set ( Vf_in = DS ( S )% V_f () - A_f_sed & ) & ) ! reset the fine sediment burial requirement, still using temporary object T if ( r % hasCriticalError ()) return ! return if critical error thrown L = Me % nLayers ! start with the bottom layer do while ( L > 0 . and . T % V_f () + T % V_w () > 0 ) ! loop through each layer, while there is still material to bury if ( T % V_f () > 0 ) Then associate ( O => & Me % colBedSedimentLayers ( L )% item ) ! association reference to layer L object call r % addErrors (. errors . & O % removeSediment ( S , B , T ) & ) ! remove sediment from this layer into B. T returns unburied sediment end associate if ( r % hasCriticalError ()) then ! if RemoveSediment throws a critical error call r % addToTrace ( tr ) ! add trace to all errors return ! and exit end if end If L = L - 1 ! move up to next layer end do ! finished burial. temporary object T can be reused do L = Me % nLayers , 2 , - 1 ! downward shift of fine sediment. loop through the layers, starting at the bottom ! and working upwards assoc1 : associate & ( O => Me % colBedSedimentLayers ( L )% item ) ! association to \"receiving\" layer L A = L - 1 ! counter for donating layers - initially the layer above assoc2 : associate & ( P => Me % colBedSedimentLayers ( A )% item ) ! association to \"donating\" layer A call r % addErrors (. errors . & T % set ( Vf_in = O % A_f ( S ), & Vw_in = O % A_w ( S ) & ) & ) ! set FineSediment object T to hold sediment requiring removal do while ( A > 0 . or . & T % IsEmpty () . eqv . . false .) ! loop through \"donating\" layers, moving upwards if ( P % colFineSediment ( S )% item % V_f () > 0 ) & then ! if there is sediment in the \"donating\" layer call r % addErrors (. errors . & P % removeSediment ( S , U , T )) ! remove sediment (T) from the \"donating\" layer ! sediment that cannot be removed is returned in T ! for removal on the next pass through the loop ! sediment that is removed is returned in U if ( r % hasCriticalError ()) then ! if RemoveSediment throws a critical error call r % addToTrace ( tr ) ! add trace to all errors return ! and exit end if call r % addErrors (. errors . & O % addSediment ( S , U )) ! add the sediment in U to the \"receiving\" layer if ( r % hasCriticalError ()) then ! if AddSediment throws a critical error call r % addToTrace ( tr ) ! add trace to all errors return ! and exit end if end if ! TODO: tally up removed sediment from U on each loop A = A - 1 ! shift up to next \"donating\" layer end do end associate assoc2 end associate assoc1 end do end if end do do S = 1 , Me % nSizeClasses ! deposit sediment from the water column L = Me % nLayers ! start with the bottom layer and work upwards do associate ( O => Me % colBedSedimentLayers ( L )% item ) ! size class S in Layer L if ( O % A_f ( S ) > 0 . or . O % A_w ( S ) > 0 ) then ! if there is available capacity in this layer, add deposition here V_w_b = DS ( S )% V_f () / O % volSLR () ! the volume of water needed to maintain SLR in the \"receiving\" layer, r = DS ( S )% set ( Vw_in = V_w_b ) ! if all deposition fits into this layer call r % addErrors (. errors . & O % addSediment ( S , DS ( S ))) ! add the fine sediment in deposition. DS(S) returns volumes ! that could not be added if ( r % hasCriticalError ()) then ! if AddSediment throws a critical error call r % addToTrace ( tr ) ! add trace to all errors return ! and exit end if end if V_w_tot = V_w_tot + V_w_b - DS ( S )% V_w () ! tally up V_w_b to compute water requirement to take from the water column L = L - 1 end associate end do end do deallocate ( DS , stat = Me % allst ) ! deallocate space for FineSediment1 objects if ( Me % allst /= 0 ) then er = ErrorInstance ( code = 1 , & message = \"Deallocation error\" , & trace = [ Me % name ] // & \"%depositSediment1%DS\" & ) ! create warning if error thrown call r % addError ( er ) ! add to Result end if deallocate ( B , stat = Me % allst ) ! deallocate B if ( Me % allst /= 0 ) then er = ErrorInstance ( code = 1 , & message = \"Deallocation error\" , & trace = [ Me % name ] // & \"%depositSediment1%B\" & ) ! create warning if error thrown call r % addError ( er ) ! add to Result end if deallocate ( T , stat = Me % allst ) ! deallocate T if ( Me % allst /= 0 ) then er = ErrorInstance ( code = 1 , & message = \"Deallocation error\" , & trace = [ Me % name ] // & \"%depositSediment1%T\" & ) ! create warning if error thrown call r % addError ( er ) ! add to Result end if deallocate ( U , stat = Me % allst ) ! deallocate U if ( Me % allst /= 0 ) then er = ErrorInstance ( code = 1 , & message = \"Deallocation error\" , & trace = [ Me % name ] // & \"%depositSediment1%U\" & ) ! create warning if error thrown call r % addError ( er ) ! add to Result end if end function !> Calculate resuspension from bed sediment using ! [Bussi](http://www.sciencedirect.com/science/article/pii/S0022169416305625): !  !      m_{\\text{ent}} = a m_{\\text{bed}} \\alpha \\omega \\frac{R_\\text{h}}{R_{\\text{h,max}}} !  !function calculateResuspensionBedSediment1(me, a, m_bed, alpha, omega, R_h, R_hmax) result(r) !    class(BedSediment1) :: me !    real(dp) :: a                                   ! Calibration factor [s2/kg] !    real(dp) :: m_bed                               ! Bed mass per unit area [kg/m2] !    real(dp) :: alpha                               ! Proportion of size class that can be resuspended [-] !    real(dp) :: omega                               ! Stream power per unit area of stream bed [J/s/m2] !    real(dp) :: R_h                                 ! Actual hydraulic radius [m] !    real(dp) :: R_hmax                              ! Maximum hydraulic radius [m] !    real(dp) :: f                                   ! Friction factor [-] !    type(Result0D) :: r !    f = R_h/R_hmax                                  ! Calculate the friction factor !    r = Result( & !        data = a * m_bed * alpha * omega * f &       ! Calculate the resuspension !    ) !end function !> Calculate the stream power (per unit area of stream bed) using Bagnold's ! stream power equation: !  !      \\omega = \\frac{\\rho g Q S}{W} !  ! Reference: [Bagnold, 1966](https://www.uvm.edu/~wbowden/Teaching/Stream_Geomorph_Assess/Resources/Private/Documents/1966_Bagnold_river_sediments.pdf) !function calculateStreamPowerBedSediment1(me, rho_water, g, Q, W, S) result(r) !    class(BedSediment1) :: me !    real(dp) :: rho_water                           ! Density of water [kg/m3] !    real(dp) :: g                                   ! Gravitational acceleration [m/s] !    real(dp) :: Q                                   ! Discharge [m3/s] !    real(dp) :: W                                   ! River width [m] !    real(dp) :: S                                   ! River slope [m/m] !    type(Result0D) :: r !    r = Result( & !        data = rho_water * g * Q * S / W & !    ) !end function end module","tags":"","loc":"sourcefile/classbedsediment1.f08.html"},{"title":"classBedSediment2.f08 – NanoFASE","text":"Modules classBedSediment2 Source Code classBedSediment2.f08 Source Code module classBedSediment2 ! class definition for BedSediment2 use Globals use ResultModule use spcBedSediment ! use BedSediment superclass implicit none ! force declaration of all variables private type , public , extends ( BedSediment ) :: & BedSediment2 ! type declaration for class - extends abstract superclass contains procedure , public :: Resuspension => calculateResuspensionBedSediment2 procedure , public :: StreamPower => calculateStreamPowerBedSediment2 end type contains !> Calculate resuspension from bed sediment using !! [Bussi](http://www.sciencedirect.com/science/article/pii/S0022169416305625): !!  !!      m_{\\text{ent}} = a m_{\\text{bed}} \\alpha \\omega \\frac{R_\\text{h}}{R_{\\text{h,max}}} !!  function calculateResuspensionBedSediment2 ( me , a , m_bed , alpha , omega , R_h , R_hmax ) result ( r ) class ( BedSediment2 ) :: me real ( dp ) :: a !! Calibration factor [s2/kg] real ( dp ) :: m_bed !! Bed mass per unit area [kg/m2] real ( dp ) :: alpha !! Proportion of size class that can be resuspended [-] real ( dp ) :: omega !! Stream power per unit area of stream bed [J/s/m2] real ( dp ) :: R_h !! Actual hydraulic radius [m] real ( dp ) :: R_hmax !! Maximum hydraulic radius [m] real ( dp ) :: f !! Friction factor [-] type ( Result0D ) :: r f = R_h / R_hmax ! Calculate the friction factor r = Result ( & data = a * m_bed * alpha * omega * f & ! Calculate the resuspension ) end function !> Calculate the stream power (per unit area of stream bed) using Bagnold's !! stream power equation: !!  !!      \\omega = \\frac{\\rho g Q S}{W} !!  !! Reference: [Bagnold, 1966](https://www.uvm.edu/~wbowden/Teaching/Stream_Geomorph_Assess/Resources/Private/Documents/1966_Bagnold_river_sediments.pdf) function calculateStreamPowerBedSediment2 ( me , rho_water , g , Q , W , S ) result ( r ) class ( BedSediment2 ) :: me real ( dp ) :: rho_water !! Density of water [kg/m3] real ( dp ) :: g !! Gravitational acceleration [m/s] real ( dp ) :: Q !! Discharge [m3/s] real ( dp ) :: W !! River width [m] real ( dp ) :: S !! River slope [m/m] type ( Result0D ) :: r r = Result ( & data = rho_water * g * Q * S / W & ) end function end module","tags":"","loc":"sourcefile/classbedsediment2.f08.html"},{"title":"spcBedSediment.f08 – NanoFASE","text":"Modules spcBedSediment Source Code spcBedSediment.f08 Source Code !> abstract superclass definition for BedSediment !! defines the properties and methods shared by all BedSediment objects !! objects of this class cannot be instantiated, only objects of its subclasses module spcBedSediment use Globals use ResultModule ! Error handling use spcBedSedimentLayer ! uses the spcBedSedimentLayer superclass and subclasses use classFineSediment1 implicit none ! force declaration of all variables type BedSedimentLayerElement class ( BedSedimentLayer ), allocatable :: item ! Storing polymorphic class(BedSedimentLayer) in derived type so that a collection of end type ! different extended types of BedSedimentLayer can be stored in an array. type , abstract , public :: BedSediment ! type declaration for superclass character ( len = 256 ) :: name ! a name for the object ! define variables for 'has a' objects: BedSedimentLayer class ( BedSedimentLayerElement ), allocatable :: & colBedSedimentLayers (:) ! collection of BedSedimentLayer objects ! properties integer :: nSizeClasses ! number of fine sediment size classes integer :: nLayers ! number of layers (BedSedimentLayer objects) integer :: nfComp ! number of fractional composition terms for sediment integer :: allst ! array allocation status ! any private variable declarations go here contains ! deferred methods: must be defined in all subclasses procedure ( createBedSediment ), public , deferred :: & create ! constructor method procedure ( destroyBedSediment ), public , deferred :: & destroy ! finaliser method procedure ( DepositSediment ), public , deferred :: & deposit ! deposit sediment from water column procedure ( ResuspendSediment ), public , deferred :: & resuspend ! resuspend sediment to water column ! non-deferred methods: defined here. Can be overwritten in subclasses procedure , public :: Af_sediment => Get_Af_sediment ! fine sediment available capacity for size class procedure , public :: Cf_sediment => Get_Cf_sediment ! fine sediment capacity for size class procedure , public :: Aw_sediment => Get_Aw_sediment ! water available capacity for size class procedure , public :: Cw_sediment => Get_Cw_sediment ! water capacity for size class procedure , public :: Mf_sediment => Get_Mf_sediment ! fine sediment mass for size class procedure , public :: Mf_sed_all => Get_Mf_sed_all ! fine sediment mass in all size classes end type abstract interface !> Create a BedSediment object. function createBedSediment ( Me , & n , & ln , & nsc , & nl , & bslType , & C_tot , & f_comp , & pd_comp , & Porosity , & V_f , & M_f ) result ( r ) use Globals import BedSediment , Result class ( BedSediment ) :: Me !! self-reference type ( Result ) :: r !! returned Result object character ( len = 256 ), intent ( in ) :: n !! a name for the object character ( len = 256 ), allocatable :: ln (:) !! names for the layers. Index = layer integer , intent ( in ) :: nsc !! the number of particle size classes integer , intent ( in ) :: nl !! the number of layers integer , intent ( in ) :: bslType !! the type identification number of the BedSedimentLayer(s) real ( dp ), intent ( in ), allocatable :: C_tot (:) !! the total volume of each layer. Index = layer real ( dp ), intent ( in ), allocatable :: f_comp (:,:,:) !! set of fractional compositions !! Index 1 = size class, Index 2 = compositional fraction, Index 3 = layer real ( dp ), intent ( in ), allocatable :: pd_comp (:) !! set of fractional particle densities !! Index 1 = size class real ( dp ), intent ( in ), optional :: Porosity (:) !! layer porosity, if being used to define layer !! Index 1 = layer real ( dp ), intent ( in ), optional , allocatable :: V_f (:,:) !! set of fine sediment volumes, if being used to define layers !! Index 1 = size class, Index 2 = layer real ( dp ), intent ( in ), optional , allocatable :: M_f (:,:) !! set of fine sediment masses, if being used to define layers !! Index 1 = size class, Index 2 = layer end function function destroyBedSediment ( Me ) result ( r ) import BedSediment , Result class ( BedSediment ) :: Me !! self-reference type ( Result ) :: r !! returned Result object end function !> compute deposition to bed sediment, including burial and downward shifting of fine sediment and water function depositSediment ( Me , M_dep , f_comp_dep , V_w_tot ) result ( r ) use Globals import BedSediment , Result , FineSedimentElement ! TODO: replace D with real array to represent SPM *masses* only class ( BedSediment ) :: Me !! self-reference real ( dp ), intent ( in ), allocatable :: M_dep (:) !! Depositing sediment mass by size class real ( dp ), intent ( in ), allocatable :: f_comp_dep (:,:) !! Depositing sediment fractional composition by size class !! Index 1 = size class, Index 2 = compositional fraction real ( dp ), intent ( out ) :: V_w_tot !! water requirement from the water column [m3 m-2] type ( Result ) :: r !! returned Result object                                       ! returned Result object type ( FineSedimentElement ), allocatable :: Q ! LOCAL object to receive sediment being buried type ( FineSedimentElement ), allocatable :: T ! LOCAL object to receive sediment being buried type ( FineSedimentElement ), allocatable :: U ! LOCAL object to receive sediment that has been buried integer :: S ! LOCAL loop counter for size classes integer :: L ! LOCAL counter for layers integer :: A ! LOCAL second counter for layers real ( dp ) :: A_f_sed ! LOCAL available fine sediment capacity for size class real ( dp ) :: deltaV_f_temp ! LOCAL volume of fine sediment requiring burial to create space for deposition real ( dp ) :: deltaV_w_temp ! LOCAL volume of water requiring burial to create space for deposition real ( dp ) :: V_f_b ! LOCAL available fine sediment capacity in the receiving layer [m3 m-2] real ( dp ) :: V_w_b ! LOCAL available water capacity in the receiving layer [m3 m-2] character ( len = 256 ) :: tr ! LOCAL name of this procedure, for trace logical :: criterr ! LOCAL .true. if one or more critical errors tripped ! ! Function purpose ! ------------------------------------------------------------------------------- ! Deposit specified masses of fine sediment in each size class, and their ! associated water. Function buries sediment and shifts remaining sediment down ! to make space for deposition, if required ! ! Function inputs ! ------------------------------------------------------------------------------- ! Function takes as inputs: ! D (FineSedimentElement)  FineSediment object representing the depositing fine !                          sediment and water ! ! Function outputs/outcomes ! ------------------------------------------------------------------------------- ! ! Notes ! ------------------------------------------------------------------------------- ! 1.    Currently does not account fully for sediment burial, in the sense that !       it does not tally mass, volume and composition of buried material. This !       will need to be added before burial losses of a chemical vector can be !       computed. !       ACTION: add code to mix FineSediments together and return a single !       FineSediment object. This code can be used to tally up the sediment that !       is lost through burial. ! 2.    The FineSediment objects in D should not contain any water, but if they !       do it is not a problem as it will be overwritten. ! ------------------------------------------------------------------------------- end function !> compute resuspension from bed sediment function resuspendSediment ( Me , M_resusp , FS ) result ( r ) use Globals import Result , BedSediment , FineSediment1 class ( BedSediment ) :: Me !! self-reference real ( dp ), intent ( in ), allocatable :: M_resusp (:) !! array of sediment masses to be resuspended [kg m-2]. Index = size class[1,...,S] type ( FineSediment1 ), intent ( out ), allocatable :: FS (:,:) !! array returning resuspended fine sediment. Index 1 = size class, Index 2 = layer type ( Result ) :: r !! returned Result object end function !        function ResuspensionBedSediment(me, a, m_bed, alpha, omega, R_h, R_hmax) result(r) !            use Globals !            import BedSediment, Result0D !            class(BedSediment) :: me !            real(dp) :: a                                   ! Calibration factor [s2/kg] !            real(dp) :: m_bed                               ! Bed mass per unit area [kg/m2] !            real(dp) :: alpha                               ! Proportion of size class that can be resuspended [-] !            real(dp) :: omega                               ! Stream power per unit area of stream bed [J/s/m2] !            real(dp) :: R_h                                 ! Actual hydraulic radius [m] !            real(dp) :: R_hmax                              ! Maximum hydraulic radius [m] !            type(Result0D) :: r !        end function ! !        function StreamPowerBedSediment(me, rho_water, g, Q, W, S) result(r) !            use Globals !            import BedSediment, Result0D !            class(BedSediment) :: me !            real(dp) :: rho_water                           ! Density of water [kg/m3] !            real(dp) :: g                                   ! Gravitational acceleration [m/s] !            real(dp) :: Q                                   ! Discharge [m3/s] !            real(dp) :: W                                   ! River width [m] !            real(dp) :: S                                   ! River slope [m/m] !            type(Result0D) :: r !        end function end interface contains !> return available capacity for fine sediment of a specified size class pure function Get_Af_sediment ( Me , S ) result ( Af_sediment ) class ( BedSediment ), intent ( in ) :: Me !! the BedSediment instance integer , intent ( in ) :: S !! size class real ( dp ) :: Af_sediment !! return value integer :: L ! LOCAL loop counter ! CRITICAL ERROR if S < 0 ! CRITICAL ERROR if S > nSizeClasses Af_sediment = 0 do L = 1 , Me % nLayers ! loop through each layer Af_sediment = Af_sediment + & Me % colBedSedimentLayers ( L )% item % A_f ( S ) ! sum capacities for all layers end do end function !> return capacity for fine sediment of a specified size class pure function Get_Cf_sediment ( Me , S ) result ( Cf_sediment ) class ( BedSediment ), intent ( in ) :: Me !! the BedSediment instance integer , intent ( in ) :: S !! size class real ( dp ) :: Cf_sediment !! return value integer :: L ! LOCAL loop counter ! CRITICAL ERROR if S < 0 ! CRITICAL ERROR if S > nSizeClasses Cf_sediment = 0 do L = 1 , Me % nLayers ! loop through each layer Cf_sediment = Cf_sediment + & Me % colBedSedimentLayers ( L )% item % C_f ( S ) ! sum capacities for all layers end do end function !> return available capacity for water associated with a specified size class pure function Get_Aw_sediment ( Me , S ) result ( Aw_sediment ) class ( BedSediment ), intent ( in ) :: Me !! the BedSediment instance integer , intent ( in ) :: S !! size class real ( dp ) :: Aw_sediment !! return value integer :: L ! LOCAL loop counter ! CRITICAL ERROR if S < 0 ! CRITICAL ERROR if S > nSizeClasses Aw_sediment = 0 do L = 1 , Me % nLayers ! loop through each layer Aw_sediment = Aw_sediment + & Me % colBedSedimentLayers ( L )% item % A_w ( S ) ! sum capacities for all layers end do end function !> return capacity for water associated with a specified size class pure function Get_Cw_sediment ( Me , S ) result ( Cw_sediment ) class ( BedSediment ), intent ( in ) :: Me !! the BedSediment instance integer , intent ( in ) :: S !! size class real ( dp ) :: Cw_sediment !! return value integer :: L ! LOCAL loop counter ! CRITICAL ERROR if S < 0 ! CRITICAL ERROR if S > nSizeClasses Cw_sediment = 0 do L = 1 , Me % nLayers ! loop through each layer Cw_sediment = Cw_sediment + & Me % colBedSedimentLayers ( L )% item % C_w ( S ) ! sum capacities for all layers end do end function !> return fine sediment mass in a specified size class pure function Get_Mf_sediment ( Me , S ) result ( Mf_sediment ) class ( BedSediment ), intent ( in ) :: Me !! the BedSediment instance integer , intent ( in ) :: S !! size class real ( dp ) :: Mf_sediment !! return value integer :: L ! LOCAL loop counter ! CRITICAL ERROR if S < 0 ! CRITICAL ERROR if S > nSizeClasses Mf_sediment = 0 do L = 1 , Me % nLayers ! loop through each layer Mf_sediment = Mf_sediment + & Me % colBedSedimentLayers ( L )% item % colFineSediment ( S )% item % M_f () ! sum masses for all layers. Not very elegant end do end function !> return fine sediment mass for all size classes pure function Get_Mf_sed_all ( Me , S ) result ( Mf_sed_all ) class ( BedSediment ), intent ( in ) :: Me !! the BedSediment instance integer , intent ( in ) :: S !! size class real ( dp ) :: Mf_sed_all !! return value integer :: L ! LOCAL loop counter ! CRITICAL ERROR if S < 0 ! CRITICAL ERROR if S > nSizeClasses Mf_sed_all = 0 do L = 1 , Me % nLayers ! loop through each layer Mf_sed_all = Mf_sed_all + & Me % colBedSedimentLayers ( L )% item % M_f_layer () ! sum masses for all layers end do end function !    subroutine createBedSediment(Me, & !                      lname, & !                      ltBSL)                                        ! constructor method !                                                                    ! dummy variables !        class(BedSediment) :: Me                                    ! reference to this object, using the type of the abstract superclass !        character(len=256) :: lname                                   ! the name of this object !                                                                    ! SH: Changed to assumed-length character string create() procedure !                                                                    ! will accept character strings less than 256. !        type(integer) :: ltBSL(:)                                   ! array of integers representing BedSedimentLayer types to create !                                                                    ! internal variables !        type(integer) :: x                                          ! loop counter !        type(objBedSedimentLayer1), allocatable :: BSL1             ! object of type BedSedimentLayer1 !        ! type(objBedSedimentLayer2), allocatable :: BSL2             ! object of type BedSedimentLayer2 !        Me%name = lname                                             ! the name of this object !        Me%nLayers = size(ltBSL)                                    ! number of BedSedimentLayer objects to create ! The next block of code creates the required number of BedSedimentLayer objects ! and stores them in the colBedSedimentLayer collection ! the collections are allocatable arrays of user-defined types BedSedimentLayerElement ! SH: the best method to do this is to store the class(BedSedimentLayer) in a derived type (BedSedimentLayerElement) and ! then have an array of that derived type as the colBedSedimentLayer property. That way, ! Fortran won't complain that elements of the array are of different types, which ! is why allocating individual array elements of the class(BedSedimentLayer) array won't work. ! implemented here and seems to be working okay. ! Reference: ! https://stackoverflow.com/questions/31106539/polymorphism-in-an-array-of-elements. !        if (Me%nLayers > 0) then !            allocate(Me%colBedSedimentLayer(Me%nLayers), & !                stat=Me%allst)                                      ! Set colBedSedimentLayer size to number of layers !            do x = 1, Me%nLayers !                select case (ltBSL(x)) !                    case (1) !                        allocate (BSL1, stat=Me%allst)              ! objBedSedimentLayer1 type - create the object !                                                                    ! SH: create() filled with arbitrary values for the moment !                        call BSL1%create('name',1.0,1.0,1.0,[1],[1])! call the object constructor !                        call move_alloc(BSL1, & !                           Me%colBedSedimentLayer(x)%item)         ! move the object to the xth element of the BedSedimentLayer collection ! case (2) !     allocate (BSL2, stat=Me%allst)              ! objBedSedimentLayer2 type - create the object !     call BSL2%create('name',1.0,1.0,1.0,[1],[1])! call the object constructor !     call move_alloc(BSL2, & !         Me%colBedSedimentLayer(x)%item)         ! move the object to the xth element of colBiota !                    case default !                        call ERROR_HANDLER%trigger(997)             ! error - ltBSL(y) points to an invalid number. Need to abort and report. !                end select !            end do !        else !            call ERROR_HANDLER%trigger(996)                         ! If no BSLs have been provided (can't be negative as nLayer deduced from array size) !        end if !    end subroutine !    subroutine destroyBedSediment(Me)                               ! finaliser method !        class(BedSediment)  :: Me                                   ! reference to this object, using the type of the abstract superclass !        integer :: x                                                ! loop counter !        do x = 1, Me%nLayers !            call Me%colBedSedimentLayer(x)%item%destroy()           ! do any cleanup required in BedSedimentLayer objects !        end do !    end subroutine !    integer function getNLayers(Me) result(nLayers)                 ! property function, returns number of BedSedimentLayer objects !        class(BedSediment) :: Me !       nLayers = size(Me%colBedSedimentLayer) !    end function !   real function Depth(Me)                                         ! property function, returns total depth of sediment !        class(BedSediment) :: Me !        type(integer) :: x                                          ! loop counter !        Depth = 0                                                   ! initialise the function return value !        do x = 1, Me%nLayers                                        ! loop through all the layers !            Depth = Depth + Me%colBedSedimentLayer(x)%item%Depth    ! adding up the depth of each layer !        end do                                                      ! to return the total sediment depth !    end function end module","tags":"","loc":"sourcefile/spcbedsediment.f08.html"},{"title":"Constants – NanoFASE ","text":"type, public :: Constants Variables g n_river T inputFile d_spm d_np nSizeClassesSpm nSizeClassesNP defaultDistributionSediment defaultDistributionNP maxRiverReaches gridCellSize timeStep nTimeSteps Type-Bound Procedures nu_w rho_w Components Type Visibility Attributes Name Initial real(kind=dp), public :: g = 9.80665_dp Gravitational acceleration [m/s&#94;2] real(kind=dp), public :: n_river = 0.035_dp Manning's roughness coefficient, for natural streams and major rivers. Reference . real(kind=dp), public :: T = 15.0_dp Temperature [C] character(len=12), public :: inputFile = 'data/data.nc' Name of the data input file. TODO: Get this from config file. real(kind=dp), public, allocatable :: d_spm (:) Suspended particulate matter size class diameters [m] real(kind=dp), public, allocatable :: d_np (:) Nanoparticle size class diameters [m] integer, public :: nSizeClassesSpm Number of sediment particle size classes integer, public :: nSizeClassesNP Number of nanoparticle size classes integer, public, allocatable :: defaultDistributionSediment (:) Default imposed size distribution for sediment integer, public, allocatable :: defaultDistributionNP (:) Default imposed size distribution for NPs integer, public :: maxRiverReaches = 100 Maximum number of RiverReaches a SubRiver can have.\n TODO: Would be good if this was from config file real(kind=dp), public :: gridCellSize The dimensions of each grid cell [m]. integer, public :: timeStep The timestep to run the model on [s]. integer, public :: nTimeSteps The number of timesteps. Type-Bound Procedures procedure, public :: nu_w public pure function nu_w (me, T, S) Calculate the kinematic viscosity of water  \\nu_w  at given temperature  T \n and optionally salinity  S :\n \n      \\nu_{\\text{w}}(T,S) = \\frac{1}{\\rho_w(T,S)} 2.414\\times 10&#94;{-5} 10&#94;{\\frac{247.8}{(T+273.15)-140.0}}\n  Arguments Type Intent Optional Attributes Name class( Constants ), intent(in) :: me This Constants instance. real(kind=dp), intent(in) :: T Temperature  T  [C]. real(kind=dp), intent(in), optional :: S Salinity  S  [g/kg] Return Value real(kind=dp) Kinematic viscosity of water  \\nu_{\\text{w}}  procedure, public :: rho_w public pure function rho_w (me, T, S) Calculate the density of water at a given temperature  T :\n \n      \\rho_{\\text{w}}(T) = 1000 \\left( 1 - \\frac{T + 288.9414}{508929.2 (T + 68.12963) (T - 3.9863&#94;2)} \\right)\n \n and optionally with a given salinity  S :\n \n      \\rho_{\\text{w,s}}(T,S) = \\rho_w + AS + BS&#94;{3/2} + CS&#94;2\n \n where  A = 0.824493 - 0.0040899T + 0.000076438T&#94;2 -0.00000082467T&#94;3 + 0.0000000053675T&#94;4 ,\n  B = -0.005724 + 0.00010227T - 0.0000016546T&#94;2  and  C = 4.8314 \\times 10&#94;{-4} .\n Reference:\n  - D. R. Maidment, Handbook of Hydrology (2012) Arguments Type Intent Optional Attributes Name class( Constants ), intent(in) :: me This Constants instance. real(kind=dp), intent(in) :: T Temperature  T  [C]. real(kind=dp), intent(in), optional :: S Salinity  S  [g/kg] Return Value real(kind=dp) Density of water  \\rho_w  [kg/m**3].","tags":"","loc":"type/constants.html"},{"title":"Database – NanoFASE ","text":"type, public :: Database Variables filePath file Type-Bound Procedures init destroy read get Components Type Visibility Attributes Name Initial character(len=256), public :: filePath type(NcDataset), public :: file Type-Bound Procedures procedure, public :: init => initDatabase private function initDatabase (me, filePath) result(r) Initialise the NetCDF database Arguments Type Intent Optional Attributes Name class( Database ) :: me This Database object character(len=*) :: filePath Path to the data file Return Value type(Result) The Result object procedure, public :: destroy => destroyDatabase private function destroyDatabase (me) result(r) Destroy the NetCDF database Arguments Type Intent Optional Attributes Name class( Database ) :: me Return Value type(Result) procedure, public :: read => readDatabase private function readDatabase (me, ref) result(r) Read data from the NetCDF database Arguments Type Intent Optional Attributes Name class( Database ) :: me character(len=*), allocatable :: ref (:) Return Value type(Result) procedure, public :: get => getVariable private function getVariable (me, location, variable) result(r) Arguments Type Intent Optional Attributes Name class( Database ) :: me character(len=256), allocatable :: location (:) class(*) :: variable Return Value type(Result)","tags":"","loc":"type/database.html"},{"title":"SoilProfile1 – NanoFASE ","text":"type, public, extends(SoilProfile) :: SoilProfile1 Type-Bound Procedures create destroy update erode imposeSizeDistribution parseInputData Type-Bound Procedures procedure, public :: create => createSoilProfile1 public function createSoilProfile1 (me, x, y, p, slope, n_river, area) result(r) Creating the SoilProfile parses input data and fills\n the corresponding object properties, as well as setting\n up the contained SoilLayers. Arguments Type Intent Optional Attributes Name class( SoilProfile1 ) :: me The SoilProfile instance. integer :: x Containing GridCell x position integer :: y Containing GridCell y position integer :: p SoilProfile reference (redundant for now as only one SoilProfile per GridCell) real(kind=dp) :: slope Slope of the containing GridCell [m/m] real(kind=dp) :: n_river Manning's roughness coefficient for the GridCell's rivers [-] real(kind=dp) :: area The surface area of the SoilProfile [m3] Return Value type(Result) The Result object procedure, public :: destroy => destroySoilProfile1 public function destroySoilProfile1 (me) result(r) Arguments Type Intent Optional Attributes Name class( SoilProfile1 ) :: me This SoilProfile instance Return Value type(Result) Result object to return procedure, public :: update => updateSoilProfile1 public function updateSoilProfile1 (me, t, Qrunoff) result(r) Arguments Type Intent Optional Attributes Name class( SoilProfile1 ) :: me This SoilProfile instance integer :: t The current timestep real(kind=dp) :: Qrunoff Runoff generated on this timestep Return Value type(Result) Result object to return procedure, public :: erode => erodeSoilProfile1 public function erodeSoilProfile1 (me, t) result(r) Calculates soil erosion for this timstep t. Updates this GridCell's\n state variable erodedSediment accordingly. Arguments Type Intent Optional Attributes Name class( SoilProfile1 ) :: me This SoilProfile instance integer :: t The timestep we're on Return Value type(Result) The Result object procedure, public :: imposeSizeDistribution => imposeSizeDistributionSoilProfile1 public function imposeSizeDistributionSoilProfile1 (me, mass) result(distribution) Impose a size class distribution on a total mass to split it up\n into separate size classes. If a size distribution has been specified\n for this SoilProfile, use that, otherwise, use the global size distribution. Arguments Type Intent Optional Attributes Name class( SoilProfile1 ) :: me This SoilProfile instance real(kind=dp) :: mass The mass to split into size classes Return Value real(kind=dp)\n  (C%nSizeClassesSpm) The resulting distribution procedure, public :: parseInputData => parseInputDataSoilProfile1 public function parseInputDataSoilProfile1 (me) result(r) Get the data from the input file and set object properties\n accordingly, including allocation of arrays that depend on\n input data\n Slope of the channel [m/m]. Defaults to GridCell slope.\n Hillslope length of the channel [km] Arguments Type Intent Optional Attributes Name class( SoilProfile1 ) :: me This SoilProfile instance Return Value type(Result) Result object to return","tags":"","loc":"type/soilprofile1.html"},{"title":"SoilLayer – NanoFASE ","text":"type, public, abstract :: SoilLayer Variables ref GridX GridY depth bdens pH SOM Type-Bound Procedures create destroy update Components Type Visibility Attributes Name Initial character(len=256), public :: ref type(integer), public :: GridX type(integer), public :: GridY type(realdp), public :: depth type(realdp), public :: bdens type(realdp), public :: pH type(realdp), public :: SOM Type-Bound Procedures procedure( createSoilLayer ), public, deferred :: create function createSoilLayer (me) result(r) Prototype Arguments Type Intent Optional Attributes Name class( SoilLayer ) :: me Return Value type(Result) procedure( destroySoilLayer ), public, deferred :: destroy function destroySoilLayer (me) result(r) Prototype Arguments Type Intent Optional Attributes Name class( SoilLayer ) :: me Return Value type(Result) procedure( updateSoilLayer ), public, deferred :: update function updateSoilLayer (me) result(r) Prototype Arguments Type Intent Optional Attributes Name class( SoilLayer ) :: me Return Value type(Result)","tags":"","loc":"type/soillayer.html"},{"title":"SoilLayerElement – NanoFASE ","text":"type, public :: SoilLayerElement Variables item Components Type Visibility Attributes Name Initial class( SoilLayer ), public, allocatable :: item","tags":"","loc":"type/soillayerelement.html"},{"title":"SoilProfile – NanoFASE ","text":"type, public, abstract :: SoilProfile Variables ref x y p ncGroup colSoilLayers nSoilLayers Qrunoff slope n_river area usle_C usle_K usle_LS usle_P usle_CFRG usle_alpha_half usle_area_hru usle_area_sb usle_L_sb usle_n_sb usle_slp_sb usle_slp_ch usle_L_ch rusle2015_erodedSediment erodedSediment distributionSediment Type-Bound Procedures create destroy update erode imposeSizeDistribution parseInputData Components Type Visibility Attributes Name Initial character(len=256), public :: ref integer, public :: x integer, public :: y integer, public :: p type(NcGroup), public :: ncGroup type(SoilLayerElement), public, allocatable :: colSoilLayers (:) type(integer), public :: nSoilLayers real(kind=dp), public :: Qrunoff real(kind=dp), public :: slope real(kind=dp), public :: n_river real(kind=dp), public :: area real(kind=dp), public, allocatable :: usle_C (:) real(kind=dp), public :: usle_K real(kind=dp), public :: usle_LS real(kind=dp), public :: usle_P real(kind=dp), public :: usle_CFRG real(kind=dp), public, allocatable :: usle_alpha_half (:) real(kind=dp), public :: usle_area_hru real(kind=dp), public :: usle_area_sb real(kind=dp), public :: usle_L_sb real(kind=dp), public :: usle_n_sb real(kind=dp), public :: usle_slp_sb real(kind=dp), public :: usle_slp_ch real(kind=dp), public :: usle_L_ch real(kind=dp), public, allocatable :: rusle2015_erodedSediment (:) real(kind=dp), public, allocatable :: erodedSediment (:) integer, public, allocatable :: distributionSediment (:) Type-Bound Procedures procedure( createSoilProfile ), public, deferred :: create function createSoilProfile (me, x, y, p, slope, n_river, area) result(r) Prototype Creating the SoilProfile parses input data and fills\n the corresponding object properties, as well as setting\n up the contained SoilLayers. Arguments Type Intent Optional Attributes Name class( SoilProfile ) :: me The SoilProfile instance. integer :: x Containing GridCell x position integer :: y Containing GridCell y position integer :: p SoilProfile reference real(kind=dp) :: slope Slope of the containing GridCell [m/m] real(kind=dp) :: n_river Manning's roughness coefficient for the GridCell's rivers [-] real(kind=dp) :: area The area of the SoilProfile's surface Return Value type(Result) Result object to return procedure( destroySoilProfile ), public, deferred :: destroy function destroySoilProfile (me) result(r) Prototype Arguments Type Intent Optional Attributes Name class( SoilProfile ) :: me The SoilProfile instance Return Value type(Result) Result object to return procedure( updateSoilProfile ), public, deferred :: update function updateSoilProfile (me, t, Qrunoff) result(r) Prototype Perform the SoilProfile's simulation for one timestep Arguments Type Intent Optional Attributes Name class( SoilProfile ) :: me This SoilProfile instance integer :: t The current timestep real(kind=dp) :: Qrunoff Runoff generated on this timestep Return Value type(Result) Result object to return procedure( erodeSoilProfile ), public, deferred :: erode function erodeSoilProfile (me, t) result(r) Prototype Erode soil for the current timestep Arguments Type Intent Optional Attributes Name class( SoilProfile ) :: me This SoilProfile instance integer :: t The current timestep Return Value type(Result) Result object to return procedure( imposeSizeDistributionSoilProfile ), public, deferred :: imposeSizeDistribution function imposeSizeDistributionSoilProfile (me, mass) result(distribution) Prototype Impose a size class distribution on a total mass to split it up\n into separate size classes. If a size distribution has been specified\n for this SoilProfile, use that, otherwise, use the global size distribution. Arguments Type Intent Optional Attributes Name class( SoilProfile ) :: me real(kind=dp) :: mass Return Value real(kind=dp)\n  (C%nSizeClassesSpm) procedure( parseInputDataSoilProfile ), public, deferred :: parseInputData function parseInputDataSoilProfile (me) result(r) Prototype Parses the input data for the SoilProfile from the data file Arguments Type Intent Optional Attributes Name class( SoilProfile ) :: me This SoilProfile instance Return Value type(Result) Result object to return","tags":"","loc":"type/soilprofile.html"},{"title":"SoilProfileElement – NanoFASE ","text":"type, public :: SoilProfileElement Variables item Components Type Visibility Attributes Name Initial class( SoilProfile ), public, allocatable :: item","tags":"","loc":"type/soilprofileelement.html"},{"title":"DiffuseSource – NanoFASE ","text":"type, public :: DiffuseSource Type-Bound Procedures destroy Type-Bound Procedures procedure, public :: destroy => destroyDiffuseSource private function destroyDiffuseSource (me) result(r) Arguments Type Intent Optional Attributes Name class( DiffuseSource ) :: me Return Value type(Result)","tags":"","loc":"type/diffusesource.html"},{"title":"PointSource – NanoFASE ","text":"type, public :: PointSource Type-Bound Procedures destroy Type-Bound Procedures procedure, public :: destroy => destroyPointSource private function destroyPointSource (me) result(r) Arguments Type Intent Optional Attributes Name class( PointSource ) :: me Return Value type(Result)","tags":"","loc":"type/pointsource.html"},{"title":"Environment – NanoFASE ","text":"type, public, abstract :: Environment Variables gridSize colGridCells Type-Bound Procedures create destroy update Components Type Visibility Attributes Name Initial integer, public, allocatable :: gridSize (:) type(GridCellElement), public, allocatable :: colGridCells (:,:) Type-Bound Procedures procedure( createEnvironment ), public, deferred :: create function createEnvironment (me) result(r) Prototype Interface to create an Environment object Arguments Type Intent Optional Attributes Name class( Environment ), target :: me Return Value type(Result) procedure( destroyEnvironment ), public, deferred :: destroy function destroyEnvironment (me) result(r) Prototype Interface to destroy an Environment object Arguments Type Intent Optional Attributes Name class( Environment ) :: me Return Value type(Result) procedure( updateEnvironment ), public, deferred :: update function updateEnvironment (me, t) result(r) Prototype Interface to perform simulations in Environment Arguments Type Intent Optional Attributes Name class( Environment ) :: me integer :: t Return Value type(Result)","tags":"","loc":"type/environment.html"},{"title":"Environment1 – NanoFASE ","text":"type, public, extends(Environment) :: Environment1 Type-Bound Procedures create destroy update Type-Bound Procedures procedure, public :: create => createEnvironment1 private function createEnvironment1 (me) result(r) Create the environment, which sets up the grid and river structure.\n The Environment instance must be a target so that SubRiver inflows\n can point to another SubRiver object ( see here ) Arguments Type Intent Optional Attributes Name class( Environment1 ), target :: me This Environment instace. Must be target so SubRivers can be pointed at. Return Value type(Result) Result object to return procedure, public :: destroy => destroyEnvironment1 private function destroyEnvironment1 (me) result(r) Destroy the Environment instance Arguments Type Intent Optional Attributes Name class( Environment1 ) :: me Return Value type(Result) procedure, public :: update => updateEnvironment1 private function updateEnvironment1 (me, t) result(r) Perform simulations for the Environment Arguments Type Intent Optional Attributes Name class( Environment1 ) :: me This Environment instance integer :: t Current time step Return Value type(Result)","tags":"","loc":"type/environment1.html"},{"title":"BedSedimentLayer1 – NanoFASE ","text":"type, public, extends(BedSedimentLayer) :: BedSedimentLayer1 Type-Bound Procedures create destroy addSediment removeSediment Type-Bound Procedures procedure, public :: create => createBedSedimentLayer1 public function createBedSedimentLayer1 (Me, n, nsc, FSType, C_tot, f_comp, pd_comp, Porosity, V_f, M_f) result(r) initialise a BedSedimentLayer object:\n  - sets number of particle size classes\n  - reads in fixed layer volume\n  - reads in volumes of fine sediment and water in each size class\n  - sets volume of coarse material Arguments Type Intent Optional Attributes Name class( BedSedimentLayer1 ) :: Me the BedSedimentLayer instance character(len=256) :: n a name for the object integer, intent(in) :: nsc the number of particle size classes integer, intent(in) :: FSType the type identification number of the FineSediment(s) real(kind=dp), intent(in) :: C_tot the total volume of the layer real(kind=dp), intent(in) :: f_comp (:,:) set of fractional compositions. Index 1 = size class, Index 2 = compositional fraction real(kind=dp), intent(in), allocatable :: pd_comp (:) set of fractional particle densities real(kind=dp), intent(in), optional :: Porosity layer porosity, if being used to define layer real(kind=dp), intent(in), optional :: V_f (:) set of fine sediment volumes, if being used to define layer real(kind=dp), intent(in), optional :: M_f (:) set of fine sediment masses, if being used to define layer Return Value type(Result) The Result object. procedure, public :: destroy => destroyBedSedimentLayer1 public function destroyBedSedimentLayer1 (Me) result(r) destroy this object Arguments Type Intent Optional Attributes Name class( BedSedimentLayer1 ) :: Me the BedSedimentLayer instance Return Value type(Result) The Result object procedure, public :: addSediment => addSediment1 public function addSediment1 (Me, S, F) result(r) add sediment and water to this layer Arguments Type Intent Optional Attributes Name class( BedSedimentLayer1 ) :: Me the BedSedimentLayer instance integer, intent(in) :: S the particle size class type(FineSediment1), intent(inout) :: F FineSediment - holds material to be added Return Value type(Result) The Result object procedure, public :: removeSediment => removeSediment1 public function removeSediment1 (Me, S, G) result(r) remove sediment and water from this layer Arguments Type Intent Optional Attributes Name class( BedSedimentLayer1 ) :: Me integer, intent(in) :: S type(FineSediment1), intent(in) :: G Return Value type(Result1D)","tags":"","loc":"type/bedsedimentlayer1.html"},{"title":"FineSedimentElement – NanoFASE ","text":"type, public :: FineSedimentElement Variables item Components Type Visibility Attributes Name Initial class(FineSediment1), public, allocatable :: item Storing polymorphic class(FineSediment) in derived type so that a set of","tags":"","loc":"type/finesedimentelement.html"},{"title":"BedSedimentLayer – NanoFASE ","text":"type, public, abstract :: BedSedimentLayer type declaration for superclass Variables name C_f_l C_w_l colFineSediment C_total V_c pd_comp nSizeClasses nfComp allst Type-Bound Procedures A_f A_w C_f C_w volSLR C_f_layer M_f_layer V_f_layer V_w_layer C_w_layer V_m_layer V_layer create destroy AddSediment RemoveSediment Components Type Visibility Attributes Name Initial character(len=256), public :: name a name for the object real(kind=dp), public, allocatable :: C_f_l (:) capacity for fine sediment [m3 m-2] real(kind=dp), public, allocatable :: C_w_l (:) capacity for water [m3 m-2] class( FineSedimentElement ), public, allocatable :: colFineSediment (:) collection of FineSediment objects real(kind=dp), public :: C_total total capacity [m3 m-2] real(kind=dp), public :: V_c coarse material volume [m3 m-2] real(kind=dp), public, allocatable :: pd_comp (:) particle densities of sediment components [kg m-3] integer, public :: nSizeClasses number of sediment size classes integer, public :: nfComp number of fractional composition terms for sediment integer, public :: allst array allocation status Type-Bound Procedures procedure, public :: A_f => GetAf public pure function GetAf (Me, s) result(A_f) return the available capacity for fine sediment of a specified size class\n compute capacity Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance integer, intent(in) :: s size class for which to retrieve available capacity Return Value real(kind=dp) return value procedure, public :: A_w => GetAw public pure function GetAw (Me, s) result(A_w) return the available capacity for water associated with fine sediment of a specified size class\n compute capacity Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance integer, intent(in) :: s size class for which to retrieve available capacity Return Value real(kind=dp) return value procedure, public :: C_f => GetCf public pure function GetCf (Me, s) result(C_f) return the total capacity for fine sediment of a specified size class\n compute capacity Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance integer, intent(in) :: s size class for which to retrieve available capacity Return Value real(kind=dp) return value procedure, public :: C_w => GetCw public pure function GetCw (Me, s) result(C_w) returns the total capacity for water associated with fine sediment of a specified size class\n compute capacity Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance integer, intent(in) :: s size class for which to retrieve available capacity Return Value real(kind=dp) return value procedure, public :: volSLR => GetvolSLR public pure function GetvolSLR (Me) result(volSLR) return the volumetric solid:liquid ratio for the layer Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value procedure, public :: C_f_layer => GetCflayer public pure function GetCflayer (Me) result(Cf_layer) return the sediment capacity in the layer across all size fractions Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value procedure, public :: M_f_layer => GetMflayer public pure function GetMflayer (Me) result(Mf_layer) return the sediment mass in the layer across all size fractions Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value procedure, public :: V_f_layer => GetVflayer public pure function GetVflayer (Me) result(Vf_layer) return the sediment volume in the layer across all size fractions Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value procedure, public :: V_w_layer => GetVwlayer public pure function GetVwlayer (Me) result(Vw_layer) return the water volume in the layer across all sediment size fractions Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value procedure, public :: C_w_layer => GetCwlayer public pure function GetCwlayer (Me) result(Cw_layer) return the water capacity in the layer across all sediment size fractions Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value procedure, public :: V_m_layer => GetVmlayer public pure function GetVmlayer (Me) result(Vm_layer) return the fine sediment & water volume in the layer across all size fractions Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value procedure, public :: V_layer => GetVlayer public pure function GetVlayer (Me) result(V_layer) return the total volume of the layer Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value procedure( createBedSedimentLayer ), public, deferred :: create function createBedSedimentLayer (Me, n, nsc, FSType, C_tot, f_comp, pd_comp, Porosity, V_f, M_f) result(r) Prototype create a BedSedimentLayer object and its incorporated BedSediment objects:\n  - sets number of particle size classes\n  - reads in fixed layer volume\n  - reads in volumes of fine sediment and water in each size class\n  - sets volume of coarse material Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ) :: Me the BedSedimentLayer instance character(len=256) :: n a name for the object integer, intent(in) :: nsc the number of particle size classes integer, intent(in) :: FSType the type identification number of the FineSediment(s) real(kind=dp), intent(in) :: C_tot the total volume of the layer real(kind=dp), intent(in) :: f_comp (:,:) set of fractional compositions. Index 1 = size class, Index 2 = compositional fraction real(kind=dp), intent(in), allocatable :: pd_comp (:) set of fractional particle densities real(kind=dp), intent(in), optional :: Porosity layer porosity, if being used to define layer real(kind=dp), intent(in), optional :: V_f (:) set of fine sediment volumes, if being used to define layer real(kind=dp), intent(in), optional :: M_f (:) set of fine sediment masses, if being used to define layer Return Value type(Result) The Result object. procedure( destroyBedSedimentLayer ), public, deferred :: destroy function destroyBedSedimentLayer (Me) result(r) Prototype destroy this object Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ) :: Me Return Value type(Result) procedure( addSedimentToLayer ), public, deferred :: AddSediment function addSedimentToLayer (Me, S, F) result(r) Prototype add sediment and water to this layer Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ) :: Me the BedSedimentLayer instance integer, intent(in) :: S the particle size class type(FineSediment1), intent(inout) :: F FineSediment - holds material to be added Return Value type(Result) The Result object procedure( RemoveSedimentFromLayer ), public, deferred :: RemoveSediment function RemoveSedimentFromLayer (Me, S, G) result(r) Prototype remove sediment and water from this layer Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ) :: Me the BedSedimentLayer instance integer, intent(in) :: S the particle size class type(FineSediment1), intent(in) :: G fine sediment to be removed; returns fine sediment that could not be removed Return Value type(Result1D) The Result object. Result%data(1) = fine sediment that was removed; Result%data(2) = fine sediment that could not be removed","tags":"","loc":"type/bedsedimentlayer.html"},{"title":"FineSediment1 – NanoFASE ","text":"type, public :: FineSediment1 Variables name M_f_l V_w_l f_comp pd_comp_l nfComp allst Type-Bound Procedures create set V_f M_f V_w rho_part audit_comp IsEmpty ClearAll mix Components Type Visibility Attributes Name Initial character(len=256), public :: name a name for the object real(kind=dp), private :: M_f_l LOCAL fine sediment mass [kg m-2] real(kind=dp), private :: V_w_l LOCAL volume of water associated with fine sediment [m3 m-2] real(kind=dp), public, allocatable :: f_comp (:) fractional composition [-] real(kind=dp), public, allocatable :: pd_comp_l (:) LOCAL storage of fractional particle densities [kg m-3] integer, public :: nfComp LOCAL number of fractional composition terms integer, public :: allst array allocation status Type-Bound Procedures procedure, public :: create => createFineSediment1 public function createFineSediment1 (Me, n, pd_comp_in) result(r) initialise this object Arguments Type Intent Optional Attributes Name class( FineSediment1 ) :: Me self-reference character(len=256) :: n a name identifier for the object; identifies this object uniquely real(kind=dp), intent(in), allocatable :: pd_comp_in (:) input array of particle densities for compositional fractions Return Value type(Result) Result object procedure, public :: set => setFS1 public function setFS1 (Me, Mf_in, Vf_in, Vw_in, f_comp_in) result(r) set the properties of the object Arguments Type Intent Optional Attributes Name class( FineSediment1 ) :: Me real(kind=dp), intent(in), optional :: Mf_in real(kind=dp), intent(in), optional :: Vf_in real(kind=dp), intent(in), optional :: Vw_in real(kind=dp), intent(in), optional :: f_comp_in (:) Return Value type(Result) procedure, public :: V_f => getFSVol1 public pure function getFSVol1 (Me) result(Vf) return the fine sediment volume [m3 m-2] Arguments Type Intent Optional Attributes Name class( FineSediment1 ), intent(in) :: Me self-reference Return Value real(kind=dp) the return value procedure, public :: M_f => getFSMass1 public pure function getFSMass1 (Me) result(Mf) return the fine sediment mass [kg m-2] Arguments Type Intent Optional Attributes Name class( FineSediment1 ), intent(in) :: Me self-reference Return Value real(kind=dp) the return value procedure, public :: V_w => getWVol1 public pure function getWVol1 (Me) result(Vw) return the water volume [m3 m-2] Arguments Type Intent Optional Attributes Name class( FineSediment1 ), intent(in) :: Me self-reference Return Value real(kind=dp) the return value procedure, public :: rho_part => pdens1 public pure function pdens1 (Me) result(rho_part) compute particle density from components and their densities Arguments Type Intent Optional Attributes Name class( FineSediment1 ), intent(in) :: Me self-reference Return Value real(kind=dp) return value: the particle density [kg m-3] procedure, public :: audit_comp => audit_fcomp1 public pure function audit_fcomp1 (Me) result(er) check that the array of fractional compositions sums to unity Arguments Type Intent Optional Attributes Name class( FineSediment1 ), intent(in) :: Me self-reference Return Value type(ErrorInstance) ErrorInstance object, returns error if t_fcomp /= 1 procedure, public :: IsEmpty => Empty1 public pure function Empty1 (Me) result(t) check whether this object contains any fine sediment or water of the specified size class Arguments Type Intent Optional Attributes Name class( FineSediment1 ), intent(in) :: Me self-reference Return Value logical return value. True= V_f/M_f = V_w = 0. False= V_f/M_f > 0 .or. V_w > 0 procedure, public :: ClearAll => ClearAll1 public subroutine ClearAll1 (Me) clear all properties Arguments Type Intent Optional Attributes Name class( FineSediment1 ) :: Me the FineSediment instance procedure, public :: mix => Mix1 public function Mix1 (Me, FS) result(r) mix two FineSediment objects together Arguments Type Intent Optional Attributes Name class( FineSediment1 ) :: Me self-reference type( FineSediment1 ), intent(in) :: FS FineSediment1 to be mixed with this one Return Value type(Result0D) Result object","tags":"","loc":"type/finesediment1.html"},{"title":"FineSediment – NanoFASE ","text":"type, public, abstract :: FineSediment type declaration for superclass Variables name M_f_l V_w_l f_comp pd_comp_l NFComp Type-Bound Procedures create SetV SetM V_f M_f V_w rho_part audit_comp IsEmpty Clear Components Type Visibility Attributes Name Initial character(len=256), public :: name a name for the object real(kind=dp), public :: M_f_l fine sediment mass [kg m-2] real(kind=dp), public :: V_w_l LOCAL volume of water associated with fine sediment [m3 m-2] real(kind=dp), public, allocatable :: f_comp (:) fractional composition [-] real(kind=dp), public, allocatable :: pd_comp_l (:) LOCAL storage of fractional particle densities [kg m-3] integer, public :: NFComp LOCAL number of fractional composition terms Type-Bound Procedures procedure( createFineSediment ), public, deferred :: create function createFineSediment (Me, n, pd_comp_in) result(r) Prototype initialise this object Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference character(len=256) :: n a name for the object real(kind=dp), intent(in), allocatable :: pd_comp_in (:) input array of particle densities for compositional fractions Return Value type(Result) Result object procedure( setFSVol ), public, deferred :: SetV function setFSVol (Me, Vf_in, Vw_in, f_comp_in) result(r) Prototype set the properties, using fine sediment volume [m3 m-2] Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference real(kind=dp), optional :: Vf_in the fine sediment volume real(kind=dp), optional :: Vw_in the water volume real(kind=dp), optional allocatable :: f_comp_in (:) input fractional composition. Optional; if not present, stored composition is used Return Value type(Result) Result object procedure( setFSMass ), public, deferred :: SetM function setFSMass (Me, Mf_in, Vw_in, f_comp_in) result(r) Prototype set the properties, using fine sediment mass [kg m-2] Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference real(kind=dp), optional :: Mf_in the fine sediment mass real(kind=dp), optional :: Vw_in the water volume real(kind=dp), optional allocatable :: f_comp_in (:) input fractional composition. Optional; if not present, stored composition is used Return Value type(Result) Result object procedure( getFSVol ), public, deferred :: V_f function getFSVol (Me) result(Vf) Prototype return the fine sediment volume [m3 m-2] Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference Return Value real(kind=dp) the return value procedure( getFSMass ), public, deferred :: M_f function getFSMass (Me) result(Mf) Prototype return the fine sediment mass [kg m-2] Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference Return Value real(kind=dp) the return value procedure( getWVol ), public, deferred :: V_w function getWVol (Me) result(Vw) Prototype return the water volume [m3 m-2] Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference Return Value real(kind=dp) the return value procedure( pdens ), public, deferred :: rho_part function pdens (Me) result(rp) Prototype return the particle density [kg m-3] Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference Return Value real(kind=dp) return value: the particle density [kg m-3] procedure( Audit_fcomp ), public, deferred :: audit_comp function Audit_fcomp (Me) Prototype audit the fractional composition Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference Return Value real procedure( Empty ), public, deferred :: IsEmpty function Empty (Me) result(t) Prototype check whether this object contains any fine sediment or water of the specified size class Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference Return Value logical procedure( ClearAll ), public, deferred :: Clear subroutine ClearAll (Me) Prototype clear all fine sediment and water from the object Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference","tags":"","loc":"type/finesediment.html"},{"title":"RiverReach1 – NanoFASE ","text":"type, public, extends(RiverReach) :: RiverReach1 RiverReach1 object is responsible for sediment transport along river and\n sediment deposition to bed sediment. Type-Bound Procedures create destroy update calculateWidth calculateDepth calculateVelocity calculateSettlingVelocity calculateArea calculateVolume Type-Bound Procedures procedure, public :: create => createRiverReach1 private function createRiverReach1 (me, x, y, s, r, l, QrunoffTimeSeries) result(res) Create a RiverReach with x, y, s, r coordinates from the datafile. Arguments Type Intent Optional Attributes Name class( RiverReach1 ) :: me The RiverReach1 instance. integer :: x Containing GridCell x-position index. integer :: y Containing GridCell y-position index. integer :: s Containing SubRiver index. integer :: r RiverReach index. real(kind=dp) :: l Length of the RiverReach (without meandering). real(kind=dp), allocatable :: QrunoffTimeSeries (:) Any GridCell runoff (that has already been split to the correct RiverReach size) Return Value type(Result) The Result object. procedure, public :: destroy => destroyRiverReach1 private function destroyRiverReach1 (me) result(r) Destroy this RiverReach1 Arguments Type Intent Optional Attributes Name class( RiverReach1 ) :: me This RiverReach1 instance Return Value type(Result) The Result object procedure, public :: update => update1 private function update1 (me, Qin, spmIn, t) result(r) Update the RiverReach on this timestep t, based on the inflow Q and SPM provided Arguments Type Intent Optional Attributes Name class( RiverReach1 ) :: me This RiverReach1 instance real(kind=dp) :: Qin Inflow to this reach real(kind=dp) :: spmIn (C%nSizeClassesSpm) Inflow SPM to this reach integer :: t What time step are we on? Return Value type(Result) Result object to return procedure, public :: calculateWidth => calculateWidth1 private pure function calculateWidth1 (me, Q) result(W) Calculate the width  W  of the river based on the discharge:\n \n      W = 1.22Q&#94;{0.557}\n \n References:\n - Dumont et al., 2012 - Allen et al., 1994 Arguments Type Intent Optional Attributes Name class( RiverReach1 ), intent(in) :: me The RiverReach1 instance real(kind=dp), intent(in) :: Q Grid cell discharge  Q  [m**3/s] Return Value real(kind=dp) The calculated width  W  [m] procedure, public :: calculateDepth => calculateDepth1 private pure function calculateDepth1 (me, W, S, Q) result(r) Calculate water depth from Manning's roughness coefficient,\n using Newton's method:\n \n      D_i = D_{i-1} - \\frac{f(D_{i-1})}{f'(D_{i-1})}\n \n where\n \n      f(D) = WD \\left( \\frac{WD}{W+2D} \\right)&#94;{2/3} \\frac{\\sqrt{S}}{n} - Q = 0\n \n and\n \n      f'(D) = \\frac{\\sqrt{S}}{n} \\frac{(DW)&#94;{5/3}(6D + 5W)}{3D(2D + W)&#94;{5/3}}\n  Arguments Type Intent Optional Attributes Name class( RiverReach1 ), intent(in) :: me The RiverReach1 instance. real(kind=dp), intent(in) :: W River width  W  [m]. real(kind=dp), intent(in) :: S River slope  S  [-]. real(kind=dp), intent(in) :: Q Flow rate  Q  [m3/s]. Return Value type(Result0D) The Result object. procedure, public :: calculateVelocity => calculateVelocity1 private pure function calculateVelocity1 (me, D, Q, W) result(v) Calculate the velocity of the river:\n \n      v = \\frac{Q}{WD}\n  Arguments Type Intent Optional Attributes Name class( RiverReach1 ), intent(in) :: me The RiverReach1 instance real(kind=dp), intent(in) :: D River depth  D  [m] real(kind=dp), intent(in) :: Q Flow rate  Q  [m**3/s] real(kind=dp), intent(in) :: W River width  W  [m] Return Value real(kind=dp) The calculated velocity  v  [m/s] procedure, public :: calculateSettlingVelocity => calculateSettlingVelocity1 private function calculateSettlingVelocity1 (me, d, rho_spm, T) result(W_spm) Calculate the settling velocity of sediment particles for an individual\n size class:\n \n      W_{text{spm}} = \\frac{\\nu}{d} d_{*}&#94;3 (38.1 + 0.93 d_{*}&#94;{12/7})&#94;{-7/8}\n \n where\n \n      d_{*} = \\left( \\frac{\\Delta g}{\\nu&#94;2} \\right)&#94;{1/3} d\n \n and\n \n      \\Delta = \\frac{\\rho_{\\text{spm}}}{\\rho} - 1\n \n Reference: Zhiyao et al, 2008 . Arguments Type Intent Optional Attributes Name class( RiverReach1 ), intent(in) :: me The RiverReach1 instance. real(kind=dp), intent(in) :: d Sediment particle diameter [m]. real(kind=dp), intent(in) :: rho_spm Sediment particle density [kg/m**3]. real(kind=dp), intent(in) :: T Temperature [C]. Return Value real(kind=dp) Calculated settling velocity [m/s]. procedure, public :: calculateArea => calculateArea1 private pure function calculateArea1 (me, D, W) result(area) Calculate the area of a cross-section of the RiverReach, assuming\n a rectangular profile:\n \n      \\text{area} = DW\n  Arguments Type Intent Optional Attributes Name class( RiverReach1 ), intent(in) :: me The RiverReach1 instance real(kind=dp), intent(in) :: D River depth [m] real(kind=dp), intent(in) :: W River width [m] Return Value real(kind=dp) The calculated area [m3] procedure, public :: calculateVolume => calculateVolume1 private pure function calculateVolume1 (me, D, W, l, f_m) result(volume) Calculate the volume of a RiverReach, assuming a rectangular profile:\n \n      \\text{volume} = DWlf_m\n  Arguments Type Intent Optional Attributes Name class( RiverReach1 ), intent(in) :: me The RiverReach1 instance real(kind=dp), intent(in) :: D River depth [m] real(kind=dp), intent(in) :: W River width [m] real(kind=dp), intent(in) :: l River length, without meandering [m] real(kind=dp), intent(in) :: f_m Meandering factor [-] Return Value real(kind=dp) The calculated volume [m3]","tags":"","loc":"type/riverreach1.html"},{"title":"RiverReach – NanoFASE ","text":"type, public, abstract :: RiverReach Variables ref S Qin Qout Qrunoff QrunoffTimeSeries spmIn spmOut m_spm m_spmTimeSeries W D v l f_m area volume rho_spm n allst ncGroup Type-Bound Procedures create destroy update calculateDepth calculateWidth calculateVelocity calculateSettlingVelocity calculateVolume calculateArea getVolume getQOut getSpmOut Components Type Visibility Attributes Name Initial character(len=256), public :: ref real(kind=dp), public :: S real(kind=dp), public :: Qin real(kind=dp), public :: Qout real(kind=dp), public :: Qrunoff real(kind=dp), public, allocatable :: QrunoffTimeSeries (:) real(kind=dp), public, allocatable :: spmIn (:) real(kind=dp), public, allocatable :: spmOut (:) real(kind=dp), public, allocatable :: m_spm (:) real(kind=dp), public, allocatable :: m_spmTimeSeries (:,:) real(kind=dp), public :: W real(kind=dp), public :: D real(kind=dp), public :: v real(kind=dp), public :: l real(kind=dp), public :: f_m = 1 real(kind=dp), public :: area real(kind=dp), public :: volume real(kind=dp), public, allocatable :: rho_spm (:) real(kind=dp), public :: n integer, public :: allst type(NcGroup), public :: ncGroup Type-Bound Procedures procedure( createRiverReach ), public, deferred :: create function createRiverReach (me, x, y, s, r, l, QrunoffTimeSeries) result(res) Prototype Arguments Type Intent Optional Attributes Name class( RiverReach ) :: me The RiverReach instance integer :: x GridCell, SubRiver and RiverReach identifiers integer :: y GridCell, SubRiver and RiverReach identifiers integer :: s GridCell, SubRiver and RiverReach identifiers integer :: r GridCell, SubRiver and RiverReach identifiers real(kind=dp) :: l The RiverReach length [m] real(kind=dp), allocatable :: QrunoffTimeSeries (:) Any initial runoff [m3/s] Return Value type(Result) The Result object procedure( destroyRiverReach ), public, deferred :: destroy function destroyRiverReach (Me) result(r) Prototype Arguments Type Intent Optional Attributes Name class( RiverReach ) :: Me The RiverReach instance Return Value type(Result) The Result object to return procedure( update ), public, deferred :: update function update (me, Qin, spmIn, t) result(r) Prototype Arguments Type Intent Optional Attributes Name class( RiverReach ) :: me This RiverReach instance real(kind=dp) :: Qin Inflow to this reach [m3/timestep] real(kind=dp) :: spmIn (C%nSizeClassesSpm) Inflow SPM to this reach [kg/timestep] integer :: t What time step are we on? Return Value type(Result) The Result object procedure( calculateDepth ), public, deferred :: calculateDepth pure function calculateDepth (Me, W, S, Q) result(r) Prototype Arguments Type Intent Optional Attributes Name class( RiverReach ), intent(in) :: Me The RiverReach instance real(kind=dp), intent(in) :: W River width [m] real(kind=dp), intent(in) :: S River slope [-] real(kind=dp), intent(in) :: Q Flow rate [m3/s] Return Value type(Result0D) The result object procedure( calculateWidth ), public, deferred :: calculateWidth function calculateWidth (Me, Q) result(W) Prototype Arguments Type Intent Optional Attributes Name class( RiverReach ), intent(in) :: Me The RiverReach instance real(kind=dp), intent(in) :: Q Flow rate [m3/s] Return Value real(kind=dp) Calculated width [m] procedure( calculateVelocity ), public, deferred :: calculateVelocity pure function calculateVelocity (me, D, Q, W) result(v) Prototype Arguments Type Intent Optional Attributes Name class( RiverReach ), intent(in) :: me The RiverReach instance real(kind=dp), intent(in) :: D River depth [m] real(kind=dp), intent(in) :: Q Flow rate [m3/s] real(kind=dp), intent(in) :: W River width [m] Return Value real(kind=dp) The calculated velocity [m/s] procedure( calculateSettlingVelocity ), public, deferred :: calculateSettlingVelocity function calculateSettlingVelocity (me, d, rho_spm, T) result(W_spm) Prototype Arguments Type Intent Optional Attributes Name class( RiverReach ), intent(in) :: me The RiverReach instance real(kind=dp), intent(in) :: d Sediment particle diameter [m] real(kind=dp), intent(in) :: rho_spm Sediment particle density [kg/m3] real(kind=dp), intent(in) :: T Temperature [C] Return Value real(kind=dp) Calculated settling velocity [m/s] procedure( calculateVolume ), public, deferred :: calculateVolume pure function calculateVolume (me, D, W, l, f_m) result(volume) Prototype Arguments Type Intent Optional Attributes Name class( RiverReach ), intent(in) :: me The RiverReach instance real(kind=dp), intent(in) :: D River depth [m] real(kind=dp), intent(in) :: W River width [m] real(kind=dp), intent(in) :: l River length, without meandering [m] real(kind=dp), intent(in) :: f_m Meandering factor [-] Return Value real(kind=dp) Calculated volume [m3] procedure( calculateArea ), public, deferred :: calculateArea pure function calculateArea (me, D, W) result(area) Prototype Arguments Type Intent Optional Attributes Name class( RiverReach ), intent(in) :: me The RiverReach instance real(kind=dp), intent(in) :: D River depth [m] real(kind=dp), intent(in) :: W River width [m] Return Value real(kind=dp) Calculated area [m2] procedure, public :: getVolume => getVolumeRiverReach public function getVolumeRiverReach (me) result(volume) Return the volume of the RiverReach. Arguments Type Intent Optional Attributes Name class( RiverReach ) :: me Return Value real(kind=dp) procedure, public :: getQOut => getQOutRiverReach public function getQOutRiverReach (me) result(Qout) Return the outflow. Arguments Type Intent Optional Attributes Name class( RiverReach ) :: me Return Value real(kind=dp) procedure, public :: getSpmOut => getSpmOutRiverReach public function getSpmOutRiverReach (me) result(spmOut) Return the SPM discahrge. Arguments Type Intent Optional Attributes Name class( RiverReach ) :: me Return Value real(kind=dp)\n  (size(me%spmOut))","tags":"","loc":"type/riverreach.html"},{"title":"SubRiver1 – NanoFASE ","text":"type, public, extends(SubRiver) :: SubRiver1 Constructor SubRiver1 Type-Bound Procedures create destroy update finaliseUpdate auditrefs Constructor public interface SubRiver1 Interface so that we can create new SubRivers by sr = SubRiver1() public function newSubRiver1 (x, y, s, length, QrunoffTimeSeries) result(me) Return a newly-created SubRiver1 object. This is bound to SubRiver1 interface\n TODO: Do something with result object Arguments Type Intent Optional Attributes Name integer :: x Location of the SubRiver integer :: y Location of the SubRiver integer :: s Location of the SubRiver real(kind=dp) :: length Length of the SubRiver (without meandering) real(kind=dp), allocatable :: QrunoffTimeSeries (:) Any initial runoff from the hydrological model Return Value type( SubRiver1 ) The new SubRiver to return Type-Bound Procedures procedure, public :: create => createSubRiver1 public function createSubRiver1 (me, x, y, s, length, QrunoffTimeSeries) result(r) Arguments Type Intent Optional Attributes Name class( SubRiver1 ) :: me type(integer), intent(in) :: x type(integer), intent(in) :: y type(integer), intent(in) :: s real(kind=dp) :: length real(kind=dp), allocatable :: QrunoffTimeSeries (:) Return Value type(Result) procedure, public :: destroy => destroySubRiver1 public function destroySubRiver1 (me) result(r) Arguments Type Intent Optional Attributes Name class( SubRiver1 ) :: me Return Value type(Result) procedure, public :: update => updateSubRiver1 public function updateSubRiver1 (me, t) result(r) Arguments Type Intent Optional Attributes Name class( SubRiver1 ) :: me integer :: t Return Value type(Result) procedure, public :: finaliseUpdate => finaliseUpdateSubRiver1 public function finaliseUpdateSubRiver1 (me) result(r) Set the outflow and SPM mass from the temporary variables that were set by the\n routing procedure. This step is kept separate from the routing so that the\n wrong outflow isn't used as an inflow for another SubRiver whilst the SubRivers\n are looped through. Arguments Type Intent Optional Attributes Name class( SubRiver1 ) :: me This SubRiver1 instace Return Value type(Result) The Result object procedure, private :: auditrefs public function auditrefs (me) result(r) Arguments Type Intent Optional Attributes Name class( SubRiver1 ) :: me Return Value type(Result)","tags":"","loc":"type/subriver1.html"},{"title":"RiverReachElement – NanoFASE ","text":"type, public :: RiverReachElement Variables item Components Type Visibility Attributes Name Initial class(RiverReach), public, allocatable :: item","tags":"","loc":"type/riverreachelement.html"},{"title":"RoutingRef – NanoFASE ","text":"type, public :: RoutingRef Variables gridX gridY subRiver Components Type Visibility Attributes Name Initial type(integer), public :: gridX type(integer), public :: gridY type(integer), public :: subRiver","tags":"","loc":"type/routingref.html"},{"title":"SubRiverPointer – NanoFASE ","text":"type, public :: SubRiverPointer Variables item Components Type Visibility Attributes Name Initial class( SubRiver ), public, pointer :: item => null()","tags":"","loc":"type/subriverpointer.html"},{"title":"SubRiver – NanoFASE ","text":"type, public, abstract :: SubRiver Variables ref length inflowRefs nInflows nReaches reachTypes Qin Qout QrunoffTimeSeries Qrunoff tmpQout spmIn spmOut tmpSpmOut m_spm tmpm_spm allst colReaches inflows Type-Bound Procedures create destroy update finaliseUpdate getQOut getSpmOut getSpmOutBySizeClass Components Type Visibility Attributes Name Initial character(len=100), public :: ref real(kind=dp), public :: length type( RoutingRef ), public, allocatable :: inflowRefs (:) integer, public :: nInflows integer, public :: nReaches integer, public, allocatable :: reachTypes (:) real(kind=dp), public :: Qin real(kind=dp), public :: Qout real(kind=dp), public, allocatable :: QrunoffTimeSeries (:) real(kind=dp), public :: Qrunoff real(kind=dp), public :: tmpQout real(kind=dp), public, allocatable :: spmIn (:) real(kind=dp), public, allocatable :: spmOut (:) real(kind=dp), public, allocatable :: tmpSpmOut (:) real(kind=dp), public, allocatable :: m_spm (:) real(kind=dp), public, allocatable :: tmpm_spm (:) integer, public :: allst type( RiverReachElement ), public, allocatable :: colReaches (:) type( SubRiverPointer ), public, allocatable :: inflows (:) Type-Bound Procedures procedure( createSubRiver ), public, deferred :: create function createSubRiver (me, x, y, s, length, QrunoffTimeSeries) result(r) Prototype Arguments Type Intent Optional Attributes Name class( SubRiver ) :: me type(integer), intent(in) :: x type(integer), intent(in) :: y type(integer), intent(in) :: s real(kind=dp) :: length real(kind=dp), allocatable :: QrunoffTimeSeries (:) Return Value type(Result) procedure( destroySubRiver ), public, deferred :: destroy function destroySubRiver (me) result(r) Prototype Arguments Type Intent Optional Attributes Name class( SubRiver ) :: me Return Value type(Result) procedure( updateSubRiver ), public, deferred :: update function updateSubRiver (me, t) result(r) Prototype Arguments Type Intent Optional Attributes Name class( SubRiver ) :: me integer :: t Return Value type(Result) procedure( finaliseUpdateSubRiver ), public, deferred :: finaliseUpdate function finaliseUpdateSubRiver (me) result(r) Prototype Arguments Type Intent Optional Attributes Name class( SubRiver ) :: me Return Value type(Result) procedure, public :: getQOut => getQOutSubRiver public function getQOutSubRiver (me) result(QOut) Get the discharge from the SubRiver. Arguments Type Intent Optional Attributes Name class( SubRiver ) :: me This SubRiver instance Return Value real(kind=dp) Discharge out of the SubRiver [m3] procedure, public :: getSpmOut => getSpmOutSubRiver public function getSpmOutSubRiver (me) result(spmOut) Get the SPM discharge from the SubRiver. Arguments Type Intent Optional Attributes Name class( SubRiver ) :: me This SubRiver instance Return Value real(kind=dp)\n  (size(me%spmOut)) SPM discharge for all size classes [kg] procedure, public :: getSpmOutBySizeClass => getSpmOutBySizeClassSubRiver public function getSpmOutBySizeClassSubRiver (me, n) result(spmOut) Get the SPM discharge from the SubRiver, for a given size class. Arguments Type Intent Optional Attributes Name class( SubRiver ) :: me This SubRiver instance integer :: n Size class Return Value real(kind=dp) SPM discharge [kg]","tags":"","loc":"type/subriver.html"},{"title":"SubRiverElement – NanoFASE ","text":"type, public :: SubRiverElement Variables item Components Type Visibility Attributes Name Initial class( SubRiver ), public, allocatable :: item","tags":"","loc":"type/subriverelement.html"},{"title":"GridCell1 – NanoFASE ","text":"type, public, extends(GridCell) :: GridCell1 Constructor GridCell1 Type-Bound Procedures create destroy update finaliseUpdate parseInputData Constructor public interface GridCell1 Interface so that we can create new GridCells by gc = GridCell1() public function newGridCell1 (x, y, isEmpty) result(me) Return a newly-created GridCell1 object.\n TODO: Do something with result object Arguments Type Intent Optional Attributes Name integer :: x Location of the GridCell integer :: y Location of the GridCell logical, optional :: isEmpty Is anything to be simulated in this GridCell? Return Value type( GridCell1 ) The new GridCell to return Type-Bound Procedures procedure, public :: create => createGridCell1 public function createGridCell1 (me, x, y, isEmpty) result(r) Create a GridCell with coordinates x and y. Arguments Type Intent Optional Attributes Name class( GridCell1 ) :: me The GridCell instance. integer :: x Location of the GridCell integer :: y Location of the GridCell logical, optional :: isEmpty Is anything to be simulated in this GridCell? Return Value type(Result) The Result object to return. procedure, public :: destroy => destroyGridCell1 public function destroyGridCell1 (Me) result(r) Arguments Type Intent Optional Attributes Name class( GridCell1 ) :: Me The GridCell instance. Return Value type(Result) The Result object procedure, public :: update => updateGridCell1 public function updateGridCell1 (Me, t) result(r) Perform the simulations required for an individual timestep t. Arguments Type Intent Optional Attributes Name class( GridCell1 ) :: Me integer :: t Return Value type(Result) procedure, public :: finaliseUpdate => finaliseUpdateGridCell1 public function finaliseUpdateGridCell1 (me) result(r) Set the outflow from the temporary outflow variables that were setting by the\n update procedure. This step is kept separate from the routing so that the\n wrong outflow isn't used as an inflow for another SubRiver whilst the SubRivers\n are looped through. Arguments Type Intent Optional Attributes Name class( GridCell1 ) :: me This SubRiver1 instace Return Value type(Result) The Result object procedure, public :: parseInputData => parseInputDataGridCell1 public function parseInputDataGridCell1 (me) result(r) Get the data from the input file and set object properties\n accordingly, including allocation of arrays that depend on\n input data. Arguments Type Intent Optional Attributes Name class( GridCell1 ) :: me This GridCell1 object Return Value type(Result) The result object","tags":"","loc":"type/gridcell1.html"},{"title":"PointSourceElement – NanoFASE ","text":"type, public :: PointSourceElement Variables item Components Type Visibility Attributes Name Initial class(PointSource), public, allocatable :: item","tags":"","loc":"type/pointsourceelement.html"},{"title":"DiffuseSourceElement – NanoFASE ","text":"type, public :: DiffuseSourceElement Variables item Components Type Visibility Attributes Name Initial class(DiffuseSource), public, allocatable :: item","tags":"","loc":"type/diffusesourceelement.html"},{"title":"GridCell – NanoFASE ","text":"type, public, abstract :: GridCell Variables ref ncGroup gridX gridY area colSubRivers colSoilProfiles colPointSources objDiffuseSource nSubRivers nSoilProfiles nPointSources DiffS QrunoffTimeSeries Qrunoff slope n_river erodedSediment isEmpty Type-Bound Procedures create destroy update finaliseUpdate Components Type Visibility Attributes Name Initial character(len=256), public :: ref type(NcGroup), public :: ncGroup type(integer), public :: gridX type(integer), public :: gridY real(kind=dp), public :: area type(SubRiverElement), public, allocatable :: colSubRivers (:) type(SoilProfileElement), public, allocatable :: colSoilProfiles (:) type( PointSourceElement ), public, allocatable :: colPointSources (:) type( DiffuseSourceElement ), public :: objDiffuseSource type(integer), public :: nSubRivers = 0 type(integer), public :: nSoilProfiles = 0 type(integer), public :: nPointSources = 0 type(logical), public :: DiffS real(kind=dp), public, allocatable :: QrunoffTimeSeries (:) real(kind=dp), public :: Qrunoff real(kind=dp), public :: slope real(kind=dp), public :: n_river real(kind=dp), public, allocatable :: erodedSediment (:) logical, public :: isEmpty = .false. Type-Bound Procedures procedure( createGridCell ), public, deferred :: create function createGridCell (me, x, y, isEmpty) result(r) Prototype Arguments Type Intent Optional Attributes Name class( GridCell ) :: me The GridCell instance. integer :: x The (x,y) position of the GridCell. integer :: y The (x,y) position of the GridCell. logical, optional :: isEmpty Is anything to be simulated for this GridCell? Return Value type(Result) procedure( destroyGridCell ), public, deferred :: destroy function destroyGridCell (me) result(r) Prototype Arguments Type Intent Optional Attributes Name class( GridCell ) :: me Return Value type(Result) procedure( updateGridCell ), public, deferred :: update function updateGridCell (me, t) result(r) Prototype Arguments Type Intent Optional Attributes Name class( GridCell ) :: me integer :: t Return Value type(Result) procedure( finaliseUpdateGridCell ), public, deferred :: finaliseUpdate function finaliseUpdateGridCell (me) result(r) Prototype Arguments Type Intent Optional Attributes Name class( GridCell ) :: me Return Value type(Result)","tags":"","loc":"type/gridcell.html"},{"title":"GridCellElement – NanoFASE ","text":"type, public :: GridCellElement Variables item Components Type Visibility Attributes Name Initial class( GridCell ), public, allocatable :: item","tags":"","loc":"type/gridcellelement.html"},{"title":"objBiota1 – NanoFASE ","text":"type, public, extends(Biota) :: objBiota1 type declaration for class - extends interface Type-Bound Procedures create destroy Type-Bound Procedures procedure, public :: create => createObjBiota1 public subroutine createObjBiota1 (Me) constructor method Arguments Type Intent Optional Attributes Name class( objBiota1 ) :: Me This Biota1 instance procedure, public :: destroy => destroyObjBiota1 public subroutine destroyObjBiota1 (Me) finaliser method Arguments Type Intent Optional Attributes Name class( objBiota1 ) :: Me","tags":"","loc":"type/objbiota1.html"},{"title":"objBiota2 – NanoFASE ","text":"type, public, extends(Biota) :: objBiota2 type declaration for class - extends interface Type-Bound Procedures create destroy Type-Bound Procedures procedure, public :: create => createObjBiota2 public subroutine createObjBiota2 (Me) constructor method Arguments Type Intent Optional Attributes Name class( objBiota2 ) :: Me This Biota2 instance procedure, public :: destroy => destroyObjBiota2 public subroutine destroyObjBiota2 (Me) finaliser method Arguments Type Intent Optional Attributes Name class( objBiota2 ) :: Me This Biota2 instance","tags":"","loc":"type/objbiota2.html"},{"title":"Biota – NanoFASE ","text":"type, public, abstract :: Biota type declaration for class Variables name Type-Bound Procedures create destroy Components Type Visibility Attributes Name Initial character(len=256), public :: name Type-Bound Procedures procedure, public :: create => createBiota public subroutine createBiota (me) Arguments Type Intent Optional Attributes Name class( Biota ) :: me procedure, public :: destroy => destroyBiota public subroutine destroyBiota (me) Arguments Type Intent Optional Attributes Name class( Biota ) :: me","tags":"","loc":"type/biota.html"},{"title":"objReactor1 – NanoFASE ","text":"type, public, extends(Reactor) :: objReactor1 Type-Bound Procedures create destroy Type-Bound Procedures procedure, public :: create => newObjReactor1 public subroutine newObjReactor1 (Me) Arguments Type Intent Optional Attributes Name class( objReactor1 ) :: Me procedure, public :: destroy => destroyObjReactor1 public subroutine destroyObjReactor1 (Me) Arguments Type Intent Optional Attributes Name class( objReactor1 ) :: Me","tags":"","loc":"type/objreactor1.html"},{"title":"objReactor2 – NanoFASE ","text":"type, public, extends(Reactor) :: objReactor2 Type-Bound Procedures create destroy Type-Bound Procedures procedure, public :: create => newObjReactor2 public subroutine newObjReactor2 (Me) Arguments Type Intent Optional Attributes Name class( objReactor2 ) :: Me procedure, public :: destroy => destroyObjReactor2 public subroutine destroyObjReactor2 (Me) Arguments Type Intent Optional Attributes Name class( objReactor2 ) :: Me","tags":"","loc":"type/objreactor2.html"},{"title":"Reactor – NanoFASE ","text":"type, public, abstract :: Reactor Variables name Type-Bound Procedures create destroy Components Type Visibility Attributes Name Initial character(len=256), public :: name Type-Bound Procedures procedure, public :: create => createReactor public subroutine createReactor (me) Arguments Type Intent Optional Attributes Name class( Reactor ) :: me procedure, public :: destroy => destroyReactor public subroutine destroyReactor (me) Arguments Type Intent Optional Attributes Name class( Reactor ) :: me","tags":"","loc":"type/reactor.html"},{"title":"BedSediment1 – NanoFASE ","text":"type, public, extends(BedSediment) :: BedSediment1 Type-Bound Procedures create destroy deposit resuspend Type-Bound Procedures procedure, public :: create => createBedSediment1 private function createBedSediment1 (Me, n, ln, nsc, nl, bslType, C_tot, f_comp, pd_comp, Porosity, V_f, M_f) result(r) Create a BedSediment object. Arguments Type Intent Optional Attributes Name class( BedSediment1 ) :: Me self-reference character(len=256), intent(in) :: n a name for the object character(len=256), allocatable :: ln (:) names for the layers. Index = layer integer, intent(in) :: nsc the number of particle size classes integer, intent(in) :: nl the number of layers integer, intent(in) :: bslType the type identification number of the BedSedimentLayer(s) real(kind=dp), intent(in), allocatable :: C_tot (:) the total volume of each layer. Index = layer real(kind=dp), intent(in), allocatable :: f_comp (:,:,:) set of fractional compositions\n Index 1 = size class, Index 2 = compositional fraction, Index 3 = layer real(kind=dp), intent(in), allocatable :: pd_comp (:) set of fractional particle densities\n Index 1 = size class real(kind=dp), intent(in), optional :: Porosity (:) layer porosity, if being used to define layer\n Index 1 = layer real(kind=dp), intent(in), optional allocatable :: V_f (:,:) set of fine sediment volumes, if being used to define layers\n Index 1 = size class, Index 2 = layer real(kind=dp), intent(in), optional allocatable :: M_f (:,:) set of fine sediment masses, if being used to define layers\n Index 1 = size class, Index 2 = layer Return Value type(Result) returned Result object procedure, public :: destroy => destroyBedSediment1 private function destroyBedSediment1 (Me) result(r) deallocate all allocatable variables and call destroy methods for all enclosed objects Arguments Type Intent Optional Attributes Name class( BedSediment1 ) :: Me self-reference Return Value type(Result) returned Result object procedure, public :: deposit => depositSediment1 private function depositSediment1 (Me, M_dep, f_comp_dep, V_w_tot) result(r) compute deposition to bed sediment, including burial and downward shifting of fine sediment and water Arguments Type Intent Optional Attributes Name class( BedSediment1 ) :: Me self-reference real(kind=dp), intent(in), allocatable :: M_dep (:) Depositing sediment mass by size class real(kind=dp), intent(in), allocatable :: f_comp_dep (:,:) Depositing sediment fractional composition by size class\n Index 1 = size class, Index 2 = compositional fraction real(kind=dp), intent(out) :: V_w_tot water requirement from the water column [m3 m-2] Return Value type(Result) returned Result object procedure, public :: resuspend => resuspendSediment1 private function resuspendSediment1 (Me, M_resusp, FS) result(r) compute resuspension from bed sediment Arguments Type Intent Optional Attributes Name class( BedSediment1 ) :: Me real(kind=dp), intent(in), allocatable :: M_resusp (:) type(FineSediment1), intent(out), allocatable :: FS (:,:) Return Value type(Result)","tags":"","loc":"type/bedsediment1.html"},{"title":"BedSediment2 – NanoFASE ","text":"type, public, extends(BedSediment) :: BedSediment2 Type-Bound Procedures Resuspension StreamPower Type-Bound Procedures procedure, public :: Resuspension => calculateResuspensionBedSediment2 private function calculateResuspensionBedSediment2 (me, a, m_bed, alpha, omega, R_h, R_hmax) result(r) Calculate resuspension from bed sediment using Bussi :\n \n      m_{\\text{ent}} = a m_{\\text{bed}} \\alpha \\omega \\frac{R_\\text{h}}{R_{\\text{h,max}}}\n  Arguments Type Intent Optional Attributes Name class( BedSediment2 ) :: me real(kind=dp) :: a Calibration factor [s2/kg] real(kind=dp) :: m_bed Bed mass per unit area [kg/m2] real(kind=dp) :: alpha Proportion of size class that can be resuspended [-] real(kind=dp) :: omega Stream power per unit area of stream bed [J/s/m2] real(kind=dp) :: R_h Actual hydraulic radius [m] real(kind=dp) :: R_hmax Maximum hydraulic radius [m] Return Value type(Result0D) procedure, public :: StreamPower => calculateStreamPowerBedSediment2 private function calculateStreamPowerBedSediment2 (me, rho_water, g, Q, W, S) result(r) Calculate the stream power (per unit area of stream bed) using Bagnold's\n stream power equation:\n \n      \\omega = \\frac{\\rho g Q S}{W}\n \n Reference: Bagnold, 1966 Arguments Type Intent Optional Attributes Name class( BedSediment2 ) :: me real(kind=dp) :: rho_water Density of water [kg/m3] real(kind=dp) :: g Gravitational acceleration [m/s] real(kind=dp) :: Q Discharge [m3/s] real(kind=dp) :: W River width [m] real(kind=dp) :: S River slope [m/m] Return Value type(Result0D)","tags":"","loc":"type/bedsediment2.html"},{"title":"BedSedimentLayerElement – NanoFASE ","text":"type, public :: BedSedimentLayerElement Variables item Components Type Visibility Attributes Name Initial class(BedSedimentLayer), public, allocatable :: item","tags":"","loc":"type/bedsedimentlayerelement.html"},{"title":"BedSediment – NanoFASE ","text":"type, public, abstract :: BedSediment Variables name colBedSedimentLayers nSizeClasses nLayers nfComp allst Type-Bound Procedures create destroy deposit resuspend Af_sediment Cf_sediment Aw_sediment Cw_sediment Mf_sediment Mf_sed_all Components Type Visibility Attributes Name Initial character(len=256), public :: name class( BedSedimentLayerElement ), public, allocatable :: colBedSedimentLayers (:) integer, public :: nSizeClasses integer, public :: nLayers integer, public :: nfComp integer, public :: allst Type-Bound Procedures procedure( createBedSediment ), public, deferred :: create function createBedSediment (Me, n, ln, nsc, nl, bslType, C_tot, f_comp, pd_comp, Porosity, V_f, M_f) result(r) Prototype Create a BedSediment object. Arguments Type Intent Optional Attributes Name class( BedSediment ) :: Me self-reference character(len=256), intent(in) :: n a name for the object character(len=256), allocatable :: ln (:) names for the layers. Index = layer integer, intent(in) :: nsc the number of particle size classes integer, intent(in) :: nl the number of layers integer, intent(in) :: bslType the type identification number of the BedSedimentLayer(s) real(kind=dp), intent(in), allocatable :: C_tot (:) the total volume of each layer. Index = layer real(kind=dp), intent(in), allocatable :: f_comp (:,:,:) set of fractional compositions\n Index 1 = size class, Index 2 = compositional fraction, Index 3 = layer real(kind=dp), intent(in), allocatable :: pd_comp (:) set of fractional particle densities\n Index 1 = size class real(kind=dp), intent(in), optional :: Porosity (:) layer porosity, if being used to define layer\n Index 1 = layer real(kind=dp), intent(in), optional allocatable :: V_f (:,:) set of fine sediment volumes, if being used to define layers\n Index 1 = size class, Index 2 = layer real(kind=dp), intent(in), optional allocatable :: M_f (:,:) set of fine sediment masses, if being used to define layers\n Index 1 = size class, Index 2 = layer Return Value type(Result) returned Result object procedure( destroyBedSediment ), public, deferred :: destroy function destroyBedSediment (Me) result(r) Prototype Arguments Type Intent Optional Attributes Name class( BedSediment ) :: Me self-reference Return Value type(Result) returned Result object procedure( depositSediment ), public, deferred :: deposit function depositSediment (Me, M_dep, f_comp_dep, V_w_tot) result(r) Prototype compute deposition to bed sediment, including burial and downward shifting of fine sediment and water Arguments Type Intent Optional Attributes Name class( BedSediment ) :: Me self-reference real(kind=dp), intent(in), allocatable :: M_dep (:) Depositing sediment mass by size class real(kind=dp), intent(in), allocatable :: f_comp_dep (:,:) Depositing sediment fractional composition by size class\n Index 1 = size class, Index 2 = compositional fraction real(kind=dp), intent(out) :: V_w_tot water requirement from the water column [m3 m-2] Return Value type(Result) returned Result object                                       ! returned Result object procedure( resuspendSediment ), public, deferred :: resuspend function resuspendSediment (Me, M_resusp, FS) result(r) Prototype compute resuspension from bed sediment Arguments Type Intent Optional Attributes Name class( BedSediment ) :: Me self-reference real(kind=dp), intent(in), allocatable :: M_resusp (:) array of sediment masses to be resuspended [kg m-2]. Index = size class[1,...,S] type(FineSediment1), intent(out), allocatable :: FS (:,:) array returning resuspended fine sediment. Index 1 = size class, Index 2 = layer Return Value type(Result) returned Result object procedure, public :: Af_sediment => Get_Af_sediment public pure function Get_Af_sediment (Me, S) result(Af_sediment) return available capacity for fine sediment of a specified size class Arguments Type Intent Optional Attributes Name class( BedSediment ), intent(in) :: Me the BedSediment instance integer, intent(in) :: S size class Return Value real(kind=dp) return value procedure, public :: Cf_sediment => Get_Cf_sediment public pure function Get_Cf_sediment (Me, S) result(Cf_sediment) return capacity for fine sediment of a specified size class Arguments Type Intent Optional Attributes Name class( BedSediment ), intent(in) :: Me the BedSediment instance integer, intent(in) :: S size class Return Value real(kind=dp) return value procedure, public :: Aw_sediment => Get_Aw_sediment public pure function Get_Aw_sediment (Me, S) result(Aw_sediment) return available capacity for water associated with a specified size class Arguments Type Intent Optional Attributes Name class( BedSediment ), intent(in) :: Me the BedSediment instance integer, intent(in) :: S size class Return Value real(kind=dp) return value procedure, public :: Cw_sediment => Get_Cw_sediment public pure function Get_Cw_sediment (Me, S) result(Cw_sediment) return capacity for water associated with a specified size class Arguments Type Intent Optional Attributes Name class( BedSediment ), intent(in) :: Me the BedSediment instance integer, intent(in) :: S size class Return Value real(kind=dp) return value procedure, public :: Mf_sediment => Get_Mf_sediment public pure function Get_Mf_sediment (Me, S) result(Mf_sediment) return fine sediment mass in a specified size class Arguments Type Intent Optional Attributes Name class( BedSediment ), intent(in) :: Me the BedSediment instance integer, intent(in) :: S size class Return Value real(kind=dp) return value procedure, public :: Mf_sed_all => Get_Mf_sed_all public pure function Get_Mf_sed_all (Me, S) result(Mf_sed_all) return fine sediment mass for all size classes Arguments Type Intent Optional Attributes Name class( BedSediment ), intent(in) :: Me the BedSediment instance integer, intent(in) :: S size class Return Value real(kind=dp) return value","tags":"","loc":"type/bedsediment.html"},{"title":"createSoilLayer – NanoFASE","text":"abstract interface public function createSoilLayer(me) result(r) Arguments Type Intent Optional Attributes Name class( SoilLayer ) :: me Return Value type(Result)","tags":"","loc":"interface/createsoillayer.html"},{"title":"destroySoilLayer – NanoFASE","text":"abstract interface public function destroySoilLayer(me) result(r) Arguments Type Intent Optional Attributes Name class( SoilLayer ) :: me Return Value type(Result)","tags":"","loc":"interface/destroysoillayer.html"},{"title":"updateSoilLayer – NanoFASE","text":"abstract interface public function updateSoilLayer(me) result(r) Arguments Type Intent Optional Attributes Name class( SoilLayer ) :: me Return Value type(Result)","tags":"","loc":"interface/updatesoillayer.html"},{"title":"createSoilProfile – NanoFASE","text":"abstract interface public function createSoilProfile(me, x, y, p, slope, n_river, area) result(r) Arguments Type Intent Optional Attributes Name class( SoilProfile ) :: me The SoilProfile instance. integer :: x Containing GridCell x position integer :: y Containing GridCell y position integer :: p SoilProfile reference real(kind=dp) :: slope Slope of the containing GridCell [m/m] real(kind=dp) :: n_river Manning's roughness coefficient for the GridCell's rivers [-] real(kind=dp) :: area The area of the SoilProfile's surface Return Value type(Result) Result object to return Description Creating the SoilProfile parses input data and fills\n the corresponding object properties, as well as setting\n up the contained SoilLayers.","tags":"","loc":"interface/createsoilprofile.html"},{"title":"destroySoilProfile – NanoFASE","text":"abstract interface public function destroySoilProfile(me) result(r) Arguments Type Intent Optional Attributes Name class( SoilProfile ) :: me The SoilProfile instance Return Value type(Result) Result object to return","tags":"","loc":"interface/destroysoilprofile.html"},{"title":"updateSoilProfile – NanoFASE","text":"abstract interface public function updateSoilProfile(me, t, Qrunoff) result(r) Arguments Type Intent Optional Attributes Name class( SoilProfile ) :: me This SoilProfile instance integer :: t The current timestep real(kind=dp) :: Qrunoff Runoff generated on this timestep Return Value type(Result) Result object to return Description Perform the SoilProfile's simulation for one timestep","tags":"","loc":"interface/updatesoilprofile.html"},{"title":"erodeSoilProfile – NanoFASE","text":"abstract interface public function erodeSoilProfile(me, t) result(r) Arguments Type Intent Optional Attributes Name class( SoilProfile ) :: me This SoilProfile instance integer :: t The current timestep Return Value type(Result) Result object to return Description Erode soil for the current timestep","tags":"","loc":"interface/erodesoilprofile.html"},{"title":"imposeSizeDistributionSoilProfile – NanoFASE","text":"abstract interface public function imposeSizeDistributionSoilProfile(me, mass) result(distribution) Arguments Type Intent Optional Attributes Name class( SoilProfile ) :: me real(kind=dp) :: mass Return Value real(kind=dp)\n  (C%nSizeClassesSpm) Description Impose a size class distribution on a total mass to split it up\n into separate size classes. If a size distribution has been specified\n for this SoilProfile, use that, otherwise, use the global size distribution.","tags":"","loc":"interface/imposesizedistributionsoilprofile.html"},{"title":"parseInputDataSoilProfile – NanoFASE","text":"abstract interface public function parseInputDataSoilProfile(me) result(r) Arguments Type Intent Optional Attributes Name class( SoilProfile ) :: me This SoilProfile instance Return Value type(Result) Result object to return Description Parses the input data for the SoilProfile from the data file","tags":"","loc":"interface/parseinputdatasoilprofile.html"},{"title":"createEnvironment – NanoFASE","text":"abstract interface private function createEnvironment(me) result(r) Arguments Type Intent Optional Attributes Name class( Environment ), target :: me Return Value type(Result) Description Interface to create an Environment object","tags":"","loc":"interface/createenvironment.html"},{"title":"destroyEnvironment – NanoFASE","text":"abstract interface private function destroyEnvironment(me) result(r) Arguments Type Intent Optional Attributes Name class( Environment ) :: me Return Value type(Result) Description Interface to destroy an Environment object","tags":"","loc":"interface/destroyenvironment.html"},{"title":"updateEnvironment – NanoFASE","text":"abstract interface private function updateEnvironment(me, t) result(r) Arguments Type Intent Optional Attributes Name class( Environment ) :: me integer :: t Return Value type(Result) Description Interface to perform simulations in Environment","tags":"","loc":"interface/updateenvironment.html"},{"title":"createBedSedimentLayer – NanoFASE","text":"abstract interface public function createBedSedimentLayer(Me, n, nsc, FSType, C_tot, f_comp, pd_comp, Porosity, V_f, M_f) result(r) Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ) :: Me the BedSedimentLayer instance character(len=256) :: n a name for the object integer, intent(in) :: nsc the number of particle size classes integer, intent(in) :: FSType the type identification number of the FineSediment(s) real(kind=dp), intent(in) :: C_tot the total volume of the layer real(kind=dp), intent(in) :: f_comp (:,:) set of fractional compositions. Index 1 = size class, Index 2 = compositional fraction real(kind=dp), intent(in), allocatable :: pd_comp (:) set of fractional particle densities real(kind=dp), intent(in), optional :: Porosity layer porosity, if being used to define layer real(kind=dp), intent(in), optional :: V_f (:) set of fine sediment volumes, if being used to define layer real(kind=dp), intent(in), optional :: M_f (:) set of fine sediment masses, if being used to define layer Return Value type(Result) The Result object. Description create a BedSedimentLayer object and its incorporated BedSediment objects:\n  - sets number of particle size classes\n  - reads in fixed layer volume\n  - reads in volumes of fine sediment and water in each size class\n  - sets volume of coarse material","tags":"","loc":"interface/createbedsedimentlayer.html"},{"title":"destroyBedSedimentLayer – NanoFASE","text":"abstract interface public function destroyBedSedimentLayer(Me) result(r) Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ) :: Me Return Value type(Result) Description destroy this object","tags":"","loc":"interface/destroybedsedimentlayer.html"},{"title":"addSedimentToLayer – NanoFASE","text":"abstract interface public function addSedimentToLayer(Me, S, F) result(r) Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ) :: Me the BedSedimentLayer instance integer, intent(in) :: S the particle size class type(FineSediment1), intent(inout) :: F FineSediment - holds material to be added Return Value type(Result) The Result object Description add sediment and water to this layer","tags":"","loc":"interface/addsedimenttolayer.html"},{"title":"RemoveSedimentFromLayer – NanoFASE","text":"abstract interface public function RemoveSedimentFromLayer(Me, S, G) result(r) Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ) :: Me the BedSedimentLayer instance integer, intent(in) :: S the particle size class type(FineSediment1), intent(in) :: G fine sediment to be removed; returns fine sediment that could not be removed Return Value type(Result1D) The Result object. Result%data(1) = fine sediment that was removed; Result%data(2) = fine sediment that could not be removed Description remove sediment and water from this layer","tags":"","loc":"interface/removesedimentfromlayer.html"},{"title":"ClearAll – NanoFASE","text":"abstract interface public subroutine ClearAll(Me) Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference Description clear all fine sediment and water from the object","tags":"","loc":"interface/clearall.html"},{"title":"createFineSediment – NanoFASE","text":"abstract interface public function createFineSediment(Me, n, pd_comp_in) result(r) Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference character(len=256) :: n a name for the object real(kind=dp), intent(in), allocatable :: pd_comp_in (:) input array of particle densities for compositional fractions Return Value type(Result) Result object Description initialise this object","tags":"","loc":"interface/createfinesediment.html"},{"title":"setFSVol – NanoFASE","text":"abstract interface public function setFSVol(Me, Vf_in, Vw_in, f_comp_in) result(r) Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference real(kind=dp), optional :: Vf_in the fine sediment volume real(kind=dp), optional :: Vw_in the water volume real(kind=dp), optional allocatable :: f_comp_in (:) input fractional composition. Optional; if not present, stored composition is used Return Value type(Result) Result object Description set the properties, using fine sediment volume [m3 m-2]","tags":"","loc":"interface/setfsvol.html"},{"title":"setFSMass – NanoFASE","text":"abstract interface public function setFSMass(Me, Mf_in, Vw_in, f_comp_in) result(r) Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference real(kind=dp), optional :: Mf_in the fine sediment mass real(kind=dp), optional :: Vw_in the water volume real(kind=dp), optional allocatable :: f_comp_in (:) input fractional composition. Optional; if not present, stored composition is used Return Value type(Result) Result object Description set the properties, using fine sediment mass [kg m-2]","tags":"","loc":"interface/setfsmass.html"},{"title":"getFSVol – NanoFASE","text":"abstract interface public function getFSVol(Me) result(Vf) Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference Return Value real(kind=dp) the return value Description return the fine sediment volume [m3 m-2]","tags":"","loc":"interface/getfsvol.html"},{"title":"getFSMass – NanoFASE","text":"abstract interface public function getFSMass(Me) result(Mf) Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference Return Value real(kind=dp) the return value Description return the fine sediment mass [kg m-2]","tags":"","loc":"interface/getfsmass.html"},{"title":"getWVol – NanoFASE","text":"abstract interface public function getWVol(Me) result(Vw) Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference Return Value real(kind=dp) the return value Description return the water volume [m3 m-2]","tags":"","loc":"interface/getwvol.html"},{"title":"pdens – NanoFASE","text":"abstract interface public function pdens(Me) result(rp) Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference Return Value real(kind=dp) return value: the particle density [kg m-3] Description return the particle density [kg m-3]","tags":"","loc":"interface/pdens.html"},{"title":"Audit_fcomp – NanoFASE","text":"abstract interface public function Audit_fcomp(Me) Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference Return Value real Description audit the fractional composition","tags":"","loc":"interface/audit_fcomp.html"},{"title":"Empty – NanoFASE","text":"abstract interface public function Empty(Me) result(t) Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference Return Value logical Description check whether this object contains any fine sediment or water of the specified size class","tags":"","loc":"interface/empty.html"},{"title":"createRiverReach – NanoFASE","text":"abstract interface public function createRiverReach(me, x, y, s, r, l, QrunoffTimeSeries) result(res) Arguments Type Intent Optional Attributes Name class( RiverReach ) :: me The RiverReach instance integer :: x GridCell, SubRiver and RiverReach identifiers integer :: y GridCell, SubRiver and RiverReach identifiers integer :: s GridCell, SubRiver and RiverReach identifiers integer :: r GridCell, SubRiver and RiverReach identifiers real(kind=dp) :: l The RiverReach length [m] real(kind=dp), allocatable :: QrunoffTimeSeries (:) Any initial runoff [m3/s] Return Value type(Result) The Result object","tags":"","loc":"interface/createriverreach.html"},{"title":"destroyRiverReach – NanoFASE","text":"abstract interface public function destroyRiverReach(Me) result(r) Arguments Type Intent Optional Attributes Name class( RiverReach ) :: Me The RiverReach instance Return Value type(Result) The Result object to return","tags":"","loc":"interface/destroyriverreach.html"},{"title":"update – NanoFASE","text":"abstract interface public function update(me, Qin, spmIn, t) result(r) Arguments Type Intent Optional Attributes Name class( RiverReach ) :: me This RiverReach instance real(kind=dp) :: Qin Inflow to this reach [m3/timestep] real(kind=dp) :: spmIn (C%nSizeClassesSpm) Inflow SPM to this reach [kg/timestep] integer :: t What time step are we on? Return Value type(Result) The Result object","tags":"","loc":"interface/update.html"},{"title":"calculateDepth – NanoFASE","text":"abstract interface public pure function calculateDepth(Me, W, S, Q) result(r) Arguments Type Intent Optional Attributes Name class( RiverReach ), intent(in) :: Me The RiverReach instance real(kind=dp), intent(in) :: W River width [m] real(kind=dp), intent(in) :: S River slope [-] real(kind=dp), intent(in) :: Q Flow rate [m3/s] Return Value type(Result0D) The result object","tags":"","loc":"interface/calculatedepth.html"},{"title":"calculateWidth – NanoFASE","text":"abstract interface public function calculateWidth(Me, Q) result(W) Arguments Type Intent Optional Attributes Name class( RiverReach ), intent(in) :: Me The RiverReach instance real(kind=dp), intent(in) :: Q Flow rate [m3/s] Return Value real(kind=dp) Calculated width [m]","tags":"","loc":"interface/calculatewidth.html"},{"title":"calculateVolume – NanoFASE","text":"abstract interface public pure function calculateVolume(me, D, W, l, f_m) result(volume) Arguments Type Intent Optional Attributes Name class( RiverReach ), intent(in) :: me The RiverReach instance real(kind=dp), intent(in) :: D River depth [m] real(kind=dp), intent(in) :: W River width [m] real(kind=dp), intent(in) :: l River length, without meandering [m] real(kind=dp), intent(in) :: f_m Meandering factor [-] Return Value real(kind=dp) Calculated volume [m3]","tags":"","loc":"interface/calculatevolume.html"},{"title":"calculateArea – NanoFASE","text":"abstract interface public pure function calculateArea(me, D, W) result(area) Arguments Type Intent Optional Attributes Name class( RiverReach ), intent(in) :: me The RiverReach instance real(kind=dp), intent(in) :: D River depth [m] real(kind=dp), intent(in) :: W River width [m] Return Value real(kind=dp) Calculated area [m2]","tags":"","loc":"interface/calculatearea.html"},{"title":"calculateVelocity – NanoFASE","text":"abstract interface public pure function calculateVelocity(me, D, Q, W) result(v) Arguments Type Intent Optional Attributes Name class( RiverReach ), intent(in) :: me The RiverReach instance real(kind=dp), intent(in) :: D River depth [m] real(kind=dp), intent(in) :: Q Flow rate [m3/s] real(kind=dp), intent(in) :: W River width [m] Return Value real(kind=dp) The calculated velocity [m/s]","tags":"","loc":"interface/calculatevelocity.html"},{"title":"calculateSettlingVelocity – NanoFASE","text":"abstract interface public function calculateSettlingVelocity(me, d, rho_spm, T) result(W_spm) Arguments Type Intent Optional Attributes Name class( RiverReach ), intent(in) :: me The RiverReach instance real(kind=dp), intent(in) :: d Sediment particle diameter [m] real(kind=dp), intent(in) :: rho_spm Sediment particle density [kg/m3] real(kind=dp), intent(in) :: T Temperature [C] Return Value real(kind=dp) Calculated settling velocity [m/s]","tags":"","loc":"interface/calculatesettlingvelocity.html"},{"title":"createSubRiver – NanoFASE","text":"abstract interface public function createSubRiver(me, x, y, s, length, QrunoffTimeSeries) result(r) Arguments Type Intent Optional Attributes Name class( SubRiver ) :: me type(integer), intent(in) :: x type(integer), intent(in) :: y type(integer), intent(in) :: s real(kind=dp) :: length real(kind=dp), allocatable :: QrunoffTimeSeries (:) Return Value type(Result)","tags":"","loc":"interface/createsubriver.html"},{"title":"destroySubRiver – NanoFASE","text":"abstract interface public function destroySubRiver(me) result(r) Arguments Type Intent Optional Attributes Name class( SubRiver ) :: me Return Value type(Result)","tags":"","loc":"interface/destroysubriver.html"},{"title":"updateSubRiver – NanoFASE","text":"abstract interface public function updateSubRiver(me, t) result(r) Arguments Type Intent Optional Attributes Name class( SubRiver ) :: me integer :: t Return Value type(Result)","tags":"","loc":"interface/updatesubriver.html"},{"title":"finaliseUpdateSubRiver – NanoFASE","text":"abstract interface public function finaliseUpdateSubRiver(me) result(r) Arguments Type Intent Optional Attributes Name class( SubRiver ) :: me Return Value type(Result)","tags":"","loc":"interface/finaliseupdatesubriver.html"},{"title":"createGridCell – NanoFASE","text":"abstract interface public function createGridCell(me, x, y, isEmpty) result(r) Arguments Type Intent Optional Attributes Name class( GridCell ) :: me The GridCell instance. integer :: x The (x,y) position of the GridCell. integer :: y The (x,y) position of the GridCell. logical, optional :: isEmpty Is anything to be simulated for this GridCell? Return Value type(Result)","tags":"","loc":"interface/creategridcell.html"},{"title":"destroyGridCell – NanoFASE","text":"abstract interface public function destroyGridCell(me) result(r) Arguments Type Intent Optional Attributes Name class( GridCell ) :: me Return Value type(Result)","tags":"","loc":"interface/destroygridcell.html"},{"title":"updateGridCell – NanoFASE","text":"abstract interface public function updateGridCell(me, t) result(r) Arguments Type Intent Optional Attributes Name class( GridCell ) :: me integer :: t Return Value type(Result)","tags":"","loc":"interface/updategridcell.html"},{"title":"finaliseUpdateGridCell – NanoFASE","text":"abstract interface public function finaliseUpdateGridCell(me) result(r) Arguments Type Intent Optional Attributes Name class( GridCell ) :: me Return Value type(Result)","tags":"","loc":"interface/finaliseupdategridcell.html"},{"title":"createBedSediment – NanoFASE","text":"abstract interface public function createBedSediment(Me, n, ln, nsc, nl, bslType, C_tot, f_comp, pd_comp, Porosity, V_f, M_f) result(r) Arguments Type Intent Optional Attributes Name class( BedSediment ) :: Me self-reference character(len=256), intent(in) :: n a name for the object character(len=256), allocatable :: ln (:) names for the layers. Index = layer integer, intent(in) :: nsc the number of particle size classes integer, intent(in) :: nl the number of layers integer, intent(in) :: bslType the type identification number of the BedSedimentLayer(s) real(kind=dp), intent(in), allocatable :: C_tot (:) the total volume of each layer. Index = layer real(kind=dp), intent(in), allocatable :: f_comp (:,:,:) set of fractional compositions\n Index 1 = size class, Index 2 = compositional fraction, Index 3 = layer real(kind=dp), intent(in), allocatable :: pd_comp (:) set of fractional particle densities\n Index 1 = size class real(kind=dp), intent(in), optional :: Porosity (:) layer porosity, if being used to define layer\n Index 1 = layer real(kind=dp), intent(in), optional allocatable :: V_f (:,:) set of fine sediment volumes, if being used to define layers\n Index 1 = size class, Index 2 = layer real(kind=dp), intent(in), optional allocatable :: M_f (:,:) set of fine sediment masses, if being used to define layers\n Index 1 = size class, Index 2 = layer Return Value type(Result) returned Result object Description Create a BedSediment object.","tags":"","loc":"interface/createbedsediment.html"},{"title":"destroyBedSediment – NanoFASE","text":"abstract interface public function destroyBedSediment(Me) result(r) Arguments Type Intent Optional Attributes Name class( BedSediment ) :: Me self-reference Return Value type(Result) returned Result object","tags":"","loc":"interface/destroybedsediment.html"},{"title":"depositSediment – NanoFASE","text":"abstract interface public function depositSediment(Me, M_dep, f_comp_dep, V_w_tot) result(r) Arguments Type Intent Optional Attributes Name class( BedSediment ) :: Me self-reference real(kind=dp), intent(in), allocatable :: M_dep (:) Depositing sediment mass by size class real(kind=dp), intent(in), allocatable :: f_comp_dep (:,:) Depositing sediment fractional composition by size class\n Index 1 = size class, Index 2 = compositional fraction real(kind=dp), intent(out) :: V_w_tot water requirement from the water column [m3 m-2] Return Value type(Result) returned Result object                                       ! returned Result object Description compute deposition to bed sediment, including burial and downward shifting of fine sediment and water","tags":"","loc":"interface/depositsediment.html"},{"title":"resuspendSediment – NanoFASE","text":"abstract interface public function resuspendSediment(Me, M_resusp, FS) result(r) Arguments Type Intent Optional Attributes Name class( BedSediment ) :: Me self-reference real(kind=dp), intent(in), allocatable :: M_resusp (:) array of sediment masses to be resuspended [kg m-2]. Index = size class[1,...,S] type(FineSediment1), intent(out), allocatable :: FS (:,:) array returning resuspended fine sediment. Index 1 = size class, Index 2 = layer Return Value type(Result) returned Result object Description compute resuspension from bed sediment","tags":"","loc":"interface/resuspendsediment.html"},{"title":"strFromInteger – NanoFASE","text":"public pure function strFromInteger(i) result(str) Convert an integer to a string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i The integer to convert to a string Return Value character(len=256) The string to return","tags":"","loc":"proc/strfrominteger.html"},{"title":"strFromReal – NanoFASE","text":"public pure function strFromReal(r) result(str) Convert a real to a string Arguments Type Intent Optional Attributes Name real, intent(in) :: r The integer to convert to a string Return Value character(len=256) The string to return","tags":"","loc":"proc/strfromreal.html"},{"title":"strFromDp – NanoFASE","text":"public pure function strFromDp(r) result(str) Convert a double-precision real to a string Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r The integer to convert to a string Return Value character(len=256) The string to return","tags":"","loc":"proc/strfromdp.html"},{"title":"ref2 – NanoFASE","text":"public pure function ref2(prefix, a, b) Generate an object reference from a prefix (e.g., \"GridCell\")\n and two integers Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix integer, intent(in) :: a integer, intent(in) :: b Return Value character(len=256)","tags":"","loc":"proc/ref2.html"},{"title":"ref3 – NanoFASE","text":"public pure function ref3(prefix, a, b, c) Generate an object reference from a prefix (e.g., \"RiverReach\")\n and three integers Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix integer, intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value character(len=256)","tags":"","loc":"proc/ref3.html"},{"title":"ref4 – NanoFASE","text":"public pure function ref4(prefix, a, b, c, d) Generate an object reference from a prefix (e.g., \"BedSediment\")\n and four integers Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix integer, intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c integer, intent(in) :: d Return Value character(len=256)","tags":"","loc":"proc/ref4.html"},{"title":"str – NanoFASE","text":"public interface str Return a string from an integer or real number Module Procedures strFromInteger strFromReal strFromDp Module Procedures public pure function strFromInteger (i) result(str) Convert an integer to a string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i The integer to convert to a string Return Value character(len=256) The string to return public pure function strFromReal (r) result(str) Convert a real to a string Arguments Type Intent Optional Attributes Name real, intent(in) :: r The integer to convert to a string Return Value character(len=256) The string to return public pure function strFromDp (r) result(str) Convert a double-precision real to a string Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r The integer to convert to a string Return Value character(len=256) The string to return","tags":"","loc":"interface/str.html"},{"title":"ref – NanoFASE","text":"public interface ref Module Procedures ref2 ref3 ref4 Module Procedures public pure function ref2 (prefix, a, b) Generate an object reference from a prefix (e.g., \"GridCell\")\n and two integers Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix integer, intent(in) :: a integer, intent(in) :: b Return Value character(len=256) public pure function ref3 (prefix, a, b, c) Generate an object reference from a prefix (e.g., \"RiverReach\")\n and three integers Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix integer, intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value character(len=256) public pure function ref4 (prefix, a, b, c, d) Generate an object reference from a prefix (e.g., \"BedSediment\")\n and four integers Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix integer, intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c integer, intent(in) :: d Return Value character(len=256)","tags":"","loc":"interface/ref.html"},{"title":"rho_w – NanoFASE","text":"public pure function rho_w(me, T, S) Calculate the density of water at a given temperature  T :\n \n      \\rho_{\\text{w}}(T) = 1000 \\left( 1 - \\frac{T + 288.9414}{508929.2 (T + 68.12963) (T - 3.9863&#94;2)} \\right)\n \n and optionally with a given salinity  S :\n \n      \\rho_{\\text{w,s}}(T,S) = \\rho_w + AS + BS&#94;{3/2} + CS&#94;2\n \n where  A = 0.824493 - 0.0040899T + 0.000076438T&#94;2 -0.00000082467T&#94;3 + 0.0000000053675T&#94;4 ,\n  B = -0.005724 + 0.00010227T - 0.0000016546T&#94;2  and  C = 4.8314 \\times 10&#94;{-4} .\n Reference:\n  - D. R. Maidment, Handbook of Hydrology (2012) Arguments Type Intent Optional Attributes Name class( Constants ), intent(in) :: me This Constants instance. real(kind=dp), intent(in) :: T Temperature  T  [C]. real(kind=dp), intent(in), optional :: S Salinity  S  [g/kg] Return Value real(kind=dp) Density of water  \\rho_w  [kg/m**3].","tags":"","loc":"proc/rho_w.html"},{"title":"nu_w – NanoFASE","text":"public pure function nu_w(me, T, S) Calculate the kinematic viscosity of water  \\nu_w  at given temperature  T \n and optionally salinity  S :\n \n      \\nu_{\\text{w}}(T,S) = \\frac{1}{\\rho_w(T,S)} 2.414\\times 10&#94;{-5} 10&#94;{\\frac{247.8}{(T+273.15)-140.0}}\n  Arguments Type Intent Optional Attributes Name class( Constants ), intent(in) :: me This Constants instance. real(kind=dp), intent(in) :: T Temperature  T  [C]. real(kind=dp), intent(in), optional :: S Salinity  S  [g/kg] Return Value real(kind=dp) Kinematic viscosity of water  \\nu_{\\text{w}} ","tags":"","loc":"proc/nu_w.html"},{"title":"GLOBALS_INIT – NanoFASE","text":"public subroutine GLOBALS_INIT() Initialise global variables. For the moment, just error\n handling, but concievably could deal with constants, files\n and other setup tasks in the future. Arguments None","tags":"","loc":"proc/globals_init.html"},{"title":"initDatabase – NanoFASE","text":"private function initDatabase(me, filePath) result(r) Initialise the NetCDF database Arguments Type Intent Optional Attributes Name class( Database ) :: me This Database object character(len=*) :: filePath Path to the data file Return Value type(Result) The Result object","tags":"","loc":"proc/initdatabase.html"},{"title":"destroyDatabase – NanoFASE","text":"private function destroyDatabase(me) result(r) Destroy the NetCDF database Arguments Type Intent Optional Attributes Name class( Database ) :: me Return Value type(Result)","tags":"","loc":"proc/destroydatabase.html"},{"title":"getVariable – NanoFASE","text":"private function getVariable(me, location, variable) result(r) Arguments Type Intent Optional Attributes Name class( Database ) :: me character(len=256), allocatable :: location (:) class(*) :: variable Return Value type(Result)","tags":"","loc":"proc/getvariable.html"},{"title":"readDatabase – NanoFASE","text":"private function readDatabase(me, ref) result(r) Read data from the NetCDF database Arguments Type Intent Optional Attributes Name class( Database ) :: me character(len=*), allocatable :: ref (:) Return Value type(Result)","tags":"","loc":"proc/readdatabase.html"},{"title":"createSoilProfile1 – NanoFASE","text":"public function createSoilProfile1(me, x, y, p, slope, n_river, area) result(r) Creating the SoilProfile parses input data and fills\n the corresponding object properties, as well as setting\n up the contained SoilLayers. Arguments Type Intent Optional Attributes Name class( SoilProfile1 ) :: me The SoilProfile instance. integer :: x Containing GridCell x position integer :: y Containing GridCell y position integer :: p SoilProfile reference (redundant for now as only one SoilProfile per GridCell) real(kind=dp) :: slope Slope of the containing GridCell [m/m] real(kind=dp) :: n_river Manning's roughness coefficient for the GridCell's rivers [-] real(kind=dp) :: area The surface area of the SoilProfile [m3] Return Value type(Result) The Result object","tags":"","loc":"proc/createsoilprofile1.html"},{"title":"destroySoilProfile1 – NanoFASE","text":"public function destroySoilProfile1(me) result(r) Arguments Type Intent Optional Attributes Name class( SoilProfile1 ) :: me This SoilProfile instance Return Value type(Result) Result object to return","tags":"","loc":"proc/destroysoilprofile1.html"},{"title":"updateSoilProfile1 – NanoFASE","text":"public function updateSoilProfile1(me, t, Qrunoff) result(r) Arguments Type Intent Optional Attributes Name class( SoilProfile1 ) :: me This SoilProfile instance integer :: t The current timestep real(kind=dp) :: Qrunoff Runoff generated on this timestep Return Value type(Result) Result object to return","tags":"","loc":"proc/updatesoilprofile1.html"},{"title":"erodeSoilProfile1 – NanoFASE","text":"public function erodeSoilProfile1(me, t) result(r) Calculates soil erosion for this timstep t. Updates this GridCell's\n state variable erodedSediment accordingly. Arguments Type Intent Optional Attributes Name class( SoilProfile1 ) :: me This SoilProfile instance integer :: t The timestep we're on Return Value type(Result) The Result object","tags":"","loc":"proc/erodesoilprofile1.html"},{"title":"imposeSizeDistributionSoilProfile1 – NanoFASE","text":"public function imposeSizeDistributionSoilProfile1(me, mass) result(distribution) Impose a size class distribution on a total mass to split it up\n into separate size classes. If a size distribution has been specified\n for this SoilProfile, use that, otherwise, use the global size distribution. Arguments Type Intent Optional Attributes Name class( SoilProfile1 ) :: me This SoilProfile instance real(kind=dp) :: mass The mass to split into size classes Return Value real(kind=dp)\n  (C%nSizeClassesSpm) The resulting distribution","tags":"","loc":"proc/imposesizedistributionsoilprofile1.html"},{"title":"parseInputDataSoilProfile1 – NanoFASE","text":"public function parseInputDataSoilProfile1(me) result(r) Get the data from the input file and set object properties\n accordingly, including allocation of arrays that depend on\n input data\n Slope of the channel [m/m]. Defaults to GridCell slope.\n Hillslope length of the channel [km] Arguments Type Intent Optional Attributes Name class( SoilProfile1 ) :: me This SoilProfile instance Return Value type(Result) Result object to return","tags":"","loc":"proc/parseinputdatasoilprofile1.html"},{"title":"destroyDiffuseSource – NanoFASE","text":"private function destroyDiffuseSource(me) result(r) Arguments Type Intent Optional Attributes Name class( DiffuseSource ) :: me Return Value type(Result)","tags":"","loc":"proc/destroydiffusesource.html"},{"title":"destroyPointSource – NanoFASE","text":"private function destroyPointSource(me) result(r) Arguments Type Intent Optional Attributes Name class( PointSource ) :: me Return Value type(Result)","tags":"","loc":"proc/destroypointsource.html"},{"title":"createEnvironment1 – NanoFASE","text":"private function createEnvironment1(me) result(r) Create the environment, which sets up the grid and river structure.\n The Environment instance must be a target so that SubRiver inflows\n can point to another SubRiver object ( see here ) Arguments Type Intent Optional Attributes Name class( Environment1 ), target :: me This Environment instace. Must be target so SubRivers can be pointed at. Return Value type(Result) Result object to return","tags":"","loc":"proc/createenvironment1.html"},{"title":"destroyEnvironment1 – NanoFASE","text":"private function destroyEnvironment1(me) result(r) Destroy the Environment instance Arguments Type Intent Optional Attributes Name class( Environment1 ) :: me Return Value type(Result)","tags":"","loc":"proc/destroyenvironment1.html"},{"title":"updateEnvironment1 – NanoFASE","text":"private function updateEnvironment1(me, t) result(r) Perform simulations for the Environment Arguments Type Intent Optional Attributes Name class( Environment1 ) :: me This Environment instance integer :: t Current time step Return Value type(Result)","tags":"","loc":"proc/updateenvironment1.html"},{"title":"createBedSedimentLayer1 – NanoFASE","text":"public function createBedSedimentLayer1(Me, n, nsc, FSType, C_tot, f_comp, pd_comp, Porosity, V_f, M_f) result(r) initialise a BedSedimentLayer object:\n  - sets number of particle size classes\n  - reads in fixed layer volume\n  - reads in volumes of fine sediment and water in each size class\n  - sets volume of coarse material Arguments Type Intent Optional Attributes Name class( BedSedimentLayer1 ) :: Me the BedSedimentLayer instance character(len=256) :: n a name for the object integer, intent(in) :: nsc the number of particle size classes integer, intent(in) :: FSType the type identification number of the FineSediment(s) real(kind=dp), intent(in) :: C_tot the total volume of the layer real(kind=dp), intent(in) :: f_comp (:,:) set of fractional compositions. Index 1 = size class, Index 2 = compositional fraction real(kind=dp), intent(in), allocatable :: pd_comp (:) set of fractional particle densities real(kind=dp), intent(in), optional :: Porosity layer porosity, if being used to define layer real(kind=dp), intent(in), optional :: V_f (:) set of fine sediment volumes, if being used to define layer real(kind=dp), intent(in), optional :: M_f (:) set of fine sediment masses, if being used to define layer Return Value type(Result) The Result object.","tags":"","loc":"proc/createbedsedimentlayer1.html"},{"title":"destroyBedSedimentLayer1 – NanoFASE","text":"public function destroyBedSedimentLayer1(Me) result(r) destroy this object Arguments Type Intent Optional Attributes Name class( BedSedimentLayer1 ) :: Me the BedSedimentLayer instance Return Value type(Result) The Result object","tags":"","loc":"proc/destroybedsedimentlayer1.html"},{"title":"addSediment1 – NanoFASE","text":"public function addSediment1(Me, S, F) result(r) add sediment and water to this layer Arguments Type Intent Optional Attributes Name class( BedSedimentLayer1 ) :: Me the BedSedimentLayer instance integer, intent(in) :: S the particle size class type(FineSediment1), intent(inout) :: F FineSediment - holds material to be added Return Value type(Result) The Result object","tags":"","loc":"proc/addsediment1.html"},{"title":"removeSediment1 – NanoFASE","text":"public function removeSediment1(Me, S, G) result(r) remove sediment and water from this layer Arguments Type Intent Optional Attributes Name class( BedSedimentLayer1 ) :: Me integer, intent(in) :: S type(FineSediment1), intent(in) :: G Return Value type(Result1D)","tags":"","loc":"proc/removesediment1.html"},{"title":"GetAf – NanoFASE","text":"public pure function GetAf(Me, s) result(A_f) return the available capacity for fine sediment of a specified size class\n compute capacity Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance integer, intent(in) :: s size class for which to retrieve available capacity Return Value real(kind=dp) return value","tags":"","loc":"proc/getaf.html"},{"title":"GetAw – NanoFASE","text":"public pure function GetAw(Me, s) result(A_w) return the available capacity for water associated with fine sediment of a specified size class\n compute capacity Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance integer, intent(in) :: s size class for which to retrieve available capacity Return Value real(kind=dp) return value","tags":"","loc":"proc/getaw.html"},{"title":"GetCf – NanoFASE","text":"public pure function GetCf(Me, s) result(C_f) return the total capacity for fine sediment of a specified size class\n compute capacity Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance integer, intent(in) :: s size class for which to retrieve available capacity Return Value real(kind=dp) return value","tags":"","loc":"proc/getcf.html"},{"title":"GetCw – NanoFASE","text":"public pure function GetCw(Me, s) result(C_w) returns the total capacity for water associated with fine sediment of a specified size class\n compute capacity Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance integer, intent(in) :: s size class for which to retrieve available capacity Return Value real(kind=dp) return value","tags":"","loc":"proc/getcw.html"},{"title":"GetvolSLR – NanoFASE","text":"public pure function GetvolSLR(Me) result(volSLR) return the volumetric solid:liquid ratio for the layer Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value","tags":"","loc":"proc/getvolslr.html"},{"title":"GetMflayer – NanoFASE","text":"public pure function GetMflayer(Me) result(Mf_layer) return the sediment mass in the layer across all size fractions Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value","tags":"","loc":"proc/getmflayer.html"},{"title":"GetCflayer – NanoFASE","text":"public pure function GetCflayer(Me) result(Cf_layer) return the sediment capacity in the layer across all size fractions Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value","tags":"","loc":"proc/getcflayer.html"},{"title":"GetVflayer – NanoFASE","text":"public pure function GetVflayer(Me) result(Vf_layer) return the sediment volume in the layer across all size fractions Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value","tags":"","loc":"proc/getvflayer.html"},{"title":"GetVwlayer – NanoFASE","text":"public pure function GetVwlayer(Me) result(Vw_layer) return the water volume in the layer across all sediment size fractions Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value","tags":"","loc":"proc/getvwlayer.html"},{"title":"GetCwlayer – NanoFASE","text":"public pure function GetCwlayer(Me) result(Cw_layer) return the water capacity in the layer across all sediment size fractions Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value","tags":"","loc":"proc/getcwlayer.html"},{"title":"GetVmlayer – NanoFASE","text":"public pure function GetVmlayer(Me) result(Vm_layer) return the fine sediment & water volume in the layer across all size fractions Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value","tags":"","loc":"proc/getvmlayer.html"},{"title":"GetVlayer – NanoFASE","text":"public pure function GetVlayer(Me) result(V_layer) return the total volume of the layer Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value","tags":"","loc":"proc/getvlayer.html"},{"title":"createFineSediment1 – NanoFASE","text":"public function createFineSediment1(Me, n, pd_comp_in) result(r) initialise this object Arguments Type Intent Optional Attributes Name class( FineSediment1 ) :: Me self-reference character(len=256) :: n a name identifier for the object; identifies this object uniquely real(kind=dp), intent(in), allocatable :: pd_comp_in (:) input array of particle densities for compositional fractions Return Value type(Result) Result object","tags":"","loc":"proc/createfinesediment1.html"},{"title":"setFS1 – NanoFASE","text":"public function setFS1(Me, Mf_in, Vf_in, Vw_in, f_comp_in) result(r) set the properties of the object Arguments Type Intent Optional Attributes Name class( FineSediment1 ) :: Me real(kind=dp), intent(in), optional :: Mf_in real(kind=dp), intent(in), optional :: Vf_in real(kind=dp), intent(in), optional :: Vw_in real(kind=dp), intent(in), optional :: f_comp_in (:) Return Value type(Result)","tags":"","loc":"proc/setfs1.html"},{"title":"getFSVol1 – NanoFASE","text":"public pure function getFSVol1(Me) result(Vf) return the fine sediment volume [m3 m-2] Arguments Type Intent Optional Attributes Name class( FineSediment1 ), intent(in) :: Me self-reference Return Value real(kind=dp) the return value","tags":"","loc":"proc/getfsvol1.html"},{"title":"getFSMass1 – NanoFASE","text":"public pure function getFSMass1(Me) result(Mf) return the fine sediment mass [kg m-2] Arguments Type Intent Optional Attributes Name class( FineSediment1 ), intent(in) :: Me self-reference Return Value real(kind=dp) the return value","tags":"","loc":"proc/getfsmass1.html"},{"title":"getWVol1 – NanoFASE","text":"public pure function getWVol1(Me) result(Vw) return the water volume [m3 m-2] Arguments Type Intent Optional Attributes Name class( FineSediment1 ), intent(in) :: Me self-reference Return Value real(kind=dp) the return value","tags":"","loc":"proc/getwvol1.html"},{"title":"pdens1 – NanoFASE","text":"public pure function pdens1(Me) result(rho_part) compute particle density from components and their densities Arguments Type Intent Optional Attributes Name class( FineSediment1 ), intent(in) :: Me self-reference Return Value real(kind=dp) return value: the particle density [kg m-3]","tags":"","loc":"proc/pdens1.html"},{"title":"audit_fcomp1 – NanoFASE","text":"public pure function audit_fcomp1(Me) result(er) check that the array of fractional compositions sums to unity Arguments Type Intent Optional Attributes Name class( FineSediment1 ), intent(in) :: Me self-reference Return Value type(ErrorInstance) ErrorInstance object, returns error if t_fcomp /= 1","tags":"","loc":"proc/audit_fcomp1.html"},{"title":"Empty1 – NanoFASE","text":"public pure function Empty1(Me) result(t) check whether this object contains any fine sediment or water of the specified size class Arguments Type Intent Optional Attributes Name class( FineSediment1 ), intent(in) :: Me self-reference Return Value logical return value. True= V_f/M_f = V_w = 0. False= V_f/M_f > 0 .or. V_w > 0","tags":"","loc":"proc/empty1.html"},{"title":"Mix1 – NanoFASE","text":"public function Mix1(Me, FS) result(r) mix two FineSediment objects together Arguments Type Intent Optional Attributes Name class( FineSediment1 ) :: Me self-reference type( FineSediment1 ), intent(in) :: FS FineSediment1 to be mixed with this one Return Value type(Result0D) Result object","tags":"","loc":"proc/mix1.html"},{"title":"ClearAll1 – NanoFASE","text":"public subroutine ClearAll1(Me) clear all properties Arguments Type Intent Optional Attributes Name class( FineSediment1 ) :: Me the FineSediment instance","tags":"","loc":"proc/clearall1.html"},{"title":"createRiverReach1 – NanoFASE","text":"private function createRiverReach1(me, x, y, s, r, l, QrunoffTimeSeries) result(res) Create a RiverReach with x, y, s, r coordinates from the datafile. Arguments Type Intent Optional Attributes Name class( RiverReach1 ) :: me The RiverReach1 instance. integer :: x Containing GridCell x-position index. integer :: y Containing GridCell y-position index. integer :: s Containing SubRiver index. integer :: r RiverReach index. real(kind=dp) :: l Length of the RiverReach (without meandering). real(kind=dp), allocatable :: QrunoffTimeSeries (:) Any GridCell runoff (that has already been split to the correct RiverReach size) Return Value type(Result) The Result object.","tags":"","loc":"proc/createriverreach1.html"},{"title":"destroyRiverReach1 – NanoFASE","text":"private function destroyRiverReach1(me) result(r) Destroy this RiverReach1 Arguments Type Intent Optional Attributes Name class( RiverReach1 ) :: me This RiverReach1 instance Return Value type(Result) The Result object","tags":"","loc":"proc/destroyriverreach1.html"},{"title":"update1 – NanoFASE","text":"private function update1(me, Qin, spmIn, t) result(r) Update the RiverReach on this timestep t, based on the inflow Q and SPM provided Arguments Type Intent Optional Attributes Name class( RiverReach1 ) :: me This RiverReach1 instance real(kind=dp) :: Qin Inflow to this reach real(kind=dp) :: spmIn (C%nSizeClassesSpm) Inflow SPM to this reach integer :: t What time step are we on? Return Value type(Result) Result object to return","tags":"","loc":"proc/update1.html"},{"title":"calculateWidth1 – NanoFASE","text":"private pure function calculateWidth1(me, Q) result(W) Calculate the width  W  of the river based on the discharge:\n \n      W = 1.22Q&#94;{0.557}\n \n References:\n - Dumont et al., 2012 - Allen et al., 1994 Arguments Type Intent Optional Attributes Name class( RiverReach1 ), intent(in) :: me The RiverReach1 instance real(kind=dp), intent(in) :: Q Grid cell discharge  Q  [m**3/s] Return Value real(kind=dp) The calculated width  W  [m]","tags":"","loc":"proc/calculatewidth1.html"},{"title":"calculateDepth1 – NanoFASE","text":"private pure function calculateDepth1(me, W, S, Q) result(r) Calculate water depth from Manning's roughness coefficient,\n using Newton's method:\n \n      D_i = D_{i-1} - \\frac{f(D_{i-1})}{f'(D_{i-1})}\n \n where\n \n      f(D) = WD \\left( \\frac{WD}{W+2D} \\right)&#94;{2/3} \\frac{\\sqrt{S}}{n} - Q = 0\n \n and\n \n      f'(D) = \\frac{\\sqrt{S}}{n} \\frac{(DW)&#94;{5/3}(6D + 5W)}{3D(2D + W)&#94;{5/3}}\n  Arguments Type Intent Optional Attributes Name class( RiverReach1 ), intent(in) :: me The RiverReach1 instance. real(kind=dp), intent(in) :: W River width  W  [m]. real(kind=dp), intent(in) :: S River slope  S  [-]. real(kind=dp), intent(in) :: Q Flow rate  Q  [m3/s]. Return Value type(Result0D) The Result object.","tags":"","loc":"proc/calculatedepth1.html"},{"title":"calculateVelocity1 – NanoFASE","text":"private pure function calculateVelocity1(me, D, Q, W) result(v) Calculate the velocity of the river:\n \n      v = \\frac{Q}{WD}\n  Arguments Type Intent Optional Attributes Name class( RiverReach1 ), intent(in) :: me The RiverReach1 instance real(kind=dp), intent(in) :: D River depth  D  [m] real(kind=dp), intent(in) :: Q Flow rate  Q  [m**3/s] real(kind=dp), intent(in) :: W River width  W  [m] Return Value real(kind=dp) The calculated velocity  v  [m/s]","tags":"","loc":"proc/calculatevelocity1.html"},{"title":"calculateSettlingVelocity1 – NanoFASE","text":"private function calculateSettlingVelocity1(me, d, rho_spm, T) result(W_spm) Calculate the settling velocity of sediment particles for an individual\n size class:\n \n      W_{text{spm}} = \\frac{\\nu}{d} d_{*}&#94;3 (38.1 + 0.93 d_{*}&#94;{12/7})&#94;{-7/8}\n \n where\n \n      d_{*} = \\left( \\frac{\\Delta g}{\\nu&#94;2} \\right)&#94;{1/3} d\n \n and\n \n      \\Delta = \\frac{\\rho_{\\text{spm}}}{\\rho} - 1\n \n Reference: Zhiyao et al, 2008 . Arguments Type Intent Optional Attributes Name class( RiverReach1 ), intent(in) :: me The RiverReach1 instance. real(kind=dp), intent(in) :: d Sediment particle diameter [m]. real(kind=dp), intent(in) :: rho_spm Sediment particle density [kg/m**3]. real(kind=dp), intent(in) :: T Temperature [C]. Return Value real(kind=dp) Calculated settling velocity [m/s].","tags":"","loc":"proc/calculatesettlingvelocity1.html"},{"title":"calculateVolume1 – NanoFASE","text":"private pure function calculateVolume1(me, D, W, l, f_m) result(volume) Calculate the volume of a RiverReach, assuming a rectangular profile:\n \n      \\text{volume} = DWlf_m\n  Arguments Type Intent Optional Attributes Name class( RiverReach1 ), intent(in) :: me The RiverReach1 instance real(kind=dp), intent(in) :: D River depth [m] real(kind=dp), intent(in) :: W River width [m] real(kind=dp), intent(in) :: l River length, without meandering [m] real(kind=dp), intent(in) :: f_m Meandering factor [-] Return Value real(kind=dp) The calculated volume [m3]","tags":"","loc":"proc/calculatevolume1.html"},{"title":"calculateArea1 – NanoFASE","text":"private pure function calculateArea1(me, D, W) result(area) Calculate the area of a cross-section of the RiverReach, assuming\n a rectangular profile:\n \n      \\text{area} = DW\n  Arguments Type Intent Optional Attributes Name class( RiverReach1 ), intent(in) :: me The RiverReach1 instance real(kind=dp), intent(in) :: D River depth [m] real(kind=dp), intent(in) :: W River width [m] Return Value real(kind=dp) The calculated area [m3]","tags":"","loc":"proc/calculatearea1.html"},{"title":"getVolumeRiverReach – NanoFASE","text":"public function getVolumeRiverReach(me) result(volume) Return the volume of the RiverReach. Arguments Type Intent Optional Attributes Name class( RiverReach ) :: me Return Value real(kind=dp)","tags":"","loc":"proc/getvolumeriverreach.html"},{"title":"getQOutRiverReach – NanoFASE","text":"public function getQOutRiverReach(me) result(Qout) Return the outflow. Arguments Type Intent Optional Attributes Name class( RiverReach ) :: me Return Value real(kind=dp)","tags":"","loc":"proc/getqoutriverreach.html"},{"title":"getSpmOutRiverReach – NanoFASE","text":"public function getSpmOutRiverReach(me) result(spmOut) Return the SPM discahrge. Arguments Type Intent Optional Attributes Name class( RiverReach ) :: me Return Value real(kind=dp)\n  (size(me%spmOut))","tags":"","loc":"proc/getspmoutriverreach.html"},{"title":"newSubRiver1 – NanoFASE","text":"public function newSubRiver1(x, y, s, length, QrunoffTimeSeries) result(me) Return a newly-created SubRiver1 object. This is bound to SubRiver1 interface\n TODO: Do something with result object Arguments Type Intent Optional Attributes Name integer :: x Location of the SubRiver integer :: y Location of the SubRiver integer :: s Location of the SubRiver real(kind=dp) :: length Length of the SubRiver (without meandering) real(kind=dp), allocatable :: QrunoffTimeSeries (:) Any initial runoff from the hydrological model Return Value type( SubRiver1 ) The new SubRiver to return","tags":"","loc":"proc/newsubriver1.html"},{"title":"createSubRiver1 – NanoFASE","text":"public function createSubRiver1(me, x, y, s, length, QrunoffTimeSeries) result(r) Arguments Type Intent Optional Attributes Name class( SubRiver1 ) :: me type(integer), intent(in) :: x type(integer), intent(in) :: y type(integer), intent(in) :: s real(kind=dp) :: length real(kind=dp), allocatable :: QrunoffTimeSeries (:) Return Value type(Result)","tags":"","loc":"proc/createsubriver1.html"},{"title":"destroySubRiver1 – NanoFASE","text":"public function destroySubRiver1(me) result(r) Arguments Type Intent Optional Attributes Name class( SubRiver1 ) :: me Return Value type(Result)","tags":"","loc":"proc/destroysubriver1.html"},{"title":"updateSubRiver1 – NanoFASE","text":"public function updateSubRiver1(me, t) result(r) Arguments Type Intent Optional Attributes Name class( SubRiver1 ) :: me integer :: t Return Value type(Result)","tags":"","loc":"proc/updatesubriver1.html"},{"title":"finaliseUpdateSubRiver1 – NanoFASE","text":"public function finaliseUpdateSubRiver1(me) result(r) Set the outflow and SPM mass from the temporary variables that were set by the\n routing procedure. This step is kept separate from the routing so that the\n wrong outflow isn't used as an inflow for another SubRiver whilst the SubRivers\n are looped through. Arguments Type Intent Optional Attributes Name class( SubRiver1 ) :: me This SubRiver1 instace Return Value type(Result) The Result object","tags":"","loc":"proc/finaliseupdatesubriver1.html"},{"title":"auditrefs – NanoFASE","text":"public function auditrefs(me) result(r) Arguments Type Intent Optional Attributes Name class( SubRiver1 ) :: me Return Value type(Result)","tags":"","loc":"proc/auditrefs.html"},{"title":"SubRiver1 – NanoFASE","text":"public interface SubRiver1 Interface so that we can create new SubRivers by sr = SubRiver1() Module Procedures newSubRiver1 Module Procedures public function newSubRiver1 (x, y, s, length, QrunoffTimeSeries) result(me) Return a newly-created SubRiver1 object. This is bound to SubRiver1 interface\n TODO: Do something with result object Arguments Type Intent Optional Attributes Name integer :: x Location of the SubRiver integer :: y Location of the SubRiver integer :: s Location of the SubRiver real(kind=dp) :: length Length of the SubRiver (without meandering) real(kind=dp), allocatable :: QrunoffTimeSeries (:) Any initial runoff from the hydrological model Return Value type( SubRiver1 ) The new SubRiver to return","tags":"","loc":"interface/subriver1.html"},{"title":"getQOutSubRiver – NanoFASE","text":"public function getQOutSubRiver(me) result(QOut) Get the discharge from the SubRiver. Arguments Type Intent Optional Attributes Name class( SubRiver ) :: me This SubRiver instance Return Value real(kind=dp) Discharge out of the SubRiver [m3]","tags":"","loc":"proc/getqoutsubriver.html"},{"title":"getSpmOutSubRiver – NanoFASE","text":"public function getSpmOutSubRiver(me) result(spmOut) Get the SPM discharge from the SubRiver. Arguments Type Intent Optional Attributes Name class( SubRiver ) :: me This SubRiver instance Return Value real(kind=dp)\n  (size(me%spmOut)) SPM discharge for all size classes [kg]","tags":"","loc":"proc/getspmoutsubriver.html"},{"title":"getSpmOutBySizeClassSubRiver – NanoFASE","text":"public function getSpmOutBySizeClassSubRiver(me, n) result(spmOut) Get the SPM discharge from the SubRiver, for a given size class. Arguments Type Intent Optional Attributes Name class( SubRiver ) :: me This SubRiver instance integer :: n Size class Return Value real(kind=dp) SPM discharge [kg]","tags":"","loc":"proc/getspmoutbysizeclasssubriver.html"},{"title":"newGridCell1 – NanoFASE","text":"public function newGridCell1(x, y, isEmpty) result(me) Return a newly-created GridCell1 object.\n TODO: Do something with result object Arguments Type Intent Optional Attributes Name integer :: x Location of the GridCell integer :: y Location of the GridCell logical, optional :: isEmpty Is anything to be simulated in this GridCell? Return Value type( GridCell1 ) The new GridCell to return","tags":"","loc":"proc/newgridcell1.html"},{"title":"createGridCell1 – NanoFASE","text":"public function createGridCell1(me, x, y, isEmpty) result(r) Create a GridCell with coordinates x and y. Arguments Type Intent Optional Attributes Name class( GridCell1 ) :: me The GridCell instance. integer :: x Location of the GridCell integer :: y Location of the GridCell logical, optional :: isEmpty Is anything to be simulated in this GridCell? Return Value type(Result) The Result object to return.","tags":"","loc":"proc/creategridcell1.html"},{"title":"destroyGridCell1 – NanoFASE","text":"public function destroyGridCell1(Me) result(r) Arguments Type Intent Optional Attributes Name class( GridCell1 ) :: Me The GridCell instance. Return Value type(Result) The Result object","tags":"","loc":"proc/destroygridcell1.html"},{"title":"updateGridCell1 – NanoFASE","text":"public function updateGridCell1(Me, t) result(r) Perform the simulations required for an individual timestep t. Arguments Type Intent Optional Attributes Name class( GridCell1 ) :: Me integer :: t Return Value type(Result)","tags":"","loc":"proc/updategridcell1.html"},{"title":"finaliseUpdateGridCell1 – NanoFASE","text":"public function finaliseUpdateGridCell1(me) result(r) Set the outflow from the temporary outflow variables that were setting by the\n update procedure. This step is kept separate from the routing so that the\n wrong outflow isn't used as an inflow for another SubRiver whilst the SubRivers\n are looped through. Arguments Type Intent Optional Attributes Name class( GridCell1 ) :: me This SubRiver1 instace Return Value type(Result) The Result object","tags":"","loc":"proc/finaliseupdategridcell1.html"},{"title":"parseInputDataGridCell1 – NanoFASE","text":"public function parseInputDataGridCell1(me) result(r) Get the data from the input file and set object properties\n accordingly, including allocation of arrays that depend on\n input data. Arguments Type Intent Optional Attributes Name class( GridCell1 ) :: me This GridCell1 object Return Value type(Result) The result object","tags":"","loc":"proc/parseinputdatagridcell1.html"},{"title":"GridCell1 – NanoFASE","text":"public interface GridCell1 Interface so that we can create new GridCells by gc = GridCell1() Module Procedures newGridCell1 Module Procedures public function newGridCell1 (x, y, isEmpty) result(me) Return a newly-created GridCell1 object.\n TODO: Do something with result object Arguments Type Intent Optional Attributes Name integer :: x Location of the GridCell integer :: y Location of the GridCell logical, optional :: isEmpty Is anything to be simulated in this GridCell? Return Value type( GridCell1 ) The new GridCell to return","tags":"","loc":"interface/gridcell1.html"},{"title":"createObjBiota1 – NanoFASE","text":"public subroutine createObjBiota1(Me) constructor method Arguments Type Intent Optional Attributes Name class( objBiota1 ) :: Me This Biota1 instance","tags":"","loc":"proc/createobjbiota1.html"},{"title":"destroyObjBiota1 – NanoFASE","text":"public subroutine destroyObjBiota1(Me) finaliser method Arguments Type Intent Optional Attributes Name class( objBiota1 ) :: Me","tags":"","loc":"proc/destroyobjbiota1.html"},{"title":"createObjBiota2 – NanoFASE","text":"public subroutine createObjBiota2(Me) constructor method Arguments Type Intent Optional Attributes Name class( objBiota2 ) :: Me This Biota2 instance","tags":"","loc":"proc/createobjbiota2.html"},{"title":"destroyObjBiota2 – NanoFASE","text":"public subroutine destroyObjBiota2(Me) finaliser method Arguments Type Intent Optional Attributes Name class( objBiota2 ) :: Me This Biota2 instance","tags":"","loc":"proc/destroyobjbiota2.html"},{"title":"createBiota – NanoFASE","text":"public subroutine createBiota(me) Arguments Type Intent Optional Attributes Name class( Biota ) :: me","tags":"","loc":"proc/createbiota.html"},{"title":"destroyBiota – NanoFASE","text":"public subroutine destroyBiota(me) Arguments Type Intent Optional Attributes Name class( Biota ) :: me","tags":"","loc":"proc/destroybiota.html"},{"title":"newObjReactor1 – NanoFASE","text":"public subroutine newObjReactor1(Me) Arguments Type Intent Optional Attributes Name class( objReactor1 ) :: Me","tags":"","loc":"proc/newobjreactor1.html"},{"title":"destroyObjReactor1 – NanoFASE","text":"public subroutine destroyObjReactor1(Me) Arguments Type Intent Optional Attributes Name class( objReactor1 ) :: Me","tags":"","loc":"proc/destroyobjreactor1.html"},{"title":"newObjReactor2 – NanoFASE","text":"public subroutine newObjReactor2(Me) Arguments Type Intent Optional Attributes Name class( objReactor2 ) :: Me","tags":"","loc":"proc/newobjreactor2.html"},{"title":"destroyObjReactor2 – NanoFASE","text":"public subroutine destroyObjReactor2(Me) Arguments Type Intent Optional Attributes Name class( objReactor2 ) :: Me","tags":"","loc":"proc/destroyobjreactor2.html"},{"title":"createReactor – NanoFASE","text":"public subroutine createReactor(me) Arguments Type Intent Optional Attributes Name class( Reactor ) :: me","tags":"","loc":"proc/createreactor.html"},{"title":"destroyReactor – NanoFASE","text":"public subroutine destroyReactor(me) Arguments Type Intent Optional Attributes Name class( Reactor ) :: me","tags":"","loc":"proc/destroyreactor.html"},{"title":"createBedSediment1 – NanoFASE","text":"private function createBedSediment1(Me, n, ln, nsc, nl, bslType, C_tot, f_comp, pd_comp, Porosity, V_f, M_f) result(r) Create a BedSediment object. Arguments Type Intent Optional Attributes Name class( BedSediment1 ) :: Me self-reference character(len=256), intent(in) :: n a name for the object character(len=256), allocatable :: ln (:) names for the layers. Index = layer integer, intent(in) :: nsc the number of particle size classes integer, intent(in) :: nl the number of layers integer, intent(in) :: bslType the type identification number of the BedSedimentLayer(s) real(kind=dp), intent(in), allocatable :: C_tot (:) the total volume of each layer. Index = layer real(kind=dp), intent(in), allocatable :: f_comp (:,:,:) set of fractional compositions\n Index 1 = size class, Index 2 = compositional fraction, Index 3 = layer real(kind=dp), intent(in), allocatable :: pd_comp (:) set of fractional particle densities\n Index 1 = size class real(kind=dp), intent(in), optional :: Porosity (:) layer porosity, if being used to define layer\n Index 1 = layer real(kind=dp), intent(in), optional allocatable :: V_f (:,:) set of fine sediment volumes, if being used to define layers\n Index 1 = size class, Index 2 = layer real(kind=dp), intent(in), optional allocatable :: M_f (:,:) set of fine sediment masses, if being used to define layers\n Index 1 = size class, Index 2 = layer Return Value type(Result) returned Result object","tags":"","loc":"proc/createbedsediment1.html"},{"title":"destroyBedSediment1 – NanoFASE","text":"private function destroyBedSediment1(Me) result(r) deallocate all allocatable variables and call destroy methods for all enclosed objects Arguments Type Intent Optional Attributes Name class( BedSediment1 ) :: Me self-reference Return Value type(Result) returned Result object","tags":"","loc":"proc/destroybedsediment1.html"},{"title":"resuspendSediment1 – NanoFASE","text":"private function resuspendSediment1(Me, M_resusp, FS) result(r) compute resuspension from bed sediment Arguments Type Intent Optional Attributes Name class( BedSediment1 ) :: Me real(kind=dp), intent(in), allocatable :: M_resusp (:) type(FineSediment1), intent(out), allocatable :: FS (:,:) Return Value type(Result)","tags":"","loc":"proc/resuspendsediment1.html"},{"title":"depositSediment1 – NanoFASE","text":"private function depositSediment1(Me, M_dep, f_comp_dep, V_w_tot) result(r) compute deposition to bed sediment, including burial and downward shifting of fine sediment and water Arguments Type Intent Optional Attributes Name class( BedSediment1 ) :: Me self-reference real(kind=dp), intent(in), allocatable :: M_dep (:) Depositing sediment mass by size class real(kind=dp), intent(in), allocatable :: f_comp_dep (:,:) Depositing sediment fractional composition by size class\n Index 1 = size class, Index 2 = compositional fraction real(kind=dp), intent(out) :: V_w_tot water requirement from the water column [m3 m-2] Return Value type(Result) returned Result object","tags":"","loc":"proc/depositsediment1.html"},{"title":"calculateResuspensionBedSediment2 – NanoFASE","text":"private function calculateResuspensionBedSediment2(me, a, m_bed, alpha, omega, R_h, R_hmax) result(r) Calculate resuspension from bed sediment using Bussi :\n \n      m_{\\text{ent}} = a m_{\\text{bed}} \\alpha \\omega \\frac{R_\\text{h}}{R_{\\text{h,max}}}\n  Arguments Type Intent Optional Attributes Name class( BedSediment2 ) :: me real(kind=dp) :: a Calibration factor [s2/kg] real(kind=dp) :: m_bed Bed mass per unit area [kg/m2] real(kind=dp) :: alpha Proportion of size class that can be resuspended [-] real(kind=dp) :: omega Stream power per unit area of stream bed [J/s/m2] real(kind=dp) :: R_h Actual hydraulic radius [m] real(kind=dp) :: R_hmax Maximum hydraulic radius [m] Return Value type(Result0D)","tags":"","loc":"proc/calculateresuspensionbedsediment2.html"},{"title":"calculateStreamPowerBedSediment2 – NanoFASE","text":"private function calculateStreamPowerBedSediment2(me, rho_water, g, Q, W, S) result(r) Calculate the stream power (per unit area of stream bed) using Bagnold's\n stream power equation:\n \n      \\omega = \\frac{\\rho g Q S}{W}\n \n Reference: Bagnold, 1966 Arguments Type Intent Optional Attributes Name class( BedSediment2 ) :: me real(kind=dp) :: rho_water Density of water [kg/m3] real(kind=dp) :: g Gravitational acceleration [m/s] real(kind=dp) :: Q Discharge [m3/s] real(kind=dp) :: W River width [m] real(kind=dp) :: S River slope [m/m] Return Value type(Result0D)","tags":"","loc":"proc/calculatestreampowerbedsediment2.html"},{"title":"Get_Af_sediment – NanoFASE","text":"public pure function Get_Af_sediment(Me, S) result(Af_sediment) return available capacity for fine sediment of a specified size class Arguments Type Intent Optional Attributes Name class( BedSediment ), intent(in) :: Me the BedSediment instance integer, intent(in) :: S size class Return Value real(kind=dp) return value","tags":"","loc":"proc/get_af_sediment.html"},{"title":"Get_Cf_sediment – NanoFASE","text":"public pure function Get_Cf_sediment(Me, S) result(Cf_sediment) return capacity for fine sediment of a specified size class Arguments Type Intent Optional Attributes Name class( BedSediment ), intent(in) :: Me the BedSediment instance integer, intent(in) :: S size class Return Value real(kind=dp) return value","tags":"","loc":"proc/get_cf_sediment.html"},{"title":"Get_Aw_sediment – NanoFASE","text":"public pure function Get_Aw_sediment(Me, S) result(Aw_sediment) return available capacity for water associated with a specified size class Arguments Type Intent Optional Attributes Name class( BedSediment ), intent(in) :: Me the BedSediment instance integer, intent(in) :: S size class Return Value real(kind=dp) return value","tags":"","loc":"proc/get_aw_sediment.html"},{"title":"Get_Cw_sediment – NanoFASE","text":"public pure function Get_Cw_sediment(Me, S) result(Cw_sediment) return capacity for water associated with a specified size class Arguments Type Intent Optional Attributes Name class( BedSediment ), intent(in) :: Me the BedSediment instance integer, intent(in) :: S size class Return Value real(kind=dp) return value","tags":"","loc":"proc/get_cw_sediment.html"},{"title":"Get_Mf_sediment – NanoFASE","text":"public pure function Get_Mf_sediment(Me, S) result(Mf_sediment) return fine sediment mass in a specified size class Arguments Type Intent Optional Attributes Name class( BedSediment ), intent(in) :: Me the BedSediment instance integer, intent(in) :: S size class Return Value real(kind=dp) return value","tags":"","loc":"proc/get_mf_sediment.html"},{"title":"Get_Mf_sed_all – NanoFASE","text":"public pure function Get_Mf_sed_all(Me, S) result(Mf_sed_all) return fine sediment mass for all size classes Arguments Type Intent Optional Attributes Name class( BedSediment ), intent(in) :: Me the BedSediment instance integer, intent(in) :: S size class Return Value real(kind=dp) return value","tags":"","loc":"proc/get_mf_sed_all.html"},{"title":"UtilModule – NanoFASE","text":"Uses: Globals Module with a handful of useful globally-available procedures Interfaces str ref Functions strFromInteger strFromReal strFromDp ref2 ref3 ref4 Interfaces public interface str Return a string from an integer or real number public pure function strFromInteger (i) result(str) Convert an integer to a string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i The integer to convert to a string Return Value character(len=256) The string to return public pure function strFromReal (r) result(str) Convert a real to a string Arguments Type Intent Optional Attributes Name real, intent(in) :: r The integer to convert to a string Return Value character(len=256) The string to return public pure function strFromDp (r) result(str) Convert a double-precision real to a string Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r The integer to convert to a string Return Value character(len=256) The string to return public interface ref public pure function ref2 (prefix, a, b) Generate an object reference from a prefix (e.g., \"GridCell\")\n and two integers Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix integer, intent(in) :: a integer, intent(in) :: b Return Value character(len=256) public pure function ref3 (prefix, a, b, c) Generate an object reference from a prefix (e.g., \"RiverReach\")\n and three integers Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix integer, intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value character(len=256) public pure function ref4 (prefix, a, b, c, d) Generate an object reference from a prefix (e.g., \"BedSediment\")\n and four integers Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix integer, intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c integer, intent(in) :: d Return Value character(len=256) Functions public pure function strFromInteger (i) result(str) Convert an integer to a string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i The integer to convert to a string Return Value character(len=256) The string to return public pure function strFromReal (r) result(str) Convert a real to a string Arguments Type Intent Optional Attributes Name real, intent(in) :: r The integer to convert to a string Return Value character(len=256) The string to return public pure function strFromDp (r) result(str) Convert a double-precision real to a string Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r The integer to convert to a string Return Value character(len=256) The string to return public pure function ref2 (prefix, a, b) Generate an object reference from a prefix (e.g., \"GridCell\")\n and two integers Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix integer, intent(in) :: a integer, intent(in) :: b Return Value character(len=256) public pure function ref3 (prefix, a, b, c) Generate an object reference from a prefix (e.g., \"RiverReach\")\n and three integers Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix integer, intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value character(len=256) public pure function ref4 (prefix, a, b, c, d) Generate an object reference from a prefix (e.g., \"BedSediment\")\n and four integers Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix integer, intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c integer, intent(in) :: d Return Value character(len=256)","tags":"","loc":"module/utilmodule.html"},{"title":"Globals – NanoFASE","text":"Uses: json_module mo_netcdf ErrorCriteriaModule ErrorInstanceModule Variables ERROR_HANDLER dp qp C Derived Types Constants Functions rho_w nu_w Subroutines GLOBALS_INIT Variables Type Visibility Attributes Name Initial type(ErrorCriteria), public :: ERROR_HANDLER integer, public, parameter :: dp = selected_real_kind(15, 307) integer, public, parameter :: qp = selected_real_kind(33, 4931) type( Constants ), public :: C Derived Types type, public :: Constants Components Type Visibility Attributes Name Initial real(kind=dp), public :: g = 9.80665_dp Gravitational acceleration [m/s&#94;2] real(kind=dp), public :: n_river = 0.035_dp Manning's roughness coefficient, for natural streams and major rivers. Reference . real(kind=dp), public :: T = 15.0_dp Temperature [C] character(len=12), public :: inputFile = 'data/data.nc' Name of the data input file. TODO: Get this from config file. real(kind=dp), public, allocatable :: d_spm (:) Suspended particulate matter size class diameters [m] real(kind=dp), public, allocatable :: d_np (:) Nanoparticle size class diameters [m] integer, public :: nSizeClassesSpm Number of sediment particle size classes integer, public :: nSizeClassesNP Number of nanoparticle size classes integer, public, allocatable :: defaultDistributionSediment (:) Default imposed size distribution for sediment integer, public, allocatable :: defaultDistributionNP (:) Default imposed size distribution for NPs integer, public :: maxRiverReaches = 100 Maximum number of RiverReaches a SubRiver can have.\n TODO: Would be good if this was from config file real(kind=dp), public :: gridCellSize The dimensions of each grid cell [m]. integer, public :: timeStep The timestep to run the model on [s]. integer, public :: nTimeSteps The number of timesteps. Type-Bound Procedures procedure, public :: nu_w procedure, public :: rho_w Functions public pure function rho_w (me, T, S) Calculate the density of water at a given temperature  T :\n \n      \\rho_{\\text{w}}(T) = 1000 \\left( 1 - \\frac{T + 288.9414}{508929.2 (T + 68.12963) (T - 3.9863&#94;2)} \\right)\n \n and optionally with a given salinity  S :\n \n      \\rho_{\\text{w,s}}(T,S) = \\rho_w + AS + BS&#94;{3/2} + CS&#94;2\n \n where  A = 0.824493 - 0.0040899T + 0.000076438T&#94;2 -0.00000082467T&#94;3 + 0.0000000053675T&#94;4 ,\n  B = -0.005724 + 0.00010227T - 0.0000016546T&#94;2  and  C = 4.8314 \\times 10&#94;{-4} .\n Reference:\n  - D. R. Maidment, Handbook of Hydrology (2012) Arguments Type Intent Optional Attributes Name class( Constants ), intent(in) :: me This Constants instance. real(kind=dp), intent(in) :: T Temperature  T  [C]. real(kind=dp), intent(in), optional :: S Salinity  S  [g/kg] Return Value real(kind=dp) Density of water  \\rho_w  [kg/m**3]. public pure function nu_w (me, T, S) Calculate the kinematic viscosity of water  \\nu_w  at given temperature  T \n and optionally salinity  S :\n \n      \\nu_{\\text{w}}(T,S) = \\frac{1}{\\rho_w(T,S)} 2.414\\times 10&#94;{-5} 10&#94;{\\frac{247.8}{(T+273.15)-140.0}}\n  Arguments Type Intent Optional Attributes Name class( Constants ), intent(in) :: me This Constants instance. real(kind=dp), intent(in) :: T Temperature  T  [C]. real(kind=dp), intent(in), optional :: S Salinity  S  [g/kg] Return Value real(kind=dp) Kinematic viscosity of water  \\nu_{\\text{w}}  Subroutines public subroutine GLOBALS_INIT () Initialise global variables. For the moment, just error\n handling, but concievably could deal with constants, files\n and other setup tasks in the future. Arguments None","tags":"","loc":"module/globals.html"},{"title":"classDatabase – NanoFASE","text":"Uses: ResultModule mo_netcdf Module for interacting with the input data.\n TODO: Not currently working as var%getData(variable) needs a specific\n variable type passed to it, so using a polymorphic class(*) won't work\n and we would need to take an approach similar to mo_netcdf in creating\n procedures for every data type. Need to think about this a bit more. Derived Types Database Functions initDatabase destroyDatabase getVariable readDatabase Derived Types type, public :: Database Components Type Visibility Attributes Name Initial character(len=256), public :: filePath type(NcDataset), public :: file Type-Bound Procedures procedure, public :: init => initDatabase procedure, public :: destroy => destroyDatabase procedure, public :: read => readDatabase procedure, public :: get => getVariable Functions private function initDatabase (me, filePath) result(r) Initialise the NetCDF database Arguments Type Intent Optional Attributes Name class( Database ) :: me This Database object character(len=*) :: filePath Path to the data file Return Value type(Result) The Result object private function destroyDatabase (me) result(r) Destroy the NetCDF database Arguments Type Intent Optional Attributes Name class( Database ) :: me Return Value type(Result) private function getVariable (me, location, variable) result(r) Arguments Type Intent Optional Attributes Name class( Database ) :: me character(len=256), allocatable :: location (:) class(*) :: variable Return Value type(Result) private function readDatabase (me, ref) result(r) Read data from the NetCDF database Arguments Type Intent Optional Attributes Name class( Database ) :: me character(len=*), allocatable :: ref (:) Return Value type(Result)","tags":"","loc":"module/classdatabase.html"},{"title":"classSoilProfile1 – NanoFASE","text":"Uses: Globals UtilModule mo_netcdf ResultModule spcSoilProfile A SoilProfile class acts as a container for a collection of\n SoilLayer objects, which collectively define the layout of\n the SoilProfile. Derived Types SoilProfile1 Functions createSoilProfile1 destroySoilProfile1 updateSoilProfile1 erodeSoilProfile1 imposeSizeDistributionSoilProfile1 parseInputDataSoilProfile1 Derived Types type, public, extends(SoilProfile) :: SoilProfile1 Type-Bound Procedures procedure, public :: create => createSoilProfile1 procedure, public :: destroy => destroySoilProfile1 procedure, public :: update => updateSoilProfile1 procedure, public :: erode => erodeSoilProfile1 procedure, public :: imposeSizeDistribution => imposeSizeDistributionSoilProfile1 procedure, public :: parseInputData => parseInputDataSoilProfile1 Functions public function createSoilProfile1 (me, x, y, p, slope, n_river, area) result(r) Creating the SoilProfile parses input data and fills\n the corresponding object properties, as well as setting\n up the contained SoilLayers. Arguments Type Intent Optional Attributes Name class( SoilProfile1 ) :: me The SoilProfile instance. integer :: x Containing GridCell x position integer :: y Containing GridCell y position integer :: p SoilProfile reference (redundant for now as only one SoilProfile per GridCell) real(kind=dp) :: slope Slope of the containing GridCell [m/m] real(kind=dp) :: n_river Manning's roughness coefficient for the GridCell's rivers [-] real(kind=dp) :: area The surface area of the SoilProfile [m3] Return Value type(Result) The Result object public function destroySoilProfile1 (me) result(r) Arguments Type Intent Optional Attributes Name class( SoilProfile1 ) :: me This SoilProfile instance Return Value type(Result) Result object to return public function updateSoilProfile1 (me, t, Qrunoff) result(r) Arguments Type Intent Optional Attributes Name class( SoilProfile1 ) :: me This SoilProfile instance integer :: t The current timestep real(kind=dp) :: Qrunoff Runoff generated on this timestep Return Value type(Result) Result object to return public function erodeSoilProfile1 (me, t) result(r) Calculates soil erosion for this timstep t. Updates this GridCell's\n state variable erodedSediment accordingly. Arguments Type Intent Optional Attributes Name class( SoilProfile1 ) :: me This SoilProfile instance integer :: t The timestep we're on Return Value type(Result) The Result object public function imposeSizeDistributionSoilProfile1 (me, mass) result(distribution) Impose a size class distribution on a total mass to split it up\n into separate size classes. If a size distribution has been specified\n for this SoilProfile, use that, otherwise, use the global size distribution. Arguments Type Intent Optional Attributes Name class( SoilProfile1 ) :: me This SoilProfile instance real(kind=dp) :: mass The mass to split into size classes Return Value real(kind=dp)\n  (C%nSizeClassesSpm) The resulting distribution public function parseInputDataSoilProfile1 (me) result(r) Get the data from the input file and set object properties\n accordingly, including allocation of arrays that depend on\n input data\n Slope of the channel [m/m]. Defaults to GridCell slope.\n Hillslope length of the channel [km] Arguments Type Intent Optional Attributes Name class( SoilProfile1 ) :: me This SoilProfile instance Return Value type(Result) Result object to return","tags":"","loc":"module/classsoilprofile1.html"},{"title":"spcSoilLayer – NanoFASE","text":"Uses: Globals netcdf mo_netcdf ResultModule ErrorInstanceModule Abstract Interfaces createSoilLayer destroySoilLayer updateSoilLayer Derived Types SoilLayer SoilLayerElement Abstract Interfaces abstract interface public function createSoilLayer (me) result(r) Arguments Type Intent Optional Attributes Name class( SoilLayer ) :: me Return Value type(Result) abstract interface public function destroySoilLayer (me) result(r) Arguments Type Intent Optional Attributes Name class( SoilLayer ) :: me Return Value type(Result) abstract interface public function updateSoilLayer (me) result(r) Arguments Type Intent Optional Attributes Name class( SoilLayer ) :: me Return Value type(Result) Derived Types type, public, abstract :: SoilLayer Components Type Visibility Attributes Name Initial character(len=256), public :: ref type(integer), public :: GridX type(integer), public :: GridY type(realdp), public :: depth type(realdp), public :: bdens type(realdp), public :: pH type(realdp), public :: SOM Type-Bound Procedures procedure(createSoilLayer), public :: create procedure(destroySoilLayer), public :: destroy procedure(updateSoilLayer), public :: update type, public :: SoilLayerElement Components Type Visibility Attributes Name Initial class( SoilLayer ), public, allocatable :: item","tags":"","loc":"module/spcsoillayer.html"},{"title":"spcSoilProfile – NanoFASE","text":"Uses: Globals spcSoilLayer Abstract Interfaces createSoilProfile destroySoilProfile updateSoilProfile erodeSoilProfile imposeSizeDistributionSoilProfile parseInputDataSoilProfile Derived Types SoilProfile SoilProfileElement Abstract Interfaces abstract interface public function createSoilProfile (me, x, y, p, slope, n_river, area) result(r) Creating the SoilProfile parses input data and fills\n the corresponding object properties, as well as setting\n up the contained SoilLayers. Arguments Type Intent Optional Attributes Name class( SoilProfile ) :: me The SoilProfile instance. integer :: x Containing GridCell x position integer :: y Containing GridCell y position integer :: p SoilProfile reference real(kind=dp) :: slope Slope of the containing GridCell [m/m] real(kind=dp) :: n_river Manning's roughness coefficient for the GridCell's rivers [-] real(kind=dp) :: area The area of the SoilProfile's surface Return Value type(Result) Result object to return abstract interface public function destroySoilProfile (me) result(r) Arguments Type Intent Optional Attributes Name class( SoilProfile ) :: me The SoilProfile instance Return Value type(Result) Result object to return abstract interface public function updateSoilProfile (me, t, Qrunoff) result(r) Perform the SoilProfile's simulation for one timestep Arguments Type Intent Optional Attributes Name class( SoilProfile ) :: me This SoilProfile instance integer :: t The current timestep real(kind=dp) :: Qrunoff Runoff generated on this timestep Return Value type(Result) Result object to return abstract interface public function erodeSoilProfile (me, t) result(r) Erode soil for the current timestep Arguments Type Intent Optional Attributes Name class( SoilProfile ) :: me This SoilProfile instance integer :: t The current timestep Return Value type(Result) Result object to return abstract interface public function imposeSizeDistributionSoilProfile (me, mass) result(distribution) Impose a size class distribution on a total mass to split it up\n into separate size classes. If a size distribution has been specified\n for this SoilProfile, use that, otherwise, use the global size distribution. Arguments Type Intent Optional Attributes Name class( SoilProfile ) :: me real(kind=dp) :: mass Return Value real(kind=dp)\n  (C%nSizeClassesSpm) abstract interface public function parseInputDataSoilProfile (me) result(r) Parses the input data for the SoilProfile from the data file Arguments Type Intent Optional Attributes Name class( SoilProfile ) :: me This SoilProfile instance Return Value type(Result) Result object to return Derived Types type, public, abstract :: SoilProfile Components Type Visibility Attributes Name Initial character(len=256), public :: ref integer, public :: x integer, public :: y integer, public :: p type(NcGroup), public :: ncGroup type(SoilLayerElement), public, allocatable :: colSoilLayers (:) type(integer), public :: nSoilLayers real(kind=dp), public :: Qrunoff real(kind=dp), public :: slope real(kind=dp), public :: n_river real(kind=dp), public :: area real(kind=dp), public, allocatable :: usle_C (:) real(kind=dp), public :: usle_K real(kind=dp), public :: usle_LS real(kind=dp), public :: usle_P real(kind=dp), public :: usle_CFRG real(kind=dp), public, allocatable :: usle_alpha_half (:) real(kind=dp), public :: usle_area_hru real(kind=dp), public :: usle_area_sb real(kind=dp), public :: usle_L_sb real(kind=dp), public :: usle_n_sb real(kind=dp), public :: usle_slp_sb real(kind=dp), public :: usle_slp_ch real(kind=dp), public :: usle_L_ch real(kind=dp), public, allocatable :: rusle2015_erodedSediment (:) real(kind=dp), public, allocatable :: erodedSediment (:) integer, public, allocatable :: distributionSediment (:) Type-Bound Procedures procedure(createSoilProfile), public :: create procedure(destroySoilProfile), public :: destroy procedure(updateSoilProfile), public :: update procedure(erodeSoilProfile), public :: erode procedure(imposeSizeDistributionSoilProfile), public :: imposeSizeDistribution procedure(parseInputDataSoilProfile), public :: parseInputData type, public :: SoilProfileElement Components Type Visibility Attributes Name Initial class( SoilProfile ), public, allocatable :: item","tags":"","loc":"module/spcsoilprofile.html"},{"title":"classDiffuseSource – NanoFASE","text":"Uses: Globals ResultModule Derived Types DiffuseSource Functions destroyDiffuseSource Derived Types type, public :: DiffuseSource Type-Bound Procedures procedure, public :: destroy => destroyDiffuseSource Functions private function destroyDiffuseSource (me) result(r) Arguments Type Intent Optional Attributes Name class( DiffuseSource ) :: me Return Value type(Result)","tags":"","loc":"module/classdiffusesource.html"},{"title":"classPointSource – NanoFASE","text":"Uses: Globals ResultModule Derived Types PointSource Functions destroyPointSource Derived Types type, public :: PointSource Type-Bound Procedures procedure, public :: destroy => destroyPointSource Functions private function destroyPointSource (me) result(r) Arguments Type Intent Optional Attributes Name class( PointSource ) :: me Return Value type(Result)","tags":"","loc":"module/classpointsource.html"},{"title":"spcEnvironment – NanoFASE","text":"Uses: Globals ResultModule spcGridCell Abstract Interfaces createEnvironment destroyEnvironment updateEnvironment Derived Types Environment Abstract Interfaces abstract interface private function createEnvironment (me) result(r) Interface to create an Environment object Arguments Type Intent Optional Attributes Name class( Environment ), target :: me Return Value type(Result) abstract interface private function destroyEnvironment (me) result(r) Interface to destroy an Environment object Arguments Type Intent Optional Attributes Name class( Environment ) :: me Return Value type(Result) abstract interface private function updateEnvironment (me, t) result(r) Interface to perform simulations in Environment Arguments Type Intent Optional Attributes Name class( Environment ) :: me integer :: t Return Value type(Result) Derived Types type, public, abstract :: Environment Components Type Visibility Attributes Name Initial integer, public, allocatable :: gridSize (:) type(GridCellElement), public, allocatable :: colGridCells (:,:) Type-Bound Procedures procedure(createEnvironment), public :: create procedure(destroyEnvironment), public :: destroy procedure(updateEnvironment), public :: update","tags":"","loc":"module/spcenvironment.html"},{"title":"classEnvironment1 – NanoFASE","text":"Uses: mo_netcdf Globals UtilModule spcEnvironment ResultModule classGridCell1 Derived Types Environment1 Functions createEnvironment1 destroyEnvironment1 updateEnvironment1 Derived Types type, public, extends(Environment) :: Environment1 Type-Bound Procedures procedure, public :: create => createEnvironment1 procedure, public :: destroy => destroyEnvironment1 procedure, public :: update => updateEnvironment1 Functions private function createEnvironment1 (me) result(r) Create the environment, which sets up the grid and river structure.\n The Environment instance must be a target so that SubRiver inflows\n can point to another SubRiver object ( see here ) Arguments Type Intent Optional Attributes Name class( Environment1 ), target :: me This Environment instace. Must be target so SubRivers can be pointed at. Return Value type(Result) Result object to return private function destroyEnvironment1 (me) result(r) Destroy the Environment instance Arguments Type Intent Optional Attributes Name class( Environment1 ) :: me Return Value type(Result) private function updateEnvironment1 (me, t) result(r) Perform simulations for the Environment Arguments Type Intent Optional Attributes Name class( Environment1 ) :: me This Environment instance integer :: t Current time step Return Value type(Result)","tags":"","loc":"module/classenvironment1.html"},{"title":"classBedSedimentLayer1 – NanoFASE","text":"Uses: spcBedSedimentLayer Globals UtilModule ResultModule ErrorInstanceModule class definition for BedSedimentLayer1 Derived Types BedSedimentLayer1 Functions createBedSedimentLayer1 destroyBedSedimentLayer1 addSediment1 removeSediment1 Derived Types type, public, extends(BedSedimentLayer) :: BedSedimentLayer1 Type-Bound Procedures procedure, public :: create => createBedSedimentLayer1 procedure, public :: destroy => destroyBedSedimentLayer1 procedure, public :: addSediment => addSediment1 procedure, public :: removeSediment => removeSediment1 Functions public function createBedSedimentLayer1 (Me, n, nsc, FSType, C_tot, f_comp, pd_comp, Porosity, V_f, M_f) result(r) initialise a BedSedimentLayer object:\n  - sets number of particle size classes\n  - reads in fixed layer volume\n  - reads in volumes of fine sediment and water in each size class\n  - sets volume of coarse material Arguments Type Intent Optional Attributes Name class( BedSedimentLayer1 ) :: Me the BedSedimentLayer instance character(len=256) :: n a name for the object integer, intent(in) :: nsc the number of particle size classes integer, intent(in) :: FSType the type identification number of the FineSediment(s) real(kind=dp), intent(in) :: C_tot the total volume of the layer real(kind=dp), intent(in) :: f_comp (:,:) set of fractional compositions. Index 1 = size class, Index 2 = compositional fraction real(kind=dp), intent(in), allocatable :: pd_comp (:) set of fractional particle densities real(kind=dp), intent(in), optional :: Porosity layer porosity, if being used to define layer real(kind=dp), intent(in), optional :: V_f (:) set of fine sediment volumes, if being used to define layer real(kind=dp), intent(in), optional :: M_f (:) set of fine sediment masses, if being used to define layer Return Value type(Result) The Result object. public function destroyBedSedimentLayer1 (Me) result(r) destroy this object Arguments Type Intent Optional Attributes Name class( BedSedimentLayer1 ) :: Me the BedSedimentLayer instance Return Value type(Result) The Result object public function addSediment1 (Me, S, F) result(r) add sediment and water to this layer Arguments Type Intent Optional Attributes Name class( BedSedimentLayer1 ) :: Me the BedSedimentLayer instance integer, intent(in) :: S the particle size class type(FineSediment1), intent(inout) :: F FineSediment - holds material to be added Return Value type(Result) The Result object public function removeSediment1 (Me, S, G) result(r) remove sediment and water from this layer Arguments Type Intent Optional Attributes Name class( BedSedimentLayer1 ) :: Me integer, intent(in) :: S type(FineSediment1), intent(in) :: G Return Value type(Result1D)","tags":"","loc":"module/classbedsedimentlayer1.html"},{"title":"spcBedSedimentLayer – NanoFASE","text":"Uses: Globals ResultModule ErrorInstanceModule classFineSediment1 abstract superclass definition for BedSedimentLayer\n defines the properties and methods shared by all BedSedimentLayer objects\n objects of this class cannot be instantiated, only objects of its subclasses Abstract Interfaces createBedSedimentLayer destroyBedSedimentLayer addSedimentToLayer RemoveSedimentFromLayer Derived Types FineSedimentElement BedSedimentLayer Functions GetAf GetAw GetCf GetCw GetvolSLR GetMflayer GetCflayer GetVflayer GetVwlayer GetCwlayer GetVmlayer GetVlayer Abstract Interfaces abstract interface public function createBedSedimentLayer (Me, n, nsc, FSType, C_tot, f_comp, pd_comp, Porosity, V_f, M_f) result(r) create a BedSedimentLayer object and its incorporated BedSediment objects:\n  - sets number of particle size classes\n  - reads in fixed layer volume\n  - reads in volumes of fine sediment and water in each size class\n  - sets volume of coarse material Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ) :: Me the BedSedimentLayer instance character(len=256) :: n a name for the object integer, intent(in) :: nsc the number of particle size classes integer, intent(in) :: FSType the type identification number of the FineSediment(s) real(kind=dp), intent(in) :: C_tot the total volume of the layer real(kind=dp), intent(in) :: f_comp (:,:) set of fractional compositions. Index 1 = size class, Index 2 = compositional fraction real(kind=dp), intent(in), allocatable :: pd_comp (:) set of fractional particle densities real(kind=dp), intent(in), optional :: Porosity layer porosity, if being used to define layer real(kind=dp), intent(in), optional :: V_f (:) set of fine sediment volumes, if being used to define layer real(kind=dp), intent(in), optional :: M_f (:) set of fine sediment masses, if being used to define layer Return Value type(Result) The Result object. abstract interface public function destroyBedSedimentLayer (Me) result(r) destroy this object Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ) :: Me Return Value type(Result) abstract interface public function addSedimentToLayer (Me, S, F) result(r) add sediment and water to this layer Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ) :: Me the BedSedimentLayer instance integer, intent(in) :: S the particle size class type(FineSediment1), intent(inout) :: F FineSediment - holds material to be added Return Value type(Result) The Result object abstract interface public function RemoveSedimentFromLayer (Me, S, G) result(r) remove sediment and water from this layer Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ) :: Me the BedSedimentLayer instance integer, intent(in) :: S the particle size class type(FineSediment1), intent(in) :: G fine sediment to be removed; returns fine sediment that could not be removed Return Value type(Result1D) The Result object. Result%data(1) = fine sediment that was removed; Result%data(2) = fine sediment that could not be removed Derived Types type, public :: FineSedimentElement Components Type Visibility Attributes Name Initial class(FineSediment1), public, allocatable :: item Storing polymorphic class(FineSediment) in derived type so that a set of type, public, abstract :: BedSedimentLayer type declaration for superclass Components Type Visibility Attributes Name Initial character(len=256), public :: name a name for the object real(kind=dp), public, allocatable :: C_f_l (:) capacity for fine sediment [m3 m-2] real(kind=dp), public, allocatable :: C_w_l (:) capacity for water [m3 m-2] class( FineSedimentElement ), public, allocatable :: colFineSediment (:) collection of FineSediment objects real(kind=dp), public :: C_total total capacity [m3 m-2] real(kind=dp), public :: V_c coarse material volume [m3 m-2] real(kind=dp), public, allocatable :: pd_comp (:) particle densities of sediment components [kg m-3] integer, public :: nSizeClasses number of sediment size classes integer, public :: nfComp number of fractional composition terms for sediment integer, public :: allst array allocation status Type-Bound Procedures procedure, public :: A_f => GetAf procedure, public :: A_w => GetAw procedure, public :: C_f => GetCf procedure, public :: C_w => GetCw procedure, public :: volSLR => GetvolSLR procedure, public :: C_f_layer => GetCflayer procedure, public :: M_f_layer => GetMflayer procedure, public :: V_f_layer => GetVflayer procedure, public :: V_w_layer => GetVwlayer procedure, public :: C_w_layer => GetCwlayer procedure, public :: V_m_layer => GetVmlayer procedure, public :: V_layer => GetVlayer procedure(createBedSedimentLayer), public :: create procedure(destroyBedSedimentLayer), public :: destroy procedure(addSedimentToLayer), public :: AddSediment procedure(RemoveSedimentFromLayer), public :: RemoveSediment Functions public pure function GetAf (Me, s) result(A_f) return the available capacity for fine sediment of a specified size class\n compute capacity Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance integer, intent(in) :: s size class for which to retrieve available capacity Return Value real(kind=dp) return value public pure function GetAw (Me, s) result(A_w) return the available capacity for water associated with fine sediment of a specified size class\n compute capacity Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance integer, intent(in) :: s size class for which to retrieve available capacity Return Value real(kind=dp) return value public pure function GetCf (Me, s) result(C_f) return the total capacity for fine sediment of a specified size class\n compute capacity Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance integer, intent(in) :: s size class for which to retrieve available capacity Return Value real(kind=dp) return value public pure function GetCw (Me, s) result(C_w) returns the total capacity for water associated with fine sediment of a specified size class\n compute capacity Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance integer, intent(in) :: s size class for which to retrieve available capacity Return Value real(kind=dp) return value public pure function GetvolSLR (Me) result(volSLR) return the volumetric solid:liquid ratio for the layer Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value public pure function GetMflayer (Me) result(Mf_layer) return the sediment mass in the layer across all size fractions Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value public pure function GetCflayer (Me) result(Cf_layer) return the sediment capacity in the layer across all size fractions Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value public pure function GetVflayer (Me) result(Vf_layer) return the sediment volume in the layer across all size fractions Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value public pure function GetVwlayer (Me) result(Vw_layer) return the water volume in the layer across all sediment size fractions Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value public pure function GetCwlayer (Me) result(Cw_layer) return the water capacity in the layer across all sediment size fractions Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value public pure function GetVmlayer (Me) result(Vm_layer) return the fine sediment & water volume in the layer across all size fractions Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value public pure function GetVlayer (Me) result(V_layer) return the total volume of the layer Arguments Type Intent Optional Attributes Name class( BedSedimentLayer ), intent(in) :: Me the BedSedimentLayer instance Return Value real(kind=dp) return value","tags":"","loc":"module/spcbedsedimentlayer.html"},{"title":"classFineSediment1 – NanoFASE","text":"Uses: Globals ResultModule definition for class FineSediment1. Nonpolymorphic. Derived Types FineSediment1 Functions createFineSediment1 setFS1 getFSVol1 getFSMass1 getWVol1 pdens1 audit_fcomp1 Empty1 Mix1 Subroutines ClearAll1 Derived Types type, public :: FineSediment1 Components Type Visibility Attributes Name Initial character(len=256), public :: name a name for the object real(kind=dp), private :: M_f_l LOCAL fine sediment mass [kg m-2] real(kind=dp), private :: V_w_l LOCAL volume of water associated with fine sediment [m3 m-2] real(kind=dp), public, allocatable :: f_comp (:) fractional composition [-] real(kind=dp), public, allocatable :: pd_comp_l (:) LOCAL storage of fractional particle densities [kg m-3] integer, public :: nfComp LOCAL number of fractional composition terms integer, public :: allst array allocation status Type-Bound Procedures procedure, public :: create => createFineSediment1 procedure, public :: set => setFS1 procedure, public :: V_f => getFSVol1 procedure, public :: M_f => getFSMass1 procedure, public :: V_w => getWVol1 procedure, public :: rho_part => pdens1 procedure, public :: audit_comp => audit_fcomp1 procedure, public :: IsEmpty => Empty1 procedure, public :: ClearAll => ClearAll1 procedure, public :: mix => Mix1 Functions public function createFineSediment1 (Me, n, pd_comp_in) result(r) initialise this object Arguments Type Intent Optional Attributes Name class( FineSediment1 ) :: Me self-reference character(len=256) :: n a name identifier for the object; identifies this object uniquely real(kind=dp), intent(in), allocatable :: pd_comp_in (:) input array of particle densities for compositional fractions Return Value type(Result) Result object public function setFS1 (Me, Mf_in, Vf_in, Vw_in, f_comp_in) result(r) set the properties of the object Arguments Type Intent Optional Attributes Name class( FineSediment1 ) :: Me real(kind=dp), intent(in), optional :: Mf_in real(kind=dp), intent(in), optional :: Vf_in real(kind=dp), intent(in), optional :: Vw_in real(kind=dp), intent(in), optional :: f_comp_in (:) Return Value type(Result) public pure function getFSVol1 (Me) result(Vf) return the fine sediment volume [m3 m-2] Arguments Type Intent Optional Attributes Name class( FineSediment1 ), intent(in) :: Me self-reference Return Value real(kind=dp) the return value public pure function getFSMass1 (Me) result(Mf) return the fine sediment mass [kg m-2] Arguments Type Intent Optional Attributes Name class( FineSediment1 ), intent(in) :: Me self-reference Return Value real(kind=dp) the return value public pure function getWVol1 (Me) result(Vw) return the water volume [m3 m-2] Arguments Type Intent Optional Attributes Name class( FineSediment1 ), intent(in) :: Me self-reference Return Value real(kind=dp) the return value public pure function pdens1 (Me) result(rho_part) compute particle density from components and their densities Arguments Type Intent Optional Attributes Name class( FineSediment1 ), intent(in) :: Me self-reference Return Value real(kind=dp) return value: the particle density [kg m-3] public pure function audit_fcomp1 (Me) result(er) check that the array of fractional compositions sums to unity Arguments Type Intent Optional Attributes Name class( FineSediment1 ), intent(in) :: Me self-reference Return Value type(ErrorInstance) ErrorInstance object, returns error if t_fcomp /= 1 public pure function Empty1 (Me) result(t) check whether this object contains any fine sediment or water of the specified size class Arguments Type Intent Optional Attributes Name class( FineSediment1 ), intent(in) :: Me self-reference Return Value logical return value. True= V_f/M_f = V_w = 0. False= V_f/M_f > 0 .or. V_w > 0 public function Mix1 (Me, FS) result(r) mix two FineSediment objects together Arguments Type Intent Optional Attributes Name class( FineSediment1 ) :: Me self-reference type( FineSediment1 ), intent(in) :: FS FineSediment1 to be mixed with this one Return Value type(Result0D) Result object Subroutines public subroutine ClearAll1 (Me) clear all properties Arguments Type Intent Optional Attributes Name class( FineSediment1 ) :: Me the FineSediment instance","tags":"","loc":"module/classfinesediment1.html"},{"title":"spcFineSediment – NanoFASE","text":"Uses: Globals netcdf mo_netcdf ResultModule ErrorInstanceModule abstract superclass definition for FineSediment\n defines the properties and methods shared by all BedSedimentLayer objects\n objects of this class cannot be instantiated, only objects of its subclasses Abstract Interfaces ClearAll createFineSediment setFSVol setFSMass getFSVol getFSMass getWVol pdens Audit_fcomp Empty Derived Types FineSediment Abstract Interfaces abstract interface public subroutine ClearAll (Me) clear all fine sediment and water from the object Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference abstract interface public function createFineSediment (Me, n, pd_comp_in) result(r) initialise this object Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference character(len=256) :: n a name for the object real(kind=dp), intent(in), allocatable :: pd_comp_in (:) input array of particle densities for compositional fractions Return Value type(Result) Result object abstract interface public function setFSVol (Me, Vf_in, Vw_in, f_comp_in) result(r) set the properties, using fine sediment volume [m3 m-2] Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference real(kind=dp), optional :: Vf_in the fine sediment volume real(kind=dp), optional :: Vw_in the water volume real(kind=dp), optional allocatable :: f_comp_in (:) input fractional composition. Optional; if not present, stored composition is used Return Value type(Result) Result object abstract interface public function setFSMass (Me, Mf_in, Vw_in, f_comp_in) result(r) set the properties, using fine sediment mass [kg m-2] Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference real(kind=dp), optional :: Mf_in the fine sediment mass real(kind=dp), optional :: Vw_in the water volume real(kind=dp), optional allocatable :: f_comp_in (:) input fractional composition. Optional; if not present, stored composition is used Return Value type(Result) Result object abstract interface public function getFSVol (Me) result(Vf) return the fine sediment volume [m3 m-2] Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference Return Value real(kind=dp) the return value abstract interface public function getFSMass (Me) result(Mf) return the fine sediment mass [kg m-2] Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference Return Value real(kind=dp) the return value abstract interface public function getWVol (Me) result(Vw) return the water volume [m3 m-2] Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference Return Value real(kind=dp) the return value abstract interface public function pdens (Me) result(rp) return the particle density [kg m-3] Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference Return Value real(kind=dp) return value: the particle density [kg m-3] abstract interface public function Audit_fcomp (Me) audit the fractional composition Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference Return Value real abstract interface public function Empty (Me) result(t) check whether this object contains any fine sediment or water of the specified size class Arguments Type Intent Optional Attributes Name class( FineSediment ) :: Me self-reference Return Value logical Derived Types type, public, abstract :: FineSediment type declaration for superclass Components Type Visibility Attributes Name Initial character(len=256), public :: name a name for the object real(kind=dp), public :: M_f_l fine sediment mass [kg m-2] real(kind=dp), public :: V_w_l LOCAL volume of water associated with fine sediment [m3 m-2] real(kind=dp), public, allocatable :: f_comp (:) fractional composition [-] real(kind=dp), public, allocatable :: pd_comp_l (:) LOCAL storage of fractional particle densities [kg m-3] integer, public :: NFComp LOCAL number of fractional composition terms Type-Bound Procedures procedure(createFineSediment), public :: create procedure(setFSVol), public :: SetV procedure(setFSMass), public :: SetM procedure(getFSVol), public :: V_f procedure(getFSMass), public :: M_f procedure(getWVol), public :: V_w procedure(pdens), public :: rho_part procedure(Audit_fcomp), public :: audit_comp procedure(Empty), public :: IsEmpty procedure(ClearAll), public :: Clear","tags":"","loc":"module/spcfinesediment.html"},{"title":"classRiverReach1 – NanoFASE","text":"Uses: mo_netcdf Globals UtilModule ResultModule ErrorInstanceModule spcRiverReach Module responsible for the RiverReach1 object Derived Types RiverReach1 Functions createRiverReach1 destroyRiverReach1 update1 calculateWidth1 calculateDepth1 calculateVelocity1 calculateSettlingVelocity1 calculateVolume1 calculateArea1 Derived Types type, public, extends(RiverReach) :: RiverReach1 RiverReach1 object is responsible for sediment transport along river and\n sediment deposition to bed sediment. Type-Bound Procedures procedure, public :: create => createRiverReach1 procedure, public :: destroy => destroyRiverReach1 procedure, public :: update => update1 procedure, public :: calculateWidth => calculateWidth1 procedure, public :: calculateDepth => calculateDepth1 procedure, public :: calculateVelocity => calculateVelocity1 procedure, public :: calculateSettlingVelocity => calculateSettlingVelocity1 procedure, public :: calculateArea => calculateArea1 procedure, public :: calculateVolume => calculateVolume1 Functions private function createRiverReach1 (me, x, y, s, r, l, QrunoffTimeSeries) result(res) Create a RiverReach with x, y, s, r coordinates from the datafile. Arguments Type Intent Optional Attributes Name class( RiverReach1 ) :: me The RiverReach1 instance. integer :: x Containing GridCell x-position index. integer :: y Containing GridCell y-position index. integer :: s Containing SubRiver index. integer :: r RiverReach index. real(kind=dp) :: l Length of the RiverReach (without meandering). real(kind=dp), allocatable :: QrunoffTimeSeries (:) Any GridCell runoff (that has already been split to the correct RiverReach size) Return Value type(Result) The Result object. private function destroyRiverReach1 (me) result(r) Destroy this RiverReach1 Arguments Type Intent Optional Attributes Name class( RiverReach1 ) :: me This RiverReach1 instance Return Value type(Result) The Result object private function update1 (me, Qin, spmIn, t) result(r) Update the RiverReach on this timestep t, based on the inflow Q and SPM provided Arguments Type Intent Optional Attributes Name class( RiverReach1 ) :: me This RiverReach1 instance real(kind=dp) :: Qin Inflow to this reach real(kind=dp) :: spmIn (C%nSizeClassesSpm) Inflow SPM to this reach integer :: t What time step are we on? Return Value type(Result) Result object to return private pure function calculateWidth1 (me, Q) result(W) Calculate the width  W  of the river based on the discharge:\n \n      W = 1.22Q&#94;{0.557}\n \n References:\n - Dumont et al., 2012 - Allen et al., 1994 Arguments Type Intent Optional Attributes Name class( RiverReach1 ), intent(in) :: me The RiverReach1 instance real(kind=dp), intent(in) :: Q Grid cell discharge  Q  [m**3/s] Return Value real(kind=dp) The calculated width  W  [m] private pure function calculateDepth1 (me, W, S, Q) result(r) Calculate water depth from Manning's roughness coefficient,\n using Newton's method:\n \n      D_i = D_{i-1} - \\frac{f(D_{i-1})}{f'(D_{i-1})}\n \n where\n \n      f(D) = WD \\left( \\frac{WD}{W+2D} \\right)&#94;{2/3} \\frac{\\sqrt{S}}{n} - Q = 0\n \n and\n \n      f'(D) = \\frac{\\sqrt{S}}{n} \\frac{(DW)&#94;{5/3}(6D + 5W)}{3D(2D + W)&#94;{5/3}}\n  Arguments Type Intent Optional Attributes Name class( RiverReach1 ), intent(in) :: me The RiverReach1 instance. real(kind=dp), intent(in) :: W River width  W  [m]. real(kind=dp), intent(in) :: S River slope  S  [-]. real(kind=dp), intent(in) :: Q Flow rate  Q  [m3/s]. Return Value type(Result0D) The Result object. private pure function calculateVelocity1 (me, D, Q, W) result(v) Calculate the velocity of the river:\n \n      v = \\frac{Q}{WD}\n  Arguments Type Intent Optional Attributes Name class( RiverReach1 ), intent(in) :: me The RiverReach1 instance real(kind=dp), intent(in) :: D River depth  D  [m] real(kind=dp), intent(in) :: Q Flow rate  Q  [m**3/s] real(kind=dp), intent(in) :: W River width  W  [m] Return Value real(kind=dp) The calculated velocity  v  [m/s] private function calculateSettlingVelocity1 (me, d, rho_spm, T) result(W_spm) Calculate the settling velocity of sediment particles for an individual\n size class:\n \n      W_{text{spm}} = \\frac{\\nu}{d} d_{*}&#94;3 (38.1 + 0.93 d_{*}&#94;{12/7})&#94;{-7/8}\n \n where\n \n      d_{*} = \\left( \\frac{\\Delta g}{\\nu&#94;2} \\right)&#94;{1/3} d\n \n and\n \n      \\Delta = \\frac{\\rho_{\\text{spm}}}{\\rho} - 1\n \n Reference: Zhiyao et al, 2008 . Arguments Type Intent Optional Attributes Name class( RiverReach1 ), intent(in) :: me The RiverReach1 instance. real(kind=dp), intent(in) :: d Sediment particle diameter [m]. real(kind=dp), intent(in) :: rho_spm Sediment particle density [kg/m**3]. real(kind=dp), intent(in) :: T Temperature [C]. Return Value real(kind=dp) Calculated settling velocity [m/s]. private pure function calculateVolume1 (me, D, W, l, f_m) result(volume) Calculate the volume of a RiverReach, assuming a rectangular profile:\n \n      \\text{volume} = DWlf_m\n  Arguments Type Intent Optional Attributes Name class( RiverReach1 ), intent(in) :: me The RiverReach1 instance real(kind=dp), intent(in) :: D River depth [m] real(kind=dp), intent(in) :: W River width [m] real(kind=dp), intent(in) :: l River length, without meandering [m] real(kind=dp), intent(in) :: f_m Meandering factor [-] Return Value real(kind=dp) The calculated volume [m3] private pure function calculateArea1 (me, D, W) result(area) Calculate the area of a cross-section of the RiverReach, assuming\n a rectangular profile:\n \n      \\text{area} = DW\n  Arguments Type Intent Optional Attributes Name class( RiverReach1 ), intent(in) :: me The RiverReach1 instance real(kind=dp), intent(in) :: D River depth [m] real(kind=dp), intent(in) :: W River width [m] Return Value real(kind=dp) The calculated area [m3]","tags":"","loc":"module/classriverreach1.html"},{"title":"spcRiverReach – NanoFASE","text":"Uses: Globals netcdf mo_netcdf ResultModule ErrorInstanceModule Abstract Interfaces createRiverReach destroyRiverReach update calculateDepth calculateWidth calculateVolume calculateArea calculateVelocity calculateSettlingVelocity Derived Types RiverReach Functions getVolumeRiverReach getQOutRiverReach getSpmOutRiverReach Abstract Interfaces abstract interface public function createRiverReach (me, x, y, s, r, l, QrunoffTimeSeries) result(res) Arguments Type Intent Optional Attributes Name class( RiverReach ) :: me The RiverReach instance integer :: x GridCell, SubRiver and RiverReach identifiers integer :: y GridCell, SubRiver and RiverReach identifiers integer :: s GridCell, SubRiver and RiverReach identifiers integer :: r GridCell, SubRiver and RiverReach identifiers real(kind=dp) :: l The RiverReach length [m] real(kind=dp), allocatable :: QrunoffTimeSeries (:) Any initial runoff [m3/s] Return Value type(Result) The Result object abstract interface public function destroyRiverReach (Me) result(r) Arguments Type Intent Optional Attributes Name class( RiverReach ) :: Me The RiverReach instance Return Value type(Result) The Result object to return abstract interface public function update (me, Qin, spmIn, t) result(r) Arguments Type Intent Optional Attributes Name class( RiverReach ) :: me This RiverReach instance real(kind=dp) :: Qin Inflow to this reach [m3/timestep] real(kind=dp) :: spmIn (C%nSizeClassesSpm) Inflow SPM to this reach [kg/timestep] integer :: t What time step are we on? Return Value type(Result) The Result object abstract interface public pure function calculateDepth (Me, W, S, Q) result(r) Arguments Type Intent Optional Attributes Name class( RiverReach ), intent(in) :: Me The RiverReach instance real(kind=dp), intent(in) :: W River width [m] real(kind=dp), intent(in) :: S River slope [-] real(kind=dp), intent(in) :: Q Flow rate [m3/s] Return Value type(Result0D) The result object abstract interface public function calculateWidth (Me, Q) result(W) Arguments Type Intent Optional Attributes Name class( RiverReach ), intent(in) :: Me The RiverReach instance real(kind=dp), intent(in) :: Q Flow rate [m3/s] Return Value real(kind=dp) Calculated width [m] abstract interface public pure function calculateVolume (me, D, W, l, f_m) result(volume) Arguments Type Intent Optional Attributes Name class( RiverReach ), intent(in) :: me The RiverReach instance real(kind=dp), intent(in) :: D River depth [m] real(kind=dp), intent(in) :: W River width [m] real(kind=dp), intent(in) :: l River length, without meandering [m] real(kind=dp), intent(in) :: f_m Meandering factor [-] Return Value real(kind=dp) Calculated volume [m3] abstract interface public pure function calculateArea (me, D, W) result(area) Arguments Type Intent Optional Attributes Name class( RiverReach ), intent(in) :: me The RiverReach instance real(kind=dp), intent(in) :: D River depth [m] real(kind=dp), intent(in) :: W River width [m] Return Value real(kind=dp) Calculated area [m2] abstract interface public pure function calculateVelocity (me, D, Q, W) result(v) Arguments Type Intent Optional Attributes Name class( RiverReach ), intent(in) :: me The RiverReach instance real(kind=dp), intent(in) :: D River depth [m] real(kind=dp), intent(in) :: Q Flow rate [m3/s] real(kind=dp), intent(in) :: W River width [m] Return Value real(kind=dp) The calculated velocity [m/s] abstract interface public function calculateSettlingVelocity (me, d, rho_spm, T) result(W_spm) Arguments Type Intent Optional Attributes Name class( RiverReach ), intent(in) :: me The RiverReach instance real(kind=dp), intent(in) :: d Sediment particle diameter [m] real(kind=dp), intent(in) :: rho_spm Sediment particle density [kg/m3] real(kind=dp), intent(in) :: T Temperature [C] Return Value real(kind=dp) Calculated settling velocity [m/s] Derived Types type, public, abstract :: RiverReach Components Type Visibility Attributes Name Initial character(len=256), public :: ref real(kind=dp), public :: S real(kind=dp), public :: Qin real(kind=dp), public :: Qout real(kind=dp), public :: Qrunoff real(kind=dp), public, allocatable :: QrunoffTimeSeries (:) real(kind=dp), public, allocatable :: spmIn (:) real(kind=dp), public, allocatable :: spmOut (:) real(kind=dp), public, allocatable :: m_spm (:) real(kind=dp), public, allocatable :: m_spmTimeSeries (:,:) real(kind=dp), public :: W real(kind=dp), public :: D real(kind=dp), public :: v real(kind=dp), public :: l real(kind=dp), public :: f_m = 1 real(kind=dp), public :: area real(kind=dp), public :: volume real(kind=dp), public, allocatable :: rho_spm (:) real(kind=dp), public :: n integer, public :: allst type(NcGroup), public :: ncGroup Type-Bound Procedures procedure(createRiverReach), public :: create procedure(destroyRiverReach), public :: destroy procedure(update), public :: update procedure(calculateDepth), public :: calculateDepth procedure(calculateWidth), public :: calculateWidth procedure(calculateVelocity), public :: calculateVelocity procedure(calculateSettlingVelocity), public :: calculateSettlingVelocity procedure(calculateVolume), public :: calculateVolume procedure(calculateArea), public :: calculateArea procedure, public :: getVolume => getVolumeRiverReach procedure, public :: getQOut => getQOutRiverReach procedure, public :: getSpmOut => getSpmOutRiverReach Functions public function getVolumeRiverReach (me) result(volume) Return the volume of the RiverReach. Arguments Type Intent Optional Attributes Name class( RiverReach ) :: me Return Value real(kind=dp) public function getQOutRiverReach (me) result(Qout) Return the outflow. Arguments Type Intent Optional Attributes Name class( RiverReach ) :: me Return Value real(kind=dp) public function getSpmOutRiverReach (me) result(spmOut) Return the SPM discahrge. Arguments Type Intent Optional Attributes Name class( RiverReach ) :: me Return Value real(kind=dp)\n  (size(me%spmOut))","tags":"","loc":"module/spcriverreach.html"},{"title":"classSubRiver1 – NanoFASE","text":"Uses: Globals UtilModule netcdf mo_netcdf ResultModule ErrorInstanceModule spcSubRiver classRiverReach1 Interfaces SubRiver1 Derived Types SubRiver1 Functions newSubRiver1 createSubRiver1 destroySubRiver1 updateSubRiver1 finaliseUpdateSubRiver1 auditrefs Interfaces public interface SubRiver1 Interface so that we can create new SubRivers by sr = SubRiver1() public function newSubRiver1 (x, y, s, length, QrunoffTimeSeries) result(me) Return a newly-created SubRiver1 object. This is bound to SubRiver1 interface\n TODO: Do something with result object Arguments Type Intent Optional Attributes Name integer :: x Location of the SubRiver integer :: y Location of the SubRiver integer :: s Location of the SubRiver real(kind=dp) :: length Length of the SubRiver (without meandering) real(kind=dp), allocatable :: QrunoffTimeSeries (:) Any initial runoff from the hydrological model Return Value type( SubRiver1 ) The new SubRiver to return Derived Types type, public, extends(SubRiver) :: SubRiver1 Constructor Interface so that we can create new SubRivers by sr = SubRiver1() public  function newSubRiver1 (x, y, s, length, QrunoffTimeSeries) Return a newly-created SubRiver1 object. This is bound to SubRiver1 interface\n TODO: Do something with result object Type-Bound Procedures procedure, public :: create => createSubRiver1 procedure, public :: destroy => destroySubRiver1 procedure, public :: update => updateSubRiver1 procedure, public :: finaliseUpdate => finaliseUpdateSubRiver1 procedure, private :: auditrefs Functions public function newSubRiver1 (x, y, s, length, QrunoffTimeSeries) result(me) Return a newly-created SubRiver1 object. This is bound to SubRiver1 interface\n TODO: Do something with result object Arguments Type Intent Optional Attributes Name integer :: x Location of the SubRiver integer :: y Location of the SubRiver integer :: s Location of the SubRiver real(kind=dp) :: length Length of the SubRiver (without meandering) real(kind=dp), allocatable :: QrunoffTimeSeries (:) Any initial runoff from the hydrological model Return Value type( SubRiver1 ) The new SubRiver to return public function createSubRiver1 (me, x, y, s, length, QrunoffTimeSeries) result(r) Arguments Type Intent Optional Attributes Name class( SubRiver1 ) :: me type(integer), intent(in) :: x type(integer), intent(in) :: y type(integer), intent(in) :: s real(kind=dp) :: length real(kind=dp), allocatable :: QrunoffTimeSeries (:) Return Value type(Result) public function destroySubRiver1 (me) result(r) Arguments Type Intent Optional Attributes Name class( SubRiver1 ) :: me Return Value type(Result) public function updateSubRiver1 (me, t) result(r) Arguments Type Intent Optional Attributes Name class( SubRiver1 ) :: me integer :: t Return Value type(Result) public function finaliseUpdateSubRiver1 (me) result(r) Set the outflow and SPM mass from the temporary variables that were set by the\n routing procedure. This step is kept separate from the routing so that the\n wrong outflow isn't used as an inflow for another SubRiver whilst the SubRivers\n are looped through. Arguments Type Intent Optional Attributes Name class( SubRiver1 ) :: me This SubRiver1 instace Return Value type(Result) The Result object public function auditrefs (me) result(r) Arguments Type Intent Optional Attributes Name class( SubRiver1 ) :: me Return Value type(Result)","tags":"","loc":"module/classsubriver1.html"},{"title":"spcSubRiver – NanoFASE","text":"Uses: Globals netcdf mo_netcdf ResultModule ErrorInstanceModule spcRiverReach Abstract Interfaces createSubRiver destroySubRiver updateSubRiver finaliseUpdateSubRiver Derived Types RiverReachElement RoutingRef SubRiverPointer SubRiver SubRiverElement Functions getQOutSubRiver getSpmOutSubRiver getSpmOutBySizeClassSubRiver Abstract Interfaces abstract interface public function createSubRiver (me, x, y, s, length, QrunoffTimeSeries) result(r) Arguments Type Intent Optional Attributes Name class( SubRiver ) :: me type(integer), intent(in) :: x type(integer), intent(in) :: y type(integer), intent(in) :: s real(kind=dp) :: length real(kind=dp), allocatable :: QrunoffTimeSeries (:) Return Value type(Result) abstract interface public function destroySubRiver (me) result(r) Arguments Type Intent Optional Attributes Name class( SubRiver ) :: me Return Value type(Result) abstract interface public function updateSubRiver (me, t) result(r) Arguments Type Intent Optional Attributes Name class( SubRiver ) :: me integer :: t Return Value type(Result) abstract interface public function finaliseUpdateSubRiver (me) result(r) Arguments Type Intent Optional Attributes Name class( SubRiver ) :: me Return Value type(Result) Derived Types type, public :: RiverReachElement Components Type Visibility Attributes Name Initial class(RiverReach), public, allocatable :: item type, public :: RoutingRef Components Type Visibility Attributes Name Initial type(integer), public :: gridX type(integer), public :: gridY type(integer), public :: subRiver type, public :: SubRiverPointer Components Type Visibility Attributes Name Initial class( SubRiver ), public, pointer :: item => null() type, public, abstract :: SubRiver Components Type Visibility Attributes Name Initial character(len=100), public :: ref real(kind=dp), public :: length type( RoutingRef ), public, allocatable :: inflowRefs (:) integer, public :: nInflows integer, public :: nReaches integer, public, allocatable :: reachTypes (:) real(kind=dp), public :: Qin real(kind=dp), public :: Qout real(kind=dp), public, allocatable :: QrunoffTimeSeries (:) real(kind=dp), public :: Qrunoff real(kind=dp), public :: tmpQout real(kind=dp), public, allocatable :: spmIn (:) real(kind=dp), public, allocatable :: spmOut (:) real(kind=dp), public, allocatable :: tmpSpmOut (:) real(kind=dp), public, allocatable :: m_spm (:) real(kind=dp), public, allocatable :: tmpm_spm (:) integer, public :: allst type( RiverReachElement ), public, allocatable :: colReaches (:) type( SubRiverPointer ), public, allocatable :: inflows (:) Type-Bound Procedures procedure(createSubRiver), public :: create procedure(destroySubRiver), public :: destroy procedure(updateSubRiver), public :: update procedure(finaliseUpdateSubRiver), public :: finaliseUpdate procedure, public :: getQOut => getQOutSubRiver procedure, public :: getSpmOut => getSpmOutSubRiver procedure, public :: getSpmOutBySizeClass => getSpmOutBySizeClassSubRiver type, public :: SubRiverElement Components Type Visibility Attributes Name Initial class( SubRiver ), public, allocatable :: item Functions public function getQOutSubRiver (me) result(QOut) Get the discharge from the SubRiver. Arguments Type Intent Optional Attributes Name class( SubRiver ) :: me This SubRiver instance Return Value real(kind=dp) Discharge out of the SubRiver [m3] public function getSpmOutSubRiver (me) result(spmOut) Get the SPM discharge from the SubRiver. Arguments Type Intent Optional Attributes Name class( SubRiver ) :: me This SubRiver instance Return Value real(kind=dp)\n  (size(me%spmOut)) SPM discharge for all size classes [kg] public function getSpmOutBySizeClassSubRiver (me, n) result(spmOut) Get the SPM discharge from the SubRiver, for a given size class. Arguments Type Intent Optional Attributes Name class( SubRiver ) :: me This SubRiver instance integer :: n Size class Return Value real(kind=dp) SPM discharge [kg]","tags":"","loc":"module/spcsubriver.html"},{"title":"classGridCell1 – NanoFASE","text":"Uses: Globals UtilModule mo_netcdf ResultModule ErrorInstanceModule spcGridCell classSoilProfile1 classSubRiver1 Interfaces GridCell1 Derived Types GridCell1 Functions newGridCell1 createGridCell1 destroyGridCell1 updateGridCell1 finaliseUpdateGridCell1 parseInputDataGridCell1 Interfaces public interface GridCell1 Interface so that we can create new GridCells by gc = GridCell1() public function newGridCell1 (x, y, isEmpty) result(me) Return a newly-created GridCell1 object.\n TODO: Do something with result object Arguments Type Intent Optional Attributes Name integer :: x Location of the GridCell integer :: y Location of the GridCell logical, optional :: isEmpty Is anything to be simulated in this GridCell? Return Value type( GridCell1 ) The new GridCell to return Derived Types type, public, extends(GridCell) :: GridCell1 Constructor Interface so that we can create new GridCells by gc = GridCell1() public  function newGridCell1 (x, y, isEmpty) Return a newly-created GridCell1 object.\n TODO: Do something with result object Type-Bound Procedures procedure, public :: create => createGridCell1 procedure, public :: destroy => destroyGridCell1 procedure, public :: update => updateGridCell1 procedure, public :: finaliseUpdate => finaliseUpdateGridCell1 procedure, public :: parseInputData => parseInputDataGridCell1 Functions public function newGridCell1 (x, y, isEmpty) result(me) Return a newly-created GridCell1 object.\n TODO: Do something with result object Arguments Type Intent Optional Attributes Name integer :: x Location of the GridCell integer :: y Location of the GridCell logical, optional :: isEmpty Is anything to be simulated in this GridCell? Return Value type( GridCell1 ) The new GridCell to return public function createGridCell1 (me, x, y, isEmpty) result(r) Create a GridCell with coordinates x and y. Arguments Type Intent Optional Attributes Name class( GridCell1 ) :: me The GridCell instance. integer :: x Location of the GridCell integer :: y Location of the GridCell logical, optional :: isEmpty Is anything to be simulated in this GridCell? Return Value type(Result) The Result object to return. public function destroyGridCell1 (Me) result(r) Arguments Type Intent Optional Attributes Name class( GridCell1 ) :: Me The GridCell instance. Return Value type(Result) The Result object public function updateGridCell1 (Me, t) result(r) Perform the simulations required for an individual timestep t. Arguments Type Intent Optional Attributes Name class( GridCell1 ) :: Me integer :: t Return Value type(Result) public function finaliseUpdateGridCell1 (me) result(r) Set the outflow from the temporary outflow variables that were setting by the\n update procedure. This step is kept separate from the routing so that the\n wrong outflow isn't used as an inflow for another SubRiver whilst the SubRivers\n are looped through. Arguments Type Intent Optional Attributes Name class( GridCell1 ) :: me This SubRiver1 instace Return Value type(Result) The Result object public function parseInputDataGridCell1 (me) result(r) Get the data from the input file and set object properties\n accordingly, including allocation of arrays that depend on\n input data. Arguments Type Intent Optional Attributes Name class( GridCell1 ) :: me This GridCell1 object Return Value type(Result) The result object","tags":"","loc":"module/classgridcell1.html"},{"title":"spcGridCell – NanoFASE","text":"Uses: Globals mo_netcdf ResultModule ErrorInstanceModule spcSubRiver spcSoilProfile classDiffuseSource classPointSource Abstract Interfaces createGridCell destroyGridCell updateGridCell finaliseUpdateGridCell Derived Types PointSourceElement DiffuseSourceElement GridCell GridCellElement Abstract Interfaces abstract interface public function createGridCell (me, x, y, isEmpty) result(r) Arguments Type Intent Optional Attributes Name class( GridCell ) :: me The GridCell instance. integer :: x The (x,y) position of the GridCell. integer :: y The (x,y) position of the GridCell. logical, optional :: isEmpty Is anything to be simulated for this GridCell? Return Value type(Result) abstract interface public function destroyGridCell (me) result(r) Arguments Type Intent Optional Attributes Name class( GridCell ) :: me Return Value type(Result) abstract interface public function updateGridCell (me, t) result(r) Arguments Type Intent Optional Attributes Name class( GridCell ) :: me integer :: t Return Value type(Result) abstract interface public function finaliseUpdateGridCell (me) result(r) Arguments Type Intent Optional Attributes Name class( GridCell ) :: me Return Value type(Result) Derived Types type, public :: PointSourceElement Components Type Visibility Attributes Name Initial class(PointSource), public, allocatable :: item type, public :: DiffuseSourceElement Components Type Visibility Attributes Name Initial class(DiffuseSource), public, allocatable :: item type, public, abstract :: GridCell Components Type Visibility Attributes Name Initial character(len=256), public :: ref type(NcGroup), public :: ncGroup type(integer), public :: gridX type(integer), public :: gridY real(kind=dp), public :: area type(SubRiverElement), public, allocatable :: colSubRivers (:) type(SoilProfileElement), public, allocatable :: colSoilProfiles (:) type( PointSourceElement ), public, allocatable :: colPointSources (:) type( DiffuseSourceElement ), public :: objDiffuseSource type(integer), public :: nSubRivers = 0 type(integer), public :: nSoilProfiles = 0 type(integer), public :: nPointSources = 0 type(logical), public :: DiffS real(kind=dp), public, allocatable :: QrunoffTimeSeries (:) real(kind=dp), public :: Qrunoff real(kind=dp), public :: slope real(kind=dp), public :: n_river real(kind=dp), public, allocatable :: erodedSediment (:) logical, public :: isEmpty = .false. Type-Bound Procedures procedure(createGridCell), public :: create procedure(destroyGridCell), public :: destroy procedure(updateGridCell), public :: update procedure(finaliseUpdateGridCell), public :: finaliseUpdate type, public :: GridCellElement Components Type Visibility Attributes Name Initial class( GridCell ), public, allocatable :: item","tags":"","loc":"module/spcgridcell.html"},{"title":"classBiota1 – NanoFASE","text":"Uses: spcBiota class definition for Biota1 Derived Types objBiota1 Subroutines createObjBiota1 destroyObjBiota1 Derived Types type, public, extends(Biota) :: objBiota1 type declaration for class - extends interface Type-Bound Procedures procedure, public :: create => createObjBiota1 procedure, public :: destroy => destroyObjBiota1 Subroutines public subroutine createObjBiota1 (Me) constructor method Arguments Type Intent Optional Attributes Name class( objBiota1 ) :: Me This Biota1 instance public subroutine destroyObjBiota1 (Me) finaliser method Arguments Type Intent Optional Attributes Name class( objBiota1 ) :: Me","tags":"","loc":"module/classbiota1.html"},{"title":"classBiota2 – NanoFASE","text":"Uses: spcBiota class definition for Biota2 Derived Types objBiota2 Subroutines createObjBiota2 destroyObjBiota2 Derived Types type, public, extends(Biota) :: objBiota2 type declaration for class - extends interface Type-Bound Procedures procedure, public :: create => createObjBiota2 procedure, public :: destroy => destroyObjBiota2 Subroutines public subroutine createObjBiota2 (Me) constructor method Arguments Type Intent Optional Attributes Name class( objBiota2 ) :: Me This Biota2 instance public subroutine destroyObjBiota2 (Me) finaliser method Arguments Type Intent Optional Attributes Name class( objBiota2 ) :: Me This Biota2 instance","tags":"","loc":"module/classbiota2.html"},{"title":"spcBiota – NanoFASE","text":"superclass definition for Biota Derived Types Biota Subroutines createBiota destroyBiota Derived Types type, public, abstract :: Biota type declaration for class Components Type Visibility Attributes Name Initial character(len=256), public :: name Type-Bound Procedures procedure, public :: create => createBiota procedure, public :: destroy => destroyBiota Subroutines public subroutine createBiota (me) Arguments Type Intent Optional Attributes Name class( Biota ) :: me public subroutine destroyBiota (me) Arguments Type Intent Optional Attributes Name class( Biota ) :: me","tags":"","loc":"module/spcbiota.html"},{"title":"classReactor1 – NanoFASE","text":"Uses: spcReactor Derived Types objReactor1 Subroutines newObjReactor1 destroyObjReactor1 Derived Types type, public, extends(Reactor) :: objReactor1 Type-Bound Procedures procedure, public :: create => newObjReactor1 procedure, public :: destroy => destroyObjReactor1 Subroutines public subroutine newObjReactor1 (Me) Arguments Type Intent Optional Attributes Name class( objReactor1 ) :: Me public subroutine destroyObjReactor1 (Me) Arguments Type Intent Optional Attributes Name class( objReactor1 ) :: Me","tags":"","loc":"module/classreactor1.html"},{"title":"classReactor2 – NanoFASE","text":"Uses: spcReactor Derived Types objReactor2 Subroutines newObjReactor2 destroyObjReactor2 Derived Types type, public, extends(Reactor) :: objReactor2 Type-Bound Procedures procedure, public :: create => newObjReactor2 procedure, public :: destroy => destroyObjReactor2 Subroutines public subroutine newObjReactor2 (Me) Arguments Type Intent Optional Attributes Name class( objReactor2 ) :: Me public subroutine destroyObjReactor2 (Me) Arguments Type Intent Optional Attributes Name class( objReactor2 ) :: Me","tags":"","loc":"module/classreactor2.html"},{"title":"spcReactor – NanoFASE","text":"Derived Types Reactor Subroutines createReactor destroyReactor Derived Types type, public, abstract :: Reactor Components Type Visibility Attributes Name Initial character(len=256), public :: name Type-Bound Procedures procedure, public :: create => createReactor procedure, public :: destroy => destroyReactor Subroutines public subroutine createReactor (me) Arguments Type Intent Optional Attributes Name class( Reactor ) :: me public subroutine destroyReactor (me) Arguments Type Intent Optional Attributes Name class( Reactor ) :: me","tags":"","loc":"module/spcreactor.html"},{"title":"classBedSediment1 – NanoFASE","text":"Uses: Globals ResultModule spcBedSediment classBedSedimentLayer1 Derived Types BedSediment1 Functions createBedSediment1 destroyBedSediment1 resuspendSediment1 depositSediment1 Derived Types type, public, extends(BedSediment) :: BedSediment1 Type-Bound Procedures procedure, public :: create => createBedSediment1 procedure, public :: destroy => destroyBedSediment1 procedure, public :: deposit => depositSediment1 procedure, public :: resuspend => resuspendSediment1 Functions private function createBedSediment1 (Me, n, ln, nsc, nl, bslType, C_tot, f_comp, pd_comp, Porosity, V_f, M_f) result(r) Create a BedSediment object. Arguments Type Intent Optional Attributes Name class( BedSediment1 ) :: Me self-reference character(len=256), intent(in) :: n a name for the object character(len=256), allocatable :: ln (:) names for the layers. Index = layer integer, intent(in) :: nsc the number of particle size classes integer, intent(in) :: nl the number of layers integer, intent(in) :: bslType the type identification number of the BedSedimentLayer(s) real(kind=dp), intent(in), allocatable :: C_tot (:) the total volume of each layer. Index = layer real(kind=dp), intent(in), allocatable :: f_comp (:,:,:) set of fractional compositions\n Index 1 = size class, Index 2 = compositional fraction, Index 3 = layer real(kind=dp), intent(in), allocatable :: pd_comp (:) set of fractional particle densities\n Index 1 = size class real(kind=dp), intent(in), optional :: Porosity (:) layer porosity, if being used to define layer\n Index 1 = layer real(kind=dp), intent(in), optional allocatable :: V_f (:,:) set of fine sediment volumes, if being used to define layers\n Index 1 = size class, Index 2 = layer real(kind=dp), intent(in), optional allocatable :: M_f (:,:) set of fine sediment masses, if being used to define layers\n Index 1 = size class, Index 2 = layer Return Value type(Result) returned Result object private function destroyBedSediment1 (Me) result(r) deallocate all allocatable variables and call destroy methods for all enclosed objects Arguments Type Intent Optional Attributes Name class( BedSediment1 ) :: Me self-reference Return Value type(Result) returned Result object private function resuspendSediment1 (Me, M_resusp, FS) result(r) compute resuspension from bed sediment Arguments Type Intent Optional Attributes Name class( BedSediment1 ) :: Me real(kind=dp), intent(in), allocatable :: M_resusp (:) type(FineSediment1), intent(out), allocatable :: FS (:,:) Return Value type(Result) private function depositSediment1 (Me, M_dep, f_comp_dep, V_w_tot) result(r) compute deposition to bed sediment, including burial and downward shifting of fine sediment and water Arguments Type Intent Optional Attributes Name class( BedSediment1 ) :: Me self-reference real(kind=dp), intent(in), allocatable :: M_dep (:) Depositing sediment mass by size class real(kind=dp), intent(in), allocatable :: f_comp_dep (:,:) Depositing sediment fractional composition by size class\n Index 1 = size class, Index 2 = compositional fraction real(kind=dp), intent(out) :: V_w_tot water requirement from the water column [m3 m-2] Return Value type(Result) returned Result object","tags":"","loc":"module/classbedsediment1.html"},{"title":"classBedSediment2 – NanoFASE","text":"Uses: Globals ResultModule spcBedSediment Derived Types BedSediment2 Functions calculateResuspensionBedSediment2 calculateStreamPowerBedSediment2 Derived Types type, public, extends(BedSediment) :: BedSediment2 Type-Bound Procedures procedure, public :: Resuspension => calculateResuspensionBedSediment2 procedure, public :: StreamPower => calculateStreamPowerBedSediment2 Functions private function calculateResuspensionBedSediment2 (me, a, m_bed, alpha, omega, R_h, R_hmax) result(r) Calculate resuspension from bed sediment using Bussi :\n \n      m_{\\text{ent}} = a m_{\\text{bed}} \\alpha \\omega \\frac{R_\\text{h}}{R_{\\text{h,max}}}\n  Arguments Type Intent Optional Attributes Name class( BedSediment2 ) :: me real(kind=dp) :: a Calibration factor [s2/kg] real(kind=dp) :: m_bed Bed mass per unit area [kg/m2] real(kind=dp) :: alpha Proportion of size class that can be resuspended [-] real(kind=dp) :: omega Stream power per unit area of stream bed [J/s/m2] real(kind=dp) :: R_h Actual hydraulic radius [m] real(kind=dp) :: R_hmax Maximum hydraulic radius [m] Return Value type(Result0D) private function calculateStreamPowerBedSediment2 (me, rho_water, g, Q, W, S) result(r) Calculate the stream power (per unit area of stream bed) using Bagnold's\n stream power equation:\n \n      \\omega = \\frac{\\rho g Q S}{W}\n \n Reference: Bagnold, 1966 Arguments Type Intent Optional Attributes Name class( BedSediment2 ) :: me real(kind=dp) :: rho_water Density of water [kg/m3] real(kind=dp) :: g Gravitational acceleration [m/s] real(kind=dp) :: Q Discharge [m3/s] real(kind=dp) :: W River width [m] real(kind=dp) :: S River slope [m/m] Return Value type(Result0D)","tags":"","loc":"module/classbedsediment2.html"},{"title":"spcBedSediment – NanoFASE","text":"Uses: Globals ResultModule spcBedSedimentLayer classFineSediment1 abstract superclass definition for BedSediment\n defines the properties and methods shared by all BedSediment objects\n objects of this class cannot be instantiated, only objects of its subclasses Abstract Interfaces createBedSediment destroyBedSediment depositSediment resuspendSediment Derived Types BedSedimentLayerElement BedSediment Functions Get_Af_sediment Get_Cf_sediment Get_Aw_sediment Get_Cw_sediment Get_Mf_sediment Get_Mf_sed_all Abstract Interfaces abstract interface public function createBedSediment (Me, n, ln, nsc, nl, bslType, C_tot, f_comp, pd_comp, Porosity, V_f, M_f) result(r) Create a BedSediment object. Arguments Type Intent Optional Attributes Name class( BedSediment ) :: Me self-reference character(len=256), intent(in) :: n a name for the object character(len=256), allocatable :: ln (:) names for the layers. Index = layer integer, intent(in) :: nsc the number of particle size classes integer, intent(in) :: nl the number of layers integer, intent(in) :: bslType the type identification number of the BedSedimentLayer(s) real(kind=dp), intent(in), allocatable :: C_tot (:) the total volume of each layer. Index = layer real(kind=dp), intent(in), allocatable :: f_comp (:,:,:) set of fractional compositions\n Index 1 = size class, Index 2 = compositional fraction, Index 3 = layer real(kind=dp), intent(in), allocatable :: pd_comp (:) set of fractional particle densities\n Index 1 = size class real(kind=dp), intent(in), optional :: Porosity (:) layer porosity, if being used to define layer\n Index 1 = layer real(kind=dp), intent(in), optional allocatable :: V_f (:,:) set of fine sediment volumes, if being used to define layers\n Index 1 = size class, Index 2 = layer real(kind=dp), intent(in), optional allocatable :: M_f (:,:) set of fine sediment masses, if being used to define layers\n Index 1 = size class, Index 2 = layer Return Value type(Result) returned Result object abstract interface public function destroyBedSediment (Me) result(r) Arguments Type Intent Optional Attributes Name class( BedSediment ) :: Me self-reference Return Value type(Result) returned Result object abstract interface public function depositSediment (Me, M_dep, f_comp_dep, V_w_tot) result(r) compute deposition to bed sediment, including burial and downward shifting of fine sediment and water Arguments Type Intent Optional Attributes Name class( BedSediment ) :: Me self-reference real(kind=dp), intent(in), allocatable :: M_dep (:) Depositing sediment mass by size class real(kind=dp), intent(in), allocatable :: f_comp_dep (:,:) Depositing sediment fractional composition by size class\n Index 1 = size class, Index 2 = compositional fraction real(kind=dp), intent(out) :: V_w_tot water requirement from the water column [m3 m-2] Return Value type(Result) returned Result object                                       ! returned Result object abstract interface public function resuspendSediment (Me, M_resusp, FS) result(r) compute resuspension from bed sediment Arguments Type Intent Optional Attributes Name class( BedSediment ) :: Me self-reference real(kind=dp), intent(in), allocatable :: M_resusp (:) array of sediment masses to be resuspended [kg m-2]. Index = size class[1,...,S] type(FineSediment1), intent(out), allocatable :: FS (:,:) array returning resuspended fine sediment. Index 1 = size class, Index 2 = layer Return Value type(Result) returned Result object Derived Types type, public :: BedSedimentLayerElement Components Type Visibility Attributes Name Initial class(BedSedimentLayer), public, allocatable :: item type, public, abstract :: BedSediment Components Type Visibility Attributes Name Initial character(len=256), public :: name class( BedSedimentLayerElement ), public, allocatable :: colBedSedimentLayers (:) integer, public :: nSizeClasses integer, public :: nLayers integer, public :: nfComp integer, public :: allst Type-Bound Procedures procedure(createBedSediment), public :: create procedure(destroyBedSediment), public :: destroy procedure(depositSediment), public :: deposit procedure(resuspendSediment), public :: resuspend procedure, public :: Af_sediment => Get_Af_sediment procedure, public :: Cf_sediment => Get_Cf_sediment procedure, public :: Aw_sediment => Get_Aw_sediment procedure, public :: Cw_sediment => Get_Cw_sediment procedure, public :: Mf_sediment => Get_Mf_sediment procedure, public :: Mf_sed_all => Get_Mf_sed_all Functions public pure function Get_Af_sediment (Me, S) result(Af_sediment) return available capacity for fine sediment of a specified size class Arguments Type Intent Optional Attributes Name class( BedSediment ), intent(in) :: Me the BedSediment instance integer, intent(in) :: S size class Return Value real(kind=dp) return value public pure function Get_Cf_sediment (Me, S) result(Cf_sediment) return capacity for fine sediment of a specified size class Arguments Type Intent Optional Attributes Name class( BedSediment ), intent(in) :: Me the BedSediment instance integer, intent(in) :: S size class Return Value real(kind=dp) return value public pure function Get_Aw_sediment (Me, S) result(Aw_sediment) return available capacity for water associated with a specified size class Arguments Type Intent Optional Attributes Name class( BedSediment ), intent(in) :: Me the BedSediment instance integer, intent(in) :: S size class Return Value real(kind=dp) return value public pure function Get_Cw_sediment (Me, S) result(Cw_sediment) return capacity for water associated with a specified size class Arguments Type Intent Optional Attributes Name class( BedSediment ), intent(in) :: Me the BedSediment instance integer, intent(in) :: S size class Return Value real(kind=dp) return value public pure function Get_Mf_sediment (Me, S) result(Mf_sediment) return fine sediment mass in a specified size class Arguments Type Intent Optional Attributes Name class( BedSediment ), intent(in) :: Me the BedSediment instance integer, intent(in) :: S size class Return Value real(kind=dp) return value public pure function Get_Mf_sed_all (Me, S) result(Mf_sed_all) return fine sediment mass for all size classes Arguments Type Intent Optional Attributes Name class( BedSediment ), intent(in) :: Me the BedSediment instance integer, intent(in) :: S size class Return Value real(kind=dp) return value","tags":"","loc":"module/spcbedsediment.html"},{"title":"main – NanoFASE","text":"Uses: Globals UtilModule ResultModule classRiverReach1 classEnvironment1 Variables start finish r x y s t i env Variables Type Attributes Name Initial real :: start real :: finish type(Result) :: r integer :: x integer :: y integer :: s integer :: t integer :: i type(Environment1) :: env","tags":"","loc":"program/main.html"}]}